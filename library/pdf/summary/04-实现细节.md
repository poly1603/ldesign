# @ldesign/pdf 实现细节

## 核心技术实现

### 1. PDF文档解析与加载

#### PDF.js集成
我们选择Mozilla的PDF.js作为PDF解析引擎，它是目前最成熟和功能完整的JavaScript PDF解析库。版本固定为3.11.174，确保稳定性和兼容性。

```typescript
// PDF.js配置和初始化
import * as pdfjsLib from 'pdfjs-dist'

// 统一配置Worker路径，避免版本冲突
pdfjsLib.GlobalWorkerOptions.workerSrc = '/pdf.worker.min.js'

// 文档加载实现
async loadDocument(input: PdfInput): Promise<PDFDocumentProxy> {
  const loadingTask = pdfjsLib.getDocument({
    data: input,
    cMapUrl: '/cmaps/',
    cMapPacked: true,
    enableXfa: true, // 支持XFA表单
  })
  
  // 监听加载进度
  loadingTask.onProgress = (progress) => {
    const percent = (progress.loaded / progress.total) * 100
    this.eventManager.emit('loadProgress', percent)
  }
  
  return await loadingTask.promise
}
```

#### 多种输入方式处理
支持URL、File对象、ArrayBuffer、Uint8Array等多种输入方式：

```typescript
private async processInput(input: PdfInput): Promise<any> {
  if (typeof input === 'string') {
    // URL处理
    return { url: input }
  } else if (input instanceof File) {
    // File对象处理
    const arrayBuffer = await this.fileToArrayBuffer(input)
    return { data: new Uint8Array(arrayBuffer) }
  } else if (input instanceof ArrayBuffer) {
    // ArrayBuffer处理
    return { data: new Uint8Array(input) }
  } else if (input instanceof Uint8Array) {
    // Uint8Array处理
    return { data: input }
  }
  
  throw new Error('Unsupported input type')
}
```

### 2. 页面渲染实现

#### Canvas渲染引擎
使用Canvas 2D API进行高性能渲染：

```typescript
private async renderToCanvas(
  page: PDFPageProxy,
  container: HTMLElement,
  viewport: any,
  options: RenderOptions
): Promise<void> {
  const canvas = document.createElement('canvas')
  const context = canvas.getContext('2d')
  
  if (!context) {
    throw new Error('Failed to get canvas context')
  }
  
  // 设置canvas尺寸
  canvas.width = viewport.width
  canvas.height = viewport.height
  
  // 高DPI支持
  if (options.useHighQuality) {
    const devicePixelRatio = window.devicePixelRatio || 1
    canvas.width = viewport.width * devicePixelRatio
    canvas.height = viewport.height * devicePixelRatio
    canvas.style.width = `${viewport.width}px`
    canvas.style.height = `${viewport.height}px`
    context.scale(devicePixelRatio, devicePixelRatio)
  }
  
  // 渲染页面
  const renderContext = {
    canvasContext: context,
    viewport,
    intent: 'display',
    enableWebGL: true, // 启用WebGL加速
  }
  
  const renderTask = page.render(renderContext)
  this.renderTasks.set(container, renderTask)
  
  await renderTask.promise
  container.appendChild(canvas)
}
```

#### 文本层实现
实现可选择的文本层，支持文本选择和搜索：

```typescript
private async renderTextLayer(
  page: PDFPageProxy,
  container: HTMLElement,
  viewport: any
): Promise<void> {
  const textContent = await page.getTextContent()
  
  const textLayerDiv = document.createElement('div')
  textLayerDiv.className = 'textLayer'
  textLayerDiv.style.position = 'absolute'
  textLayerDiv.style.left = '0'
  textLayerDiv.style.top = '0'
  textLayerDiv.style.right = '0'
  textLayerDiv.style.bottom = '0'
  textLayerDiv.style.overflow = 'hidden'
  textLayerDiv.style.opacity = '0.2'
  textLayerDiv.style.lineHeight = '1.0'
  
  // 渲染文本项
  textContent.items.forEach((item: any) => {
    const textDiv = document.createElement('span')
    textDiv.textContent = item.str
    textDiv.style.position = 'absolute'
    textDiv.style.whiteSpace = 'pre'
    textDiv.style.color = 'transparent'
    textDiv.style.userSelect = 'text'
    
    // 计算文本位置
    const transform = item.transform
    const x = transform[4]
    const y = viewport.height - transform[5]
    const fontSize = Math.abs(transform[0])
    
    textDiv.style.left = `${x}px`
    textDiv.style.top = `${y - fontSize}px`
    textDiv.style.fontSize = `${fontSize}px`
    
    textLayerDiv.appendChild(textDiv)
  })
  
  container.appendChild(textLayerDiv)
}
```

### 3. 缓存系统实现

#### LRU缓存算法
实现基于LRU（最近最少使用）算法的智能缓存：

```typescript
class LRUCache<T> {
  private cache = new Map<string, CacheNode<T>>()
  private head: CacheNode<T>
  private tail: CacheNode<T>
  private capacity: number
  
  constructor(capacity: number) {
    this.capacity = capacity
    this.head = { key: '', value: null as any, prev: null, next: null }
    this.tail = { key: '', value: null as any, prev: null, next: null }
    this.head.next = this.tail
    this.tail.prev = this.head
  }
  
  get(key: string): T | null {
    const node = this.cache.get(key)
    if (!node) return null
    
    // 移动到头部（最近使用）
    this.moveToHead(node)
    return node.value
  }
  
  set(key: string, value: T): void {
    const existingNode = this.cache.get(key)
    
    if (existingNode) {
      existingNode.value = value
      this.moveToHead(existingNode)
    } else {
      const newNode: CacheNode<T> = {
        key,
        value,
        prev: null,
        next: null,
      }
      
      if (this.cache.size >= this.capacity) {
        // 删除尾部节点（最少使用）
        const tail = this.removeTail()
        this.cache.delete(tail.key)
      }
      
      this.cache.set(key, newNode)
      this.addToHead(newNode)
    }
  }
  
  private moveToHead(node: CacheNode<T>): void {
    this.removeNode(node)
    this.addToHead(node)
  }
  
  private removeNode(node: CacheNode<T>): void {
    if (node.prev) node.prev.next = node.next
    if (node.next) node.next.prev = node.prev
  }
  
  private addToHead(node: CacheNode<T>): void {
    node.prev = this.head
    node.next = this.head.next
    if (this.head.next) this.head.next.prev = node
    this.head.next = node
  }
  
  private removeTail(): CacheNode<T> {
    const lastNode = this.tail.prev!
    this.removeNode(lastNode)
    return lastNode
  }
}
```

#### 分层缓存实现
实现多层缓存系统，提高缓存效率：

```typescript
class HierarchicalCacheManager {
  private l1Cache: LRUCache<any> // 内存缓存
  private l2Cache: Map<string, any> // 会话缓存
  private l3Cache: IDBDatabase | null = null // IndexedDB缓存
  
  constructor() {
    this.l1Cache = new LRUCache(50) // L1缓存50项
    this.l2Cache = new Map()
    this.initIndexedDB()
  }
  
  async get(key: string): Promise<any> {
    // L1缓存查找
    let value = this.l1Cache.get(key)
    if (value) return value
    
    // L2缓存查找
    value = this.l2Cache.get(key)
    if (value) {
      this.l1Cache.set(key, value) // 提升到L1
      return value
    }
    
    // L3缓存查找
    value = await this.getFromIndexedDB(key)
    if (value) {
      this.l2Cache.set(key, value) // 提升到L2
      this.l1Cache.set(key, value) // 提升到L1
      return value
    }
    
    return null
  }
  
  async set(key: string, value: any): Promise<void> {
    this.l1Cache.set(key, value)
    this.l2Cache.set(key, value)
    await this.setToIndexedDB(key, value)
  }
}
```

### 4. 事件系统实现

#### 发布-订阅模式
实现高效的事件系统，支持松耦合通信：

```typescript
class EventManager {
  private listeners = new Map<string, Set<Function>>()
  private onceListeners = new Map<string, Set<Function>>()
  
  on(event: string, listener: Function): void {
    if (!this.listeners.has(event)) {
      this.listeners.set(event, new Set())
    }
    this.listeners.get(event)!.add(listener)
  }
  
  once(event: string, listener: Function): void {
    if (!this.onceListeners.has(event)) {
      this.onceListeners.set(event, new Set())
    }
    this.onceListeners.get(event)!.add(listener)
  }
  
  emit(event: string, ...args: any[]): void {
    // 处理普通监听器
    const listeners = this.listeners.get(event)
    if (listeners) {
      listeners.forEach(listener => {
        try {
          listener(...args)
        } catch (error) {
          console.error(`Error in event listener for ${event}:`, error)
        }
      })
    }
    
    // 处理一次性监听器
    const onceListeners = this.onceListeners.get(event)
    if (onceListeners) {
      onceListeners.forEach(listener => {
        try {
          listener(...args)
        } catch (error) {
          console.error(`Error in once event listener for ${event}:`, error)
        }
      })
      this.onceListeners.delete(event) // 执行后删除
    }
  }
  
  off(event: string, listener?: Function): void {
    if (!listener) {
      // 删除所有监听器
      this.listeners.delete(event)
      this.onceListeners.delete(event)
    } else {
      // 删除特定监听器
      this.listeners.get(event)?.delete(listener)
      this.onceListeners.get(event)?.delete(listener)
    }
  }
}
```

### 5. 搜索功能实现

#### 全文搜索算法
实现高效的全文搜索功能：

```typescript
class TextSearchEngine {
  private documentText: Map<number, string> = new Map()
  
  async indexDocument(document: PDFDocumentProxy): Promise<void> {
    const numPages = document.numPages
    
    for (let i = 1; i <= numPages; i++) {
      const page = await document.getPage(i)
      const textContent = await page.getTextContent()
      const pageText = textContent.items
        .map((item: any) => item.str)
        .join(' ')
      
      this.documentText.set(i, pageText)
    }
  }
  
  search(query: string, options: SearchOptions): SearchResult[] {
    const results: SearchResult[] = []
    const regex = this.buildSearchRegex(query, options)
    
    for (const [pageNumber, text] of this.documentText) {
      const matches = Array.from(text.matchAll(regex))
      
      matches.forEach((match, index) => {
        results.push({
          pageNumber,
          text: match[0],
          position: this.calculatePosition(match, text),
          matchIndex: results.length,
          totalMatches: 0, // 稍后更新
        })
      })
    }
    
    // 更新总匹配数
    results.forEach(result => {
      result.totalMatches = results.length
    })
    
    return results
  }
  
  private buildSearchRegex(query: string, options: SearchOptions): RegExp {
    let pattern = query
    
    if (!options.useRegex) {
      // 转义特殊字符
      pattern = pattern.replace(/[.*+?^${}()|[\]\\]/g, '\\$&')
    }
    
    if (options.wholeWords) {
      pattern = `\\b${pattern}\\b`
    }
    
    const flags = options.caseSensitive ? 'g' : 'gi'
    return new RegExp(pattern, flags)
  }
}
```

### 6. 性能优化实现

#### 虚拟滚动
实现虚拟滚动，处理大型文档：

```typescript
class VirtualScroller {
  private container: HTMLElement
  private itemHeight: number
  private visibleCount: number
  private totalCount: number
  private scrollTop: number = 0
  
  constructor(container: HTMLElement, itemHeight: number) {
    this.container = container
    this.itemHeight = itemHeight
    this.visibleCount = Math.ceil(container.clientHeight / itemHeight) + 2
    this.setupScrollListener()
  }
  
  private setupScrollListener(): void {
    this.container.addEventListener('scroll', () => {
      this.scrollTop = this.container.scrollTop
      this.updateVisibleItems()
    })
  }
  
  private updateVisibleItems(): void {
    const startIndex = Math.floor(this.scrollTop / this.itemHeight)
    const endIndex = Math.min(startIndex + this.visibleCount, this.totalCount)
    
    // 只渲染可见范围内的项目
    this.renderItems(startIndex, endIndex)
  }
  
  private renderItems(startIndex: number, endIndex: number): void {
    // 清除现有项目
    this.container.innerHTML = ''
    
    // 创建占位空间
    const spacerTop = document.createElement('div')
    spacerTop.style.height = `${startIndex * this.itemHeight}px`
    this.container.appendChild(spacerTop)
    
    // 渲染可见项目
    for (let i = startIndex; i < endIndex; i++) {
      const item = this.createItem(i)
      this.container.appendChild(item)
    }
    
    // 创建底部占位空间
    const spacerBottom = document.createElement('div')
    const remainingHeight = (this.totalCount - endIndex) * this.itemHeight
    spacerBottom.style.height = `${remainingHeight}px`
    this.container.appendChild(spacerBottom)
  }
}
```

#### Web Workers集成
使用Web Workers进行后台处理：

```typescript
class WorkerManager {
  private workers: Worker[] = []
  private taskQueue: Task[] = []
  private workerCount: number
  
  constructor(workerScript: string, workerCount: number = 4) {
    this.workerCount = workerCount
    this.initWorkers(workerScript)
  }
  
  private initWorkers(workerScript: string): void {
    for (let i = 0; i < this.workerCount; i++) {
      const worker = new Worker(workerScript)
      worker.onmessage = (event) => {
        this.handleWorkerMessage(i, event.data)
      }
      this.workers.push(worker)
    }
  }
  
  async executeTask<T>(taskData: any): Promise<T> {
    return new Promise((resolve, reject) => {
      const task: Task = {
        id: Date.now() + Math.random(),
        data: taskData,
        resolve,
        reject,
      }
      
      const availableWorker = this.findAvailableWorker()
      if (availableWorker !== -1) {
        this.assignTaskToWorker(availableWorker, task)
      } else {
        this.taskQueue.push(task)
      }
    })
  }
  
  private findAvailableWorker(): number {
    // 简化实现：返回第一个worker
    // 实际实现应该跟踪worker状态
    return 0
  }
  
  private assignTaskToWorker(workerIndex: number, task: Task): void {
    this.workers[workerIndex].postMessage({
      taskId: task.id,
      data: task.data,
    })
  }
}
```

这些实现细节展示了@ldesign/pdf如何通过精心设计的算法和数据结构，实现高性能、可扩展的PDF预览功能。每个模块都经过优化，确保在各种使用场景下都能提供优秀的性能表现。
