<!-- 41472049-a26c-421e-a13c-e2d278dff37a 06c01998-a378-4311-a411-208182ca7e22 -->
# @ldesign/chart 双引擎架构升级计划

## 总体策略

采用**渐进式双引擎架构**：

- **阶段1（1-2周）**：修复现有代码，确保示例可运行
- **阶段2（2-3周）**：设计并实现引擎抽象层
- **阶段3（3-4周）**：集成 VChart 引擎
- **阶段4（2-3周）**：添加 VChart 独有功能（小程序、高级图表）
- **阶段5（1-2周）**：优化、测试和文档

**总时间**：约 9-14 周（2-3个月）

---

## 阶段1：修复和验证现有实现（1-2周）

### 关键文件

- `libraries/chart/examples/vue-example/`
- `libraries/chart/examples/react-example/`
- `libraries/chart/src/index.ts`
- `libraries/chart/rollup.config.js`

### 任务

1. **构建和修复依赖**

   - 检查 `package.json` 依赖是否完整
   - 修复 TypeScript 编译错误
   - 确保 rollup 构建成功

2. **修复 Vue 示例**

   - 检查 `examples/vue-example/src/App.vue` 中的导入
   - 修复组件注册问题
   - 确保 `pnpm dev` 可以正常运行

3. **修复 React 示例**

   - 检查 `examples/react-example/src/App.tsx` 中的导入
   - 修复类型定义问题
   - 确保示例可以正常预览

4. **验证所有图表类型**

   - 测试 line, bar, pie, scatter, radar, waterfall, funnel 等
   - 验证性能优化功能（cache, virtual, worker）
   - 确认所有新增功能正常工作（v1.3.0）

---

## 阶段2：设计引擎抽象层（2-3周）

### 核心架构设计

创建引擎无关的抽象层，使图表库可以同时支持 ECharts 和 VChart。

### 新增文件结构

```
src/
├── engines/
│   ├── base/
│   │   ├── engine-interface.ts       # 引擎接口定义
│   │   ├── chart-instance.ts         # 图表实例抽象
│   │   └── config-adapter.ts         # 配置适配器基类
│   ├── echarts/
│   │   ├── echarts-engine.ts         # ECharts 引擎实现
│   │   ├── echarts-adapter.ts        # ECharts 配置适配器
│   │   └── echarts-loader.ts         # 移动现有加载器
│   ├── vchart/
│   │   ├── vchart-engine.ts          # VChart 引擎实现
│   │   ├── vchart-adapter.ts         # VChart 配置适配器
│   │   └── vchart-loader.ts          # VChart 动态加载器
│   └── engine-manager.ts             # 引擎管理器（选择和切换）
├── core/
│   └── chart.ts                      # 重构，使用引擎抽象
└── config/
    ├── universal/                    # 引擎无关的配置生成器
    │   ├── line.ts
    │   ├── bar.ts
    │   └── ...
    └── generators/                   # 保留 ECharts 专用生成器
```

### 关键接口设计

```typescript
// src/engines/base/engine-interface.ts
export interface ChartEngine {
  name: 'echarts' | 'vchart';
  version: string;
  
  // 生命周期
  init(container: HTMLElement, options?: any): Promise<EngineInstance>;
  dispose(): void;
  
  // 配置
  setOption(option: any): void;
  getOption(): any;
  
  // 渲染
  resize(): void;
  render(): void;
  
  // 事件
  on(event: string, handler: Function): void;
  off(event: string, handler?: Function): void;
  
  // 导出
  getDataURL(options?: any): string;
  
  // 能力检测
  supports(feature: ChartFeature): boolean;
}

// 特性枚举
export enum ChartFeature {
  MINI_PROGRAM = 'miniProgram',
  WEB_WORKER = 'webWorker',
  VIRTUAL_RENDER = 'virtualRender',
  STORY_MODE = 'storyMode',
  THREE_D = '3d',
}
```

### 配置适配器

```typescript
// 将通用配置转换为引擎特定配置
export abstract class ConfigAdapter {
  abstract adapt(universalConfig: UniversalChartConfig): EngineSpecificConfig;
  abstract reverse(engineConfig: EngineSpecificConfig): UniversalChartConfig;
}
```

---

## 阶段3：集成 VChart 引擎（3-4周）

### 依赖安装

```json
{
  "dependencies": {
    "@visactor/vchart": "^1.x.x",
    "@visactor/vrender": "^0.x.x"
  },
  "peerDependencies": {
    "echarts": "^5.4.0",
    "@visactor/vchart": "^1.0.0"
  }
}
```

### 实现 VChart 引擎

**文件**：`src/engines/vchart/vchart-engine.ts`

```typescript
import * as VChart from '@visactor/vchart';

export class VChartEngine implements ChartEngine {
  private instance?: VChart.VChart;
  
  async init(container: HTMLElement, options?: any) {
    this.instance = new VChart.VChart(
      { /* spec */ },
      { dom: container, ...options }
    );
    await this.instance.renderAsync();
    return this;
  }
  
  setOption(option: any) {
    this.instance?.updateSpec(option);
  }
  
  supports(feature: ChartFeature): boolean {
    switch(feature) {
      case ChartFeature.MINI_PROGRAM: return true;
      case ChartFeature.STORY_MODE: return true;
      case ChartFeature.THREE_D: return true;
      default: return false;
    }
  }
  
  // ... 其他方法实现
}
```

### 配置适配器

**文件**：`src/engines/vchart/vchart-adapter.ts`

```typescript
export class VChartConfigAdapter extends ConfigAdapter {
  adapt(config: UniversalChartConfig): VChartSpec {
    // 将通用配置转换为 VChart Spec
    return {
      type: this.mapChartType(config.type),
      data: this.adaptData(config.data),
      axes: this.adaptAxes(config),
      series: this.adaptSeries(config),
      // ...
    };
  }
  
  private mapChartType(type: ChartType): VChartType {
    const mapping = {
      'line': 'line',
      'bar': 'bar',
      'pie': 'pie',
      // ...
    };
    return mapping[type] || type;
  }
}
```

### 引擎管理器

**文件**：`src/engines/engine-manager.ts`

```typescript
export class EngineManager {
  private engines = new Map<string, ChartEngine>();
  private defaultEngine: 'echarts' | 'vchart' = 'echarts';
  
  register(name: string, engine: ChartEngine) {
    this.engines.set(name, engine);
  }
  
  select(name: string, feature?: ChartFeature): ChartEngine {
    // 如果指定引擎，直接返回
    if (name) return this.engines.get(name)!;
    
    // 根据特性自动选择
    if (feature) {
      for (const [_, engine] of this.engines) {
        if (engine.supports(feature)) return engine;
      }
    }
    
    // 返回默认引擎
    return this.engines.get(this.defaultEngine)!;
  }
}
```

### 重构 Chart 核心类

**文件**：`src/core/chart.ts`（重构）

```typescript
export class Chart implements ChartInstance {
  private engine: ChartEngine;
  private engineInstance?: any;
  
  constructor(container: HTMLElement, config: ChartConfig) {
    // 选择引擎
    this.engine = engineManager.select(
      config.engine || 'echarts',
      this.detectRequiredFeature(config)
    );
    
    this.init();
  }
  
  private detectRequiredFeature(config: ChartConfig): ChartFeature | undefined {
    // 如果需要小程序支持，选择 VChart
    if (config.platform === 'miniprogram') {
      return ChartFeature.MINI_PROGRAM;
    }
    // 如果需要 3D，选择 VChart
    if (config.type.includes('3d')) {
      return ChartFeature.THREE_D;
    }
    return undefined;
  }
  
  private async init() {
    // 生成通用配置
    const universalConfig = await configGenerator.generate(this.config);
    
    // 适配为引擎特定配置
    const adapter = this.engine.getAdapter();
    const engineConfig = adapter.adapt(universalConfig);
    
    // 初始化引擎
    this.engineInstance = await this.engine.init(this.container, engineConfig);
  }
}
```

---

## 阶段4：VChart 独有功能（3-4周）

### 小程序支持

**文件**：`src/platforms/miniprogram/`

```typescript
// 微信小程序适配器
export class WechatMiniProgramAdapter {
  createChart(selector: string, config: ChartConfig) {
    // 使用 VChart 的小程序版本
    const chart = new Chart(selector, {
      ...config,
      engine: 'vchart',
      platform: 'wechat-miniprogram'
    });
    return chart;
  }
}
```

**新增适配器**：

- `src/platforms/miniprogram/wechat.ts` - 微信小程序
- `src/platforms/miniprogram/alipay.ts` - 支付宝小程序
- `src/platforms/miniprogram/taro.ts` - Taro 跨平台

### 高级图表类型（VChart 专属）

**新增生成器**：

```
src/config/generators/vchart/
├── 3d-bar.ts          # 3D 柱状图
├── 3d-scatter.ts      # 3D 散点图
├── sunburst.ts        # 旭日图
├── treemap.ts         # 矩形树图
├── sankey.ts          # 桑基图（增强版）
├── liquid.ts          # 水球图
└── word-cloud.ts      # 词云图
```

### 数据故事模式

**文件**：`src/features/story-mode.ts`

```typescript
export class StoryMode {
  private timeline: StoryTimeline;
  
  createStory(charts: Chart[], config: StoryConfig) {
    // 使用 VChart 的 Story 功能
    // 实现图表切换、动画过渡等
  }
  
  addChapter(chart: Chart, duration: number, narration?: string) {
    // 添加故事章节
  }
  
  play() {
    // 播放故事
  }
}
```

---

## 阶段5：优化、测试和文档（1-2周）

### 自动引擎选择

添加智能引擎选择逻辑：

```typescript
// 配置示例
const chart = new Chart(container, {
  type: 'bar',
  data: myData,
  // 不指定引擎，自动选择
  // engine: 'auto',  // 默认值
  
  // 或显式指定
  // engine: 'echarts',
  // engine: 'vchart',
});

// 特定功能自动选择 VChart
const miniChart = new Chart(container, {
  type: 'line',
  platform: 'wechat-miniprogram',  // 自动使用 VChart
});

const chart3D = new Chart(container, {
  type: '3d-bar',  // 自动使用 VChart
});
```

### 性能对比测试

**文件**：`benchmarks/engine-comparison.ts`

对比 ECharts vs VChart：

- 初始化时间
- 渲染性能
- 内存占用
- 大数据处理
- 动画流畅度

### 框架适配器更新

更新 Vue/React/Lit 适配器以支持引擎选择：

```vue
<!-- Vue 示例 -->
<Chart 
  type="bar" 
  :data="data"
  engine="vchart"
  platform="wechat-miniprogram"
/>
```



```jsx
// React 示例
<Chart 
  type="3d-scatter" 
  data={data}
  engine="vchart"
/>
```

### 文档更新

新增文档：

- `docs/engines.md` - 引擎选择指南
- `docs/vchart-features.md` - VChart 独有功能
- `docs/miniprogram.md` - 小程序开发指南
- `docs/migration.md` - 从纯 ECharts 迁移指南
- `docs/engine-comparison.md` - 引擎对比

更新现有文档：

- `README.md` - 添加双引擎说明
- `docs/api-reference.md` - 添加 engine 选项
- `docs/quick-start.md` - 添加引擎选择示例

---

## 技术亮点

### 1. 统一 API，多引擎支持

开发者无需学习两套 API，通过配置自动选择最优引擎。

### 2. 按需加载

只有在实际使用时才加载对应引擎，减小初始包体积。

### 3. 渐进式增强

保持 100% 向后兼容，现有 ECharts 代码无需修改。

### 4. 智能引擎选择

根据平台、图表类型、功能需求自动选择最合适的引擎。

### 5. 性能优化继承

现有的缓存、虚拟渲染、Worker 等优化可复用到两个引擎。

---

## 风险评估和缓解

### 风险1：两个引擎配置差异大

**缓解**：设计完善的配置适配器，充分测试边缘情况。

### 风险2：包体积增大

**缓解**：严格按需加载，提供纯 ECharts 或纯 VChart 的构建版本。

### 风险3：维护成本增加

**缓解**：通过抽象层隔离，大部分代码引擎无关。

### 风险4：性能差异

**缓解**：提供详细的性能对比文档，让开发者根据场景选择。

---

## 成功标准

- ✅ 现有示例正常运行
- ✅ 支持 ECharts 和 VChart 双引擎
- ✅ 小程序平台完美支持
- ✅ 至少新增 5 种 VChart 独有图表
- ✅ 100% 向后兼容
- ✅ 包体积增加 < 30%（按需加载）
- ✅ 性能无明显下降
- ✅ 完整的文档和示例
- ✅ 测试覆盖率 > 60%

---

## 交付物清单

### 代码

- [ ] 引擎抽象层（5-8个文件）
- [ ] VChart 引擎实现（10-15个文件）
- [ ] 小程序适配器（3-5个文件）
- [ ] VChart 专属图表（5-10个文件）
- [ ] 更新的框架适配器（Vue/React/Lit）
- [ ] 性能基准测试

### 示例

- [ ] Vue 示例（ECharts + VChart 对比）
- [ ] React 示例（ECharts + VChart 对比）
- [ ] 小程序示例（微信/支付宝）
- [ ] 3D 图表示例
- [ ] 数据故事模式示例

### 文档

- [ ] 引擎选择指南
- [ ] VChart 功能文档
- [ ] 小程序开发指南
- [ ] 引擎对比文档
- [ ] 迁移指南
- [ ] API 文档更新

### 配置

- [ ] 更新 package.json（新依赖）
- [ ] 更新 rollup.config.js（多引擎构建）
- [ ] 更新 tsconfig.json（新模块）
- [ ] CI/CD 配置更新

### To-dos

- [ ] 修复并验证现有 Vue 和 React 示例可正常运行
- [ ] 设计引擎抽象层接口和架构
- [ ] 实现 ChartEngine 接口和 EngineManager
- [ ] 将现有 ECharts 代码重构为引擎实现
- [ ] 实现 VChart 引擎和配置适配器
- [ ] 添加小程序平台支持（微信、支付宝）
- [ ] 添加 VChart 独有图表类型（3D、旭日图等）
- [ ] 更新 Vue/React/Lit 框架适配器支持引擎选择
- [ ] 创建双引擎对比示例和小程序示例
- [ ] 编写完整文档（引擎指南、小程序指南、API文档）
- [ ] 性能测试、优化和测试覆盖