/**
 * ÂºÄÂèëÁéØÂ¢ÉÊó•ÂøóÂ∑•ÂÖ∑
 * Êèê‰æõÊõ¥Â•ΩÁöÑÈîôËØØÊèêÁ§∫ÂíåË∞ÉËØï‰ø°ÊÅØ
 */

// ËΩªÈáèANSIÈ¢úËâ≤Â∑•ÂÖ∑ÔºåÈÅøÂÖçÂØπÂ§ñÈÉ®‰æùËµñÁöÑÂº∫ÁªëÂÆö
const chalk = {
  gray: (s: string) => `\x1b[90m${s}\x1b[0m`,
  blue: (s: string) => `\x1b[34m${s}\x1b[0m`,
  cyan: (s: string) => `\x1b[36m${s}\x1b[0m`,
  yellow: (s: string) => `\x1b[33m${s}\x1b[0m`,
  red: (s: string) => `\x1b[31m${s}\x1b[0m`,
  green: (s: string) => `\x1b[32m${s}\x1b[0m`,
  magenta: (s: string) => `\x1b[35m${s}\x1b[0m`,
  bold: {
    white: (s: string) => `\x1b[1m\x1b[37m${s}\x1b[0m`,
  },
}

export type LogLevel = 'debug' | 'info' | 'warn' | 'error' | 'success'

export interface LogOptions {
  level?: LogLevel
  timestamp?: boolean
  prefix?: string
  group?: boolean
}

export class DevLogger {
  private static instance: DevLogger
  private level: LogLevel = 'info'
  private enableTimestamp = true

  static getInstance(): DevLogger {
    if (!DevLogger.instance) {
      DevLogger.instance = new DevLogger()
    }
    return DevLogger.instance
  }

  setLevel(level: LogLevel) {
    this.level = level
  }

  setTimestamp(enabled: boolean) {
    this.enableTimestamp = enabled
  }

  private shouldLog(level: LogLevel): boolean {
    const levels = ['debug', 'info', 'warn', 'error', 'success']
    const currentIndex = levels.indexOf(this.level)
    const messageIndex = levels.indexOf(level)
    return messageIndex >= currentIndex
  }

  private formatMessage(
    level: LogLevel,
    message: string,
    options: LogOptions = {},
  ): string {
    let formatted = ''

    // Êó∂Èó¥Êà≥
    if (this.enableTimestamp && options.timestamp !== false) {
      const timestamp = new Date().toLocaleTimeString()
      formatted += chalk.gray(`[${timestamp}] `)
    }

    // Á∫ßÂà´Ê†áËØÜ
    const levelColors = {
      debug: chalk.blue,
      info: chalk.cyan,
      warn: chalk.yellow,
      error: chalk.red,
      success: chalk.green,
    }

    const levelIcons = {
      debug: 'üîç',
      info: '‚ÑπÔ∏è',
      warn: '‚ö†Ô∏è',
      error: '‚ùå',
      success: '‚úÖ',
    }

    formatted += levelColors[level](
      `${levelIcons[level]} [${level.toUpperCase()}]`,
    )

    // ÂâçÁºÄ
    if (options.prefix) {
      formatted += chalk.magenta(` [${options.prefix}]`)
    }

    formatted += ` ${message}`

    return formatted
  }

  debug(message: string, options: LogOptions = {}) {
    if (this.shouldLog('debug')) {
      const formatted = this.formatMessage('debug', message, options)
      console.log(formatted)
    }
  }

  info(message: string, options: LogOptions = {}) {
    if (this.shouldLog('info')) {
      const formatted = this.formatMessage('info', message, options)
      console.log(formatted)
    }
  }

  warn(message: string, options: LogOptions = {}) {
    if (this.shouldLog('warn')) {
      const formatted = this.formatMessage('warn', message, options)
      console.warn(formatted)
    }
  }

  error(message: string, error?: Error, options: LogOptions = {}) {
    if (this.shouldLog('error')) {
      const formatted = this.formatMessage('error', message, options)
      console.error(formatted)

      if (error) {
        console.error(chalk.red('Stack trace:'))
        console.error(chalk.gray(error.stack))
      }
    }
  }

  success(message: string, options: LogOptions = {}) {
    if (this.shouldLog('success')) {
      const formatted = this.formatMessage('success', message, options)
      console.log(formatted)
    }
  }

  group(title: string, callback: () => void, options: LogOptions = {}) {
    if (options.group !== false) {
      const formatted = this.formatMessage('info', title, options)
      console.group(formatted)
      callback()
      console.groupEnd()
    }
    else {
      callback()
    }
  }

  table(data: any[], title?: string) {
    if (title) {
      this.info(title)
    }
    try {
      // ‰ªÖÂΩì console.table ÂèØÁî®Êó∂ÂÜçË∞ÉÁî®
      if (typeof (console as any).table === 'function') {
        ; (console as any).table(data)
      }
      else {
        console.log(JSON.stringify(data, null, 2))
      }
    }
    catch {
      console.log(JSON.stringify(data))
    }
  }

  progress(current: number, total: number, message: string) {
    const safeTotal = Math.max(1, total)
    const clamped = Math.min(Math.max(current, 0), safeTotal)
    const ratio = clamped / safeTotal
    const percentage = Math.round(ratio * 100)
    const filled = Math.round(percentage / 5)
    const empty = Math.max(0, 20 - filled)
    const progressBar = '‚ñà'.repeat(filled) + '‚ñë'.repeat(empty)
    const formatted = `${chalk.cyan('üìä')} ${message} [${progressBar}] ${percentage}% (${clamped}/${safeTotal})`

    const isTTY = Boolean(process.stdout && process.stdout.isTTY)
    try {
      if (isTTY && typeof (process.stdout as any).clearLine === 'function' && typeof (process.stdout as any).cursorTo === 'function') {
        ; (process.stdout as any).clearLine(0)
          ; (process.stdout as any).cursorTo(0)
        process.stdout.write(formatted)
        if (clamped === safeTotal) process.stdout.write('\n')
      }
      else {
        console.log(formatted)
      }
    }
    catch {
      console.log(formatted)
    }
  }

  spinner(message: string, promise: Promise<any>): Promise<any> {
    const frames = ['‚†ã', '‚†ô', '‚†π', '‚†∏', '‚†º', '‚†¥', '‚†¶', '‚†ß', '‚†á', '‚†è']
    let i = 0

    const isTTY = Boolean(process.stdout && process.stdout.isTTY)
    const interval = setInterval(() => {
      try {
        if (isTTY && typeof (process.stdout as any).clearLine === 'function' && typeof (process.stdout as any).cursorTo === 'function') {
          ; (process.stdout as any).clearLine(0)
            ; (process.stdout as any).cursorTo(0)
          process.stdout.write(`${chalk.cyan(frames[i])} ${message}`)
        }
        else if (i % 5 === 0) {
          // Èùû TTY ÁéØÂ¢É‰∏ãÈôç‰ΩéÂà∑Â±èÈ¢ëÁéá
          console.log(`${chalk.cyan(frames[i])} ${message}`)
        }
      }
      catch {
        // ÂõûÈÄÄÂà∞ÊôÆÈÄöÊó•ÂøóËæìÂá∫
        if (i % 5 === 0) console.log(`${chalk.cyan(frames[i])} ${message}`)
      }
      i = (i + 1) % frames.length
    }, 100)

    return promise
      .then((result) => {
        clearInterval(interval)
        try {
          if (isTTY && typeof (process.stdout as any).clearLine === 'function' && typeof (process.stdout as any).cursorTo === 'function') {
            ; (process.stdout as any).clearLine(0)
              ; (process.stdout as any).cursorTo(0)
          }
        }
        catch { }
        this.success(message)
        return result
      })
      .catch((error) => {
        clearInterval(interval)
        try {
          if (isTTY && typeof (process.stdout as any).clearLine === 'function' && typeof (process.stdout as any).cursorTo === 'function') {
            ; (process.stdout as any).clearLine(0)
              ; (process.stdout as any).cursorTo(0)
          }
        }
        catch { }
        this.error(`${message} Â§±Ë¥•`, error)
        throw error
      })
  }

  banner(title: string, subtitle?: string) {
    const width = 60
    const border = '‚ïê'.repeat(width)

    console.log(chalk.blue(`‚ïî${border}‚ïó`))
    console.log(
      chalk.blue(
        `‚ïë${' '.repeat((width - title.length) / 2)}${chalk.bold.white(
          title,
        )}${' '.repeat(Math.ceil((width - title.length) / 2))}‚ïë`,
      ),
    )

    if (subtitle) {
      console.log(
        chalk.blue(
          `‚ïë${' '.repeat((width - subtitle.length) / 2)}${chalk.gray(
            subtitle,
          )}${' '.repeat(Math.ceil((width - subtitle.length) / 2))}‚ïë`,
        ),
      )
    }

    console.log(chalk.blue(`‚ïö${border}‚ïù`))
  }

  divider(title?: string) {
    const width = 60
    if (title) {
      const padding = Math.max(0, (width - title.length - 2) / 2)
      const line = `${'‚îÄ'.repeat(Math.floor(padding))} ${title} ${'‚îÄ'.repeat(
        Math.ceil(padding),
      )}`
      console.log(chalk.gray(line))
    }
    else {
      console.log(chalk.gray('‚îÄ'.repeat(width)))
    }
  }

  clear() {
    console.clear()
  }

  // ÂåÖÁâπÂÆöÁöÑÊó•ÂøóÊñπÊ≥ï
  package(packageName: string, message: string, level: LogLevel = 'info') {
    this[level](message, { prefix: packageName })
  }

  // ÊûÑÂª∫Áõ∏ÂÖ≥ÁöÑÊó•ÂøóÊñπÊ≥ï
  build(message: string, level: LogLevel = 'info') {
    this[level](message, { prefix: 'BUILD' })
  }

  // ÊµãËØïÁõ∏ÂÖ≥ÁöÑÊó•ÂøóÊñπÊ≥ï
  test(message: string, level: LogLevel = 'info') {
    this[level](message, { prefix: 'TEST' })
  }

  // ÂºÄÂèëÊúçÂä°Âô®Áõ∏ÂÖ≥ÁöÑÊó•ÂøóÊñπÊ≥ï
  server(message: string, level: LogLevel = 'info') {
    this[level](message, { prefix: 'SERVER' })
  }
}

// ÂàõÂª∫ÂÖ®Â±ÄÂÆû‰æã
export const logger = DevLogger.getInstance()

// ‰æøÊç∑ÊñπÊ≥ï
export const log = {
  debug: (message: string, options?: LogOptions) =>
    logger.debug(message, options),
  info: (message: string, options?: LogOptions) =>
    logger.info(message, options),
  warn: (message: string, options?: LogOptions) =>
    logger.warn(message, options),
  error: (message: string, error?: Error, options?: LogOptions) =>
    logger.error(message, error, options),
  success: (message: string, options?: LogOptions) =>
    logger.success(message, options),
  group: (title: string, callback: () => void, options?: LogOptions) =>
    logger.group(title, callback, options),
  table: (data: any[], title?: string) => logger.table(data, title),
  progress: (current: number, total: number, message: string) =>
    logger.progress(current, total, message),
  spinner: (message: string, promise: Promise<any>) =>
    logger.spinner(message, promise),
  banner: (title: string, subtitle?: string) => logger.banner(title, subtitle),
  divider: (title?: string) => logger.divider(title),
  clear: () => logger.clear(),
  package: (packageName: string, message: string, level?: LogLevel) =>
    logger.package(packageName, message, level),
  build: (message: string, level?: LogLevel) => logger.build(message, level),
  test: (message: string, level?: LogLevel) => logger.test(message, level),
  server: (message: string, level?: LogLevel) => logger.server(message, level),
}

// ËÆæÁΩÆÂºÄÂèëÁéØÂ¢ÉÈªòËÆ§ÈÖçÁΩÆ
if (process.env.NODE_ENV === 'development') {
  logger.setLevel('debug')
  logger.setTimestamp(true)
}
