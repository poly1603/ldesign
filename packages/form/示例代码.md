# 通用表单系统实现示例

## 目录结构
```
src/
├── core/
│   ├── index.ts                    # 核心入口
│   ├── layout-engine.ts           # 布局引擎
│   ├── state-manager.ts           # 状态管理
│   ├── animation-manager.ts       # 动画管理
│   ├── button-group.ts            # 按钮组
│   └── utils/
│       ├── space-calculator.ts    # 空间计算
│       ├── responsive-manager.ts  # 响应式管理
│       └── helpers.ts             # 工具函数
├── adapters/
│   ├── react.tsx                  # React适配器
│   ├── vue.ts                     # Vue适配器
│   └── vanilla.ts                 # 原生JS适配器
└── styles/
    ├── core.css                   # 核心样式
    ├── themes/                    # 主题样式
    └── animations.css             # 动画样式
```

## 1. 核心布局引擎实现

### layout-engine.ts
```typescript
export interface LayoutConfig {
  defaultRows?: number;
  columnsPerRow?: number | 'auto';
  spacing?: number;
  buttonPosition?: 'auto' | 'inline' | 'newline';
  animation?: boolean;
  animationDuration?: number;
  responsive?: boolean;
  breakpoints?: BreakpointConfig;
}

export interface LayoutResult {
  rows: number;
  columns: number;
  items: LayoutItem[];
  buttonPosition: ButtonPositionResult;
  availableSpace: SpaceInfo;
}

export class LayoutEngine {
  private container: HTMLElement;
  private config: LayoutConfig;
  private resizeObserver: ResizeObserver;
  private items: HTMLElement[] = [];

  constructor(container: HTMLElement, config: LayoutConfig = {}) {
    this.container = container;
    this.config = {
      defaultRows: 2,
      columnsPerRow: 'auto',
      spacing: 16,
      buttonPosition: 'auto',
      animation: true,
      animationDuration: 300,
      responsive: true,
      ...config
    };

    this.initialize();
  }

  private initialize(): void {
    this.scanFormItems();
    this.setupResizeObserver();
    this.calculateLayout();
  }

  private scanFormItems(): void {
    this.items = Array.from(
      this.container.querySelectorAll('.form-item')
    ) as HTMLElement[];
  }

  calculateLayout(): LayoutResult {
    const spaceInfo = this.calculateSpace();
    const buttonPosition = this.determineButtonPosition(spaceInfo);
    
    return {
      rows: spaceInfo.actualRows,
      columns: spaceInfo.columnsPerRow,
      items: this.createLayoutItems(spaceInfo),
      buttonPosition,
      availableSpace: spaceInfo
    };
  }

  private calculateSpace(): SpaceCalculationResult {
    const containerWidth = this.container.clientWidth;
    const itemMinWidth = 200; // 表单项最小宽度
    const spacing = this.config.spacing!;

    let columnsPerRow: number;
    
    if (this.config.columnsPerRow === 'auto') {
      columnsPerRow = Math.floor((containerWidth + spacing) / (itemMinWidth + spacing));
      columnsPerRow = Math.max(1, Math.min(columnsPerRow, 6)); // 限制在1-6列
    } else {
      columnsPerRow = this.config.columnsPerRow as number;
    }

    const actualRows = Math.ceil(this.items.length / columnsPerRow);
    const lastRowItems = this.items.length % columnsPerRow || columnsPerRow;
    
    // 计算每个表单项的实际宽度
    const availableWidth = containerWidth - (columnsPerRow - 1) * spacing;
    const itemWidth = availableWidth / columnsPerRow;
    
    // 计算最后一行剩余空间
    const lastRowUsedWidth = lastRowItems * itemWidth + (lastRowItems - 1) * spacing;
    const remainingWidth = containerWidth - lastRowUsedWidth;

    return {
      containerWidth,
      columnsPerRow,
      actualRows,
      itemWidth,
      lastRowItems,
      remainingWidth,
      canFitButtons: remainingWidth >= this.getButtonGroupMinWidth()
    };
  }

  private determineButtonPosition(spaceInfo: SpaceCalculationResult): ButtonPositionResult {
    const { canFitButtons, remainingWidth, actualRows } = spaceInfo;
    const buttonMinWidth = this.getButtonGroupMinWidth();

    // 强制配置
    if (this.config.buttonPosition === 'newline') {
      return {
        strategy: 'newline',
        position: { row: actualRows + 1, align: 'right', width: '100%' }
      };
    }

    if (this.config.buttonPosition === 'inline' && canFitButtons) {
      return {
        strategy: 'inline',
        position: { 
          row: actualRows, 
          align: 'right',
          width: `${remainingWidth}px`
        }
      };
    }

    // 自动模式：智能决策
    if (canFitButtons && remainingWidth > buttonMinWidth * 1.2) {
      return {
        strategy: 'inline',
        position: { 
          row: actualRows, 
          align: 'right',
          width: `${remainingWidth}px`
        }
      };
    }

    return {
      strategy: 'newline',
      position: { row: actualRows + 1, align: 'right', width: '100%' }
    };
  }

  private getButtonGroupMinWidth(): number {
    // 三个按钮的最小宽度：展开(80) + 重置(60) + 查询(80) + 间距(20)
    return 240;
  }

  private setupResizeObserver(): void {
    this.resizeObserver = new ResizeObserver(
      this.debounce(() => {
        this.updateLayout();
      }, 100)
    );
    
    this.resizeObserver.observe(this.container);
  }

  updateLayout(): LayoutResult {
    const result = this.calculateLayout();
    this.applyLayout(result);
    return result;
  }

  private applyLayout(layout: LayoutResult): void {
    // 应用表单项布局
    this.applyItemLayout(layout);
    
    // 应用按钮组布局
    this.applyButtonLayout(layout.buttonPosition);
  }

  private debounce(func: Function, delay: number): Function {
    let timeoutId: number;
    return (...args: any[]) => {
      clearTimeout(timeoutId);
      timeoutId = setTimeout(() => func.apply(this, args), delay);
    };
  }

  destroy(): void {
    this.resizeObserver?.disconnect();
  }
}
```

## 2. 状态管理实现

### state-manager.ts
```typescript
export interface FormLayoutState {
  isExpanded: boolean;
  currentRows: number;
  totalRows: number;
  layout: LayoutResult;
  isAnimating: boolean;
  config: LayoutConfig;
}

export type StateAction = 
  | { type: 'EXPAND' }
  | { type: 'COLLAPSE' }
  | { type: 'RESET' }
  | { type: 'UPDATE_CONFIG'; payload: Partial<LayoutConfig> }
  | { type: 'UPDATE_LAYOUT'; payload: LayoutResult };

export class StateManager {
  private state: FormLayoutState;
  private listeners: Map<string, Function[]> = new Map();

  constructor(initialState: Partial<FormLayoutState> = {}) {
    this.state = {
      isExpanded: false,
      currentRows: 0,
      totalRows: 0,
      layout: {} as LayoutResult,
      isAnimating: false,
      config: {},
      ...initialState
    };
  }

  getState(): Readonly<FormLayoutState> {
    return Object.freeze({ ...this.state });
  }

  dispatch(action: StateAction): void {
    const newState = this.reducer(this.state, action);
    const prevState = this.state;
    this.state = newState;

    // 触发状态变更事件
    this.emit('state-change', { prevState, newState, action });
  }

  private reducer(state: FormLayoutState, action: StateAction): FormLayoutState {
    switch (action.type) {
      case 'EXPAND':
        return { ...state, isExpanded: true };
        
      case 'COLLAPSE':
        return { ...state, isExpanded: false };
        
      case 'RESET':
        return { ...state, isExpanded: false };
        
      case 'UPDATE_CONFIG':
        return { ...state, config: { ...state.config, ...action.payload } };
        
      case 'UPDATE_LAYOUT':
        return { ...state, layout: action.payload };
        
      default:
        return state;
    }
  }

  subscribe(event: string, listener: Function): () => void {
    if (!this.listeners.has(event)) {
      this.listeners.set(event, []);
    }
    
    this.listeners.get(event)!.push(listener);
    
    // 返回取消订阅函数
    return () => {
      const eventListeners = this.listeners.get(event);
      if (eventListeners) {
        const index = eventListeners.indexOf(listener);
        if (index > -1) {
          eventListeners.splice(index, 1);
        }
      }
    };
  }

  private emit(event: string, data?: any): void {
    const eventListeners = this.listeners.get(event);
    if (eventListeners) {
      eventListeners.forEach(listener => listener(data));
    }
  }

  destroy(): void {
    this.listeners.clear();
  }
}
```

## 3. 动画管理实现

### animation-manager.ts
```typescript
export interface AnimationConfig {
  duration: number;
  easing: string;
  enableGPU: boolean;
}

export class AnimationManager {
  private config: AnimationConfig;
  private activeAnimations = new Map<string, Animation>();

  constructor(config: AnimationConfig = {}) {
    this.config = {
      duration: 300,
      easing: 'cubic-bezier(0.4, 0.0, 0.2, 1)',
      enableGPU: true,
      ...config
    };
  }

  async expand(elements: HTMLElement[]): Promise<void> {
    if (elements.length === 0) return;

    const animations = elements.map((element, index) => {
      // 预设初始状态
      element.style.opacity = '0';
      element.style.transform = 'translateY(-10px)';
      element.style.display = 'block';

      return element.animate([
        { 
          opacity: 0, 
          transform: 'translateY(-10px)',
          height: '0px'
        },
        { 
          opacity: 1, 
          transform: 'translateY(0px)',
          height: 'auto'
        }
      ], {
        duration: this.config.duration,
        easing: this.config.easing,
        delay: index * 50, // 错开动画时间
        fill: 'forwards'
      });
    });

    // 等待所有动画完成
    await Promise.all(animations.map(anim => anim.finished));
    
    // 清理样式
    elements.forEach(element => {
      element.style.opacity = '';
      element.style.transform = '';
      element.style.height = '';
    });
  }

  async collapse(elements: HTMLElement[]): Promise<void> {
    if (elements.length === 0) return;

    const animations = elements.map((element, index) => {
      const rect = element.getBoundingClientRect();
      
      return element.animate([
        { 
          opacity: 1, 
          transform: 'translateY(0px)',
          height: `${rect.height}px`
        },
        { 
          opacity: 0, 
          transform: 'translateY(-10px)',
          height: '0px'
        }
      ], {
        duration: this.config.duration,
        easing: this.config.easing,
        delay: (elements.length - 1 - index) * 30, // 反向错开
        fill: 'forwards'
      });
    });

    await Promise.all(animations.map(anim => anim.finished));
    
    // 隐藏元素
    elements.forEach(element => {
      element.style.display = 'none';
      element.style.opacity = '';
      element.style.transform = '';
      element.style.height = '';
    });
  }

  async repositionButtons(
    buttonGroup: HTMLElement, 
    newPosition: ButtonPositionResult
  ): Promise<void> {
    if (!this.config.enableGPU) {
      this.applyButtonPosition(buttonGroup, newPosition);
      return;
    }

    // GPU加速的位置变更动画
    const currentRect = buttonGroup.getBoundingClientRect();
    
    // 应用新位置
    this.applyButtonPosition(buttonGroup, newPosition);
    
    const newRect = buttonGroup.getBoundingClientRect();
    const deltaX = currentRect.left - newRect.left;
    const deltaY = currentRect.top - newRect.top;

    if (deltaX === 0 && deltaY === 0) return;

    // 使用transform创建平滑过渡
    buttonGroup.style.transform = `translate(${deltaX}px, ${deltaY}px)`;
    buttonGroup.style.transition = 'none';

    await new Promise(resolve => {
      requestAnimationFrame(() => {
        buttonGroup.style.transform = '';
        buttonGroup.style.transition = `transform ${this.config.duration}ms ${this.config.easing}`;
        
        setTimeout(resolve, this.config.duration);
      });
    });

    buttonGroup.style.transition = '';
  }

  private applyButtonPosition(
    buttonGroup: HTMLElement, 
    position: ButtonPositionResult
  ): void {
    buttonGroup.className = `button-group button-group--${position.strategy}`;
    
    if (position.strategy === 'inline') {
      buttonGroup.style.width = position.position.width;
      buttonGroup.style.justifyContent = 'flex-end';
    } else {
      buttonGroup.style.width = '100%';
      buttonGroup.style.justifyContent = 'flex-end';
    }
  }
}
```

## 4. 按钮组实现

### button-group.ts
```typescript
export interface ButtonConfig {
  expandText?: string;
  collapseText?: string;
  resetText?: string;
  submitText?: string;
  showReset?: boolean;
  showSubmit?: boolean;
}

export class ButtonGroup {
  private container: HTMLElement;
  private buttons = new Map<string, HTMLButtonElement>();
  private config: ButtonConfig;
  private eventBus: EventBus;

  constructor(
    container: HTMLElement, 
    config: ButtonConfig = {},
    eventBus: EventBus
  ) {
    this.container = container;
    this.config = {
      expandText: '展开',
      collapseText: '收起',
      resetText: '重置',
      submitText: '查询',
      showReset: true,
      showSubmit: true,
      ...config
    };
    this.eventBus = eventBus;

    this.createButtons();
    this.bindEvents();
  }

  private createButtons(): void {
    this.container.innerHTML = '';
    this.container.className = 'button-group';

    // 展开/收起按钮
    const expandButton = this.createButton({
      text: this.config.expandText!,
      className: 'btn btn-expand',
      type: 'button'
    });
    this.buttons.set('expand', expandButton);

    // 重置按钮
    if (this.config.showReset) {
      const resetButton = this.createButton({
        text: this.config.resetText!,
        className: 'btn btn-reset',
        type: 'reset'
      });
      this.buttons.set('reset', resetButton);
    }

    // 查询按钮
    if (this.config.showSubmit) {
      const submitButton = this.createButton({
        text: this.config.submitText!,
        className: 'btn btn-submit btn-primary',
        type: 'submit'
      });
      this.buttons.set('submit', submitButton);
    }
  }

  private createButton(config: {
    text: string;
    className: string;
    type: string;
  }): HTMLButtonElement {
    const button = document.createElement('button');
    button.textContent = config.text;
    button.className = config.className;
    button.type = config.type;
    
    this.container.appendChild(button);
    return button;
  }

  private bindEvents(): void {
    // 展开/收起按钮事件
    const expandButton = this.buttons.get('expand');
    if (expandButton) {
      expandButton.addEventListener('click', (e) => {
        e.preventDefault();
        const isExpanded = expandButton.textContent === this.config.collapseText;
        
        if (isExpanded) {
          this.eventBus.emit('collapse');
          expandButton.textContent = this.config.expandText!;
        } else {
          this.eventBus.emit('expand');
          expandButton.textContent = this.config.collapseText!;
        }
      });
    }

    // 重置按钮事件
    const resetButton = this.buttons.get('reset');
    if (resetButton) {
      resetButton.addEventListener('click', (e) => {
        e.preventDefault();
        this.eventBus.emit('reset');
      });
    }

    // 查询按钮事件
    const submitButton = this.buttons.get('submit');
    if (submitButton) {
      submitButton.addEventListener('click', (e) => {
        e.preventDefault();
        this.eventBus.emit('submit');
      });
    }
  }

  updateExpandButton(isExpanded: boolean): void {
    const expandButton = this.buttons.get('expand');
    if (expandButton) {
      expandButton.textContent = isExpanded 
        ? this.config.collapseText! 
        : this.config.expandText!;
    }
  }

  updatePosition(position: ButtonPositionResult): void {
    this.container.setAttribute('data-position', position.strategy);
    
    if (position.strategy === 'inline') {
      this.container.style.width = position.position.width;
      this.container.style.gridColumn = 'span 1';
    } else {
      this.container.style.width = '100%';
      this.container.style.gridColumn = 'span 10';
    }
  }
}
```

## 5. React适配器实现

### react.tsx
```typescript
import React, { useEffect, useRef, useState, useCallback } from 'react';
import { LayoutEngine, StateManager, AnimationManager, ButtonGroup } from '../core';

export interface FormLayoutProps {
  config?: LayoutConfig;
  children?: React.ReactNode;
  onExpand?: () => void;
  onCollapse?: () => void;
  onReset?: () => void;
  onSubmit?: (data: FormData) => void;
  className?: string;
}

export function useFormLayout(config: LayoutConfig = {}) {
  const containerRef = useRef<HTMLDivElement>(null);
  const engineRef = useRef<LayoutEngine | null>(null);
  const stateManagerRef = useRef<StateManager | null>(null);
  const animationManagerRef = useRef<AnimationManager | null>(null);
  const buttonGroupRef = useRef<ButtonGroup | null>(null);
  
  const [state, setState] = useState<FormLayoutState>({
    isExpanded: false,
    currentRows: 0,
    totalRows: 0,
    layout: {} as LayoutResult,
    isAnimating: false,
    config
  });

  const initializeEngine = useCallback(() => {
    if (!containerRef.current) return;

    // 初始化核心组件
    engineRef.current = new LayoutEngine(containerRef.current, config);
    stateManagerRef.current = new StateManager(state);
    animationManagerRef.current = new AnimationManager({
      duration: config.animationDuration || 300,
      easing: 'cubic-bezier(0.4, 0.0, 0.2, 1)',
      enableGPU: true
    });

    // 创建按钮组
    const buttonContainer = containerRef.current.querySelector('.button-group-container');
    if (buttonContainer) {
      buttonGroupRef.current = new ButtonGroup(
        buttonContainer as HTMLElement,
        config,
        stateManagerRef.current.eventBus
      );
    }

    // 监听状态变更
    stateManagerRef.current.subscribe('state-change', ({ newState }) => {
      setState(newState);
    });

  }, [config]);

  const expand = useCallback(async () => {
    if (!engineRef.current || !animationManagerRef.current || state.isAnimating) return;

    setState(prev => ({ ...prev, isAnimating: true }));
    
    try {
      const hiddenItems = getHiddenItems(containerRef.current!, config.defaultRows || 2);
      
      if (config.animation) {
        await animationManagerRef.current.expand(hiddenItems);
      } else {
        hiddenItems.forEach(item => item.style.display = 'block');
      }
      
      stateManagerRef.current?.dispatch({ type: 'EXPAND' });
      buttonGroupRef.current?.updateExpandButton(true);
      
      // 重新计算布局
      const newLayout = engineRef.current.updateLayout();
      stateManagerRef.current?.dispatch({ 
        type: 'UPDATE_LAYOUT', 
        payload: newLayout 
      });

    } finally {
      setState(prev => ({ ...prev, isAnimating: false }));
    }
  }, [config, state.isAnimating]);

  const collapse = useCallback(async () => {
    if (!engineRef.current || !animationManagerRef.current || state.isAnimating) return;

    setState(prev => ({ ...prev, isAnimating: true }));
    
    try {
      const extraItems = getExtraItems(containerRef.current!, config.defaultRows || 2);
      
      if (config.animation) {
        await animationManagerRef.current.collapse(extraItems);
      } else {
        extraItems.forEach(item => item.style.display = 'none');
      }
      
      stateManagerRef.current?.dispatch({ type: 'COLLAPSE' });
      buttonGroupRef.current?.updateExpandButton(false);
      
      // 重新计算布局
      const newLayout = engineRef.current.updateLayout();
      stateManagerRef.current?.dispatch({ 
        type: 'UPDATE_LAYOUT', 
        payload: newLayout 
      });

    } finally {
      setState(prev => ({ ...prev, isAnimating: false }));
    }
  }, [config, state.isAnimating]);

  const reset = useCallback(() => {
    // 触发表单重置
    const form = containerRef.current?.closest('form');
    if (form) {
      form.reset();
    }
    
    // 重置到收起状态
    if (state.isExpanded) {
      collapse();
    }
    
    stateManagerRef.current?.dispatch({ type: 'RESET' });
  }, [state.isExpanded, collapse]);

  const submit = useCallback(() => {
    const form = containerRef.current?.closest('form');
    if (form) {
      const formData = new FormData(form);
      // 触发提交事件
      stateManagerRef.current?.eventBus.emit('submit', formData);
    }
  }, []);

  useEffect(() => {
    initializeEngine();

    return () => {
      engineRef.current?.destroy();
      stateManagerRef.current?.destroy();
      buttonGroupRef.current = null;
    };
  }, [initializeEngine]);

  return {
    containerRef,
    state,
    expand,
    collapse,
    reset,
    submit
  };
}

// React组件
export const FormLayout: React.FC<FormLayoutProps> = ({
  config = {},
  children,
  onExpand,
  onCollapse,
  onReset,
  onSubmit,
  className = ''
}) => {
  const { containerRef, state, expand, collapse, reset, submit } = useFormLayout(config);

  // 事件回调
  useEffect(() => {
    if (onExpand && state.isExpanded) onExpand();
  }, [state.isExpanded, onExpand]);

  const handleReset = useCallback(() => {
    reset();
    onReset?.();
  }, [reset, onReset]);

  const handleSubmit = useCallback(() => {
    submit();
    onSubmit?.(new FormData(containerRef.current?.closest('form') as HTMLFormElement));
  }, [submit, onSubmit]);

  return (
    <div 
      ref={containerRef} 
      className={`form-layout ${className}`}
      data-expanded={state.isExpanded}
      data-animating={state.isAnimating}
    >
      <div className="form-items">
        {children}
      </div>
      <div className="button-group-container"></div>
    </div>
  );
};

// 辅助函数
function getHiddenItems(container: HTMLElement, defaultRows: number): HTMLElement[] {
  const items = Array.from(container.querySelectorAll('.form-item')) as HTMLElement[];
  const layout = calculateCurrentLayout(container);
  const visibleCount = defaultRows * layout.columnsPerRow;
  
  return items.slice(visibleCount);
}

function getExtraItems(container: HTMLElement, defaultRows: number): HTMLElement[] {
  return getHiddenItems(container, defaultRows).filter(
    item => item.style.display !== 'none'
  );
}

function calculateCurrentLayout(container: HTMLElement): { columnsPerRow: number } {
  // 简单的列数计算
  const containerWidth = container.clientWidth;
  const itemMinWidth = 200;
  const spacing = 16;
  
  const columnsPerRow = Math.floor((containerWidth + spacing) / (itemMinWidth + spacing));
  return { columnsPerRow: Math.max(1, Math.min(columnsPerRow, 6)) };
}
```

## 6. Vue适配器实现

### vue.ts
```typescript
import { ref, computed, onMounted, onUnmounted, reactive, readonly } from 'vue';
import type { Ref } from 'vue';
import { LayoutEngine, StateManager, AnimationManager, ButtonGroup } from '../core';

export function useFormLayout(config: Ref<LayoutConfig> | LayoutConfig) {
  const containerRef = ref<HTMLElement>();
  const configRef = ref(config);
  
  const state = reactive<FormLayoutState>({
    isExpanded: false,
    currentRows: 0,
    totalRows: 0,
    layout: {} as LayoutResult,
    isAnimating: false,
    config: typeof config === 'object' && 'value' in config ? config.value : config
  });

  let engine: LayoutEngine | null = null;
  let stateManager: StateManager | null = null;
  let animationManager: AnimationManager | null = null;
  let buttonGroup: ButtonGroup | null = null;

  const initialize = () => {
    if (!containerRef.value) return;

    const currentConfig = typeof configRef.value === 'object' && 'value' in configRef.value 
      ? configRef.value.value 
      : configRef.value;

    engine = new LayoutEngine(containerRef.value, currentConfig);
    stateManager = new StateManager(state);
    animationManager = new AnimationManager({
      duration: currentConfig.animationDuration || 300
    });

    // 创建按钮组
    const buttonContainer = containerRef.value.querySelector('.button-group-container');
    if (buttonContainer) {
      buttonGroup = new ButtonGroup(
        buttonContainer as HTMLElement,
        currentConfig,
        stateManager.eventBus
      );
    }

    // 监听状态变更
    stateManager.subscribe('state-change', ({ newState }) => {
      Object.assign(state, newState);
    });
  };

  const expand = async () => {
    if (!engine || !animationManager || state.isAnimating) return;

    state.isAnimating = true;
    
    try {
      const hiddenItems = getHiddenItems(containerRef.value!, configRef.value.defaultRows || 2);
      
      if (configRef.value.animation) {
        await animationManager.expand(hiddenItems);
      } else {
        hiddenItems.forEach(item => item.style.display = 'block');
      }
      
      state.isExpanded = true;
      buttonGroup?.updateExpandButton(true);
      
      const newLayout = engine.updateLayout();
      Object.assign(state.layout, newLayout);

    } finally {
      state.isAnimating = false;
    }
  };

  const collapse = async () => {
    if (!engine || !animationManager || state.isAnimating) return;

    state.isAnimating = true;
    
    try {
      const extraItems = getExtraItems(containerRef.value!, configRef.value.defaultRows || 2);
      
      if (configRef.value.animation) {
        await animationManager.collapse(extraItems);
      } else {
        extraItems.forEach(item => item.style.display = 'none');
      }
      
      state.isExpanded = false;
      buttonGroup?.updateExpandButton(false);
      
      const newLayout = engine.updateLayout();
      Object.assign(state.layout, newLayout);

    } finally {
      state.isAnimating = false;
    }
  };

  const reset = () => {
    const form = containerRef.value?.closest('form') as HTMLFormElement;
    if (form) {
      form.reset();
    }
    
    if (state.isExpanded) {
      collapse();
    }
  };

  const submit = () => {
    const form = containerRef.value?.closest('form') as HTMLFormElement;
    if (form) {
      const formData = new FormData(form);
      stateManager?.eventBus.emit('submit', formData);
    }
  };

  onMounted(() => {
    initialize();
  });

  onUnmounted(() => {
    engine?.destroy();
    stateManager?.destroy();
  });

  return {
    containerRef,
    state: readonly(state),
    expand,
    collapse,
    reset,
    submit
  };
}

// Vue组件定义
export default {
  name: 'FormLayout',
  props: {
    config: {
      type: Object,
      default: () => ({})
    }
  },
  emits: ['expand', 'collapse', 'reset', 'submit'],
  setup(props, { emit, slots }) {
    const { containerRef, state, expand, collapse, reset, submit } = useFormLayout(
      computed(() => props.config)
    );

    const handleExpand = () => {
      expand();
      emit('expand');
    };

    const handleCollapse = () => {
      collapse();
      emit('collapse');
    };

    const handleReset = () => {
      reset();
      emit('reset');
    };

    const handleSubmit = () => {
      submit();
      emit('submit');
    };

    return {
      containerRef,
      state,
      handleExpand,
      handleCollapse,
      handleReset,
      handleSubmit,
      slots
    };
  },
  template: `
    <div 
      ref="containerRef" 
      class="form-layout"
      :data-expanded="state.isExpanded"
      :data-animating="state.isAnimating"
    >
      <div class="form-items">
        <slot></slot>
      </div>
      <div class="button-group-container"></div>
    </div>
  `
};
```

## 7. 核心CSS样式

### core.css
```css
/* CSS变量定义 */
:root {
  --fl-spacing: 16px;
  --fl-border-radius: 4px;
  --fl-transition-duration: 300ms;
  --fl-transition-easing: cubic-bezier(0.4, 0.0, 0.2, 1);
  
  /* 按钮样式变量 */
  --fl-btn-height: 32px;
  --fl-btn-padding: 0 16px;
  --fl-btn-border-radius: 4px;
  --fl-btn-font-size: 14px;
  
  /* 颜色变量 */
  --fl-primary-color: #1890ff;
  --fl-border-color: #d9d9d9;
  --fl-text-color: #262626;
  --fl-bg-color: #ffffff;
}

/* 表单布局容器 */
.form-layout {
  width: 100%;
  display: flex;
  flex-direction: column;
}

.form-items {
  display: grid;
  gap: var(--fl-spacing);
  grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
  margin-bottom: var(--fl-spacing);
}

/* 表单项基础样式 */
.form-item {
  display: flex;
  flex-direction: column;
  min-height: 60px;
}

.form-item label {
  font-size: 14px;
  color: var(--fl-text-color);
  margin-bottom: 4px;
  font-weight: 500;
}

.form-item input,
.form-item select,
.form-item textarea {
  height: 32px;
  padding: 4px 12px;
  border: 1px solid var(--fl-border-color);
  border-radius: var(--fl-btn-border-radius);
  font-size: 14px;
  transition: border-color var(--fl-transition-duration);
}

.form-item input:focus,
.form-item select:focus,
.form-item textarea:focus {
  outline: none;
  border-color: var(--fl-primary-color);
  box-shadow: 0 0 0 2px rgba(24, 144, 255, 0.2);
}

/* 按钮组样式 */
.button-group {
  display: flex;
  gap: 8px;
  align-items: center;
  justify-content: flex-end;
  transition: all var(--fl-transition-duration) var(--fl-transition-easing);
}

.button-group--inline {
  grid-column-start: -1;
  align-self: end;
}

.button-group--newline {
  grid-column: 1 / -1;
  margin-top: var(--fl-spacing);
}

/* 按钮样式 */
.btn {
  height: var(--fl-btn-height);
  padding: var(--fl-btn-padding);
  border: 1px solid var(--fl-border-color);
  border-radius: var(--fl-btn-border-radius);
  font-size: var(--fl-btn-font-size);
  cursor: pointer;
  background: var(--fl-bg-color);
  color: var(--fl-text-color);
  transition: all 200ms ease;
  white-space: nowrap;
}

.btn:hover {
  border-color: var(--fl-primary-color);
  color: var(--fl-primary-color);
}

.btn-primary {
  background: var(--fl-primary-color);
  border-color: var(--fl-primary-color);
  color: white;
}

.btn-primary:hover {
  background: #40a9ff;
  border-color: #40a9ff;
}

/* 展开/收起动画 */
.form-item-enter-active,
.form-item-leave-active {
  transition: all var(--fl-transition-duration) var(--fl-transition-easing);
}

.form-item-enter-from {
  opacity: 0;
  transform: translateY(-10px);
  height: 0;
}

.form-item-leave-to {
  opacity: 0;
  transform: translateY(-10px);
  height: 0;
}

/* 响应式布局 */
@media (max-width: 576px) {
  .form-items {
    grid-template-columns: 1fr;
  }
  
  .button-group {
    flex-direction: column;
    align-items: stretch;
  }
  
  .btn {
    width: 100%;
    margin-bottom: 8px;
  }
}

@media (min-width: 577px) and (max-width: 768px) {
  .form-items {
    grid-template-columns: repeat(2, 1fr);
  }
}

@media (min-width: 769px) and (max-width: 992px) {
  .form-items {
    grid-template-columns: repeat(3, 1fr);
  }
}

@media (min-width: 993px) and (max-width: 1200px) {
  .form-items {
    grid-template-columns: repeat(4, 1fr);
  }
}

@media (min-width: 1201px) {
  .form-items {
    grid-template-columns: repeat(6, 1fr);
  }
}

/* 加载和禁用状态 */
.form-layout[data-animating="true"] {
  pointer-events: none;
}

.form-layout[data-animating="true"] .btn {
  opacity: 0.6;
}

/* 高对比度模式支持 */
@media (prefers-contrast: high) {
  .btn {
    border-width: 2px;
  }
  
  .form-item input:focus,
  .form-item select:focus {
    border-width: 2px;
  }
}

/* 减少动画偏好 */
@media (prefers-reduced-motion: reduce) {
  .form-layout,
  .button-group,
  .btn,
  .form-item-enter-active,
  .form-item-leave-active {
    transition: none !important;
    animation: none !important;
  }
}
```

## 8. 使用示例

### React使用示例
```typescript
import React from 'react';
import { FormLayout } from '@ldesign/form-layout/react';
import '@ldesign/form-layout/styles';

function SearchForm() {
  const handleSubmit = (formData: FormData) => {
    console.log('提交数据:', Object.fromEntries(formData));
  };

  const handleReset = () => {
    console.log('重置表单');
  };

  return (
    <form>
      <FormLayout
        config={{
          defaultRows: 2,
          columnsPerRow: 'auto',
          animation: true,
          buttonPosition: 'auto'
        }}
        onSubmit={handleSubmit}
        onReset={handleReset}
      >
        <div className="form-item">
          <label>用户名</label>
          <input name="username" placeholder="请输入用户名" />
        </div>
        <div className="form-item">
          <label>邮箱</label>
          <input name="email" type="email" placeholder="请输入邮箱" />
        </div>
        <div className="form-item">
          <label>手机号</label>
          <input name="phone" placeholder="请输入手机号" />
        </div>
        <div className="form-item">
          <label>部门</label>
          <select name="department">
            <option value="">请选择部门</option>
            <option value="tech">技术部</option>
            <option value="sales">销售部</option>
          </select>
        </div>
        <div className="form-item">
          <label>状态</label>
          <select name="status">
            <option value="">请选择状态</option>
            <option value="active">启用</option>
            <option value="inactive">禁用</option>
          </select>
        </div>
        <div className="form-item">
          <label>备注</label>
          <textarea name="remark" placeholder="请输入备注"></textarea>
        </div>
      </FormLayout>
    </form>
  );
}
```

### Vue使用示例
```vue
<template>
  <form>
    <FormLayout 
      :config="layoutConfig"
      @submit="handleSubmit"
      @reset="handleReset"
    >
      <div class="form-item">
        <label>用户名</label>
        <input v-model="form.username" placeholder="请输入用户名" />
      </div>
      <div class="form-item">
        <label>邮箱</label>
        <input v-model="form.email" type="email" placeholder="请输入邮箱" />
      </div>
      <div class="form-item">
        <label>手机号</label>
        <input v-model="form.phone" placeholder="请输入手机号" />
      </div>
      <div class="form-item">
        <label>部门</label>
        <select v-model="form.department">
          <option value="">请选择部门</option>
          <option value="tech">技术部</option>
          <option value="sales">销售部</option>
        </select>
      </div>
      <div class="form-item">
        <label>状态</label>
        <select v-model="form.status">
          <option value="">请选择状态</option>
          <option value="active">启用</option>
          <option value="inactive">禁用</option>
        </select>
      </div>
      <div class="form-item">
        <label>备注</label>
        <textarea v-model="form.remark" placeholder="请输入备注"></textarea>
      </div>
    </FormLayout>
  </form>
</template>

<script setup lang="ts">
import { ref, reactive } from 'vue';
import FormLayout from '@ldesign/form-layout/vue';

const layoutConfig = ref({
  defaultRows: 2,
  columnsPerRow: 'auto',
  animation: true,
  buttonPosition: 'auto'
});

const form = reactive({
  username: '',
  email: '',
  phone: '',
  department: '',
  status: '',
  remark: ''
});

const handleSubmit = (formData: FormData) => {
  console.log('提交数据:', Object.fromEntries(formData));
};

const handleReset = () => {
  Object.keys(form).forEach(key => {
    form[key] = '';
  });
  console.log('重置表单');
};
</script>
```

### 原生JavaScript使用示例
```html
<!DOCTYPE html>
<html>
<head>
  <link rel="stylesheet" href="@ldesign/form-layout/styles">
</head>
<body>
  <form id="searchForm">
    <div class="form-layout-container">
      <div class="form-item">
        <label>用户名</label>
        <input name="username" placeholder="请输入用户名" />
      </div>
      <div class="form-item">
        <label>邮箱</label>
        <input name="email" type="email" placeholder="请输入邮箱" />
      </div>
      <div class="form-item">
        <label>手机号</label>
        <input name="phone" placeholder="请输入手机号" />
      </div>
      <div class="form-item">
        <label>部门</label>
        <select name="department">
          <option value="">请选择部门</option>
          <option value="tech">技术部</option>
          <option value="sales">销售部</option>
        </select>
      </div>
      <div class="button-group-container"></div>
    </div>
  </form>

  <script type="module">
    import { FormLayout } from '@ldesign/form-layout';

    const container = document.querySelector('.form-layout-container');
    const formLayout = new FormLayout(container, {
      defaultRows: 2,
      columnsPerRow: 'auto',
      animation: true,
      buttonPosition: 'auto'
    });

    // 监听事件
    formLayout.on('submit', (formData) => {
      console.log('提交数据:', Object.fromEntries(formData));
    });

    formLayout.on('reset', () => {
      document.getElementById('searchForm').reset();
      console.log('重置表单');
    });
  </script>
</body>
</html>
```

## 9. TypeScript类型定义

### types.ts
```typescript
// 基础类型定义
export interface FormLayoutConfig {
  defaultRows?: number;
  columnsPerRow?: number | 'auto';
  spacing?: number;
  buttonPosition?: 'auto' | 'inline' | 'newline';
  animation?: boolean;
  animationDuration?: number;
  responsive?: boolean;
  breakpoints?: BreakpointConfig;
  buttons?: ButtonConfig;
  theme?: string;
}

export interface BreakpointConfig {
  xs: number;
  sm: number;
  md: number;
  lg: number;
  xl: number;
}

export interface ButtonConfig {
  expandText?: string;
  collapseText?: string;
  resetText?: string;
  submitText?: string;
  showReset?: boolean;
  showSubmit?: boolean;
}

export interface SpaceCalculationResult {
  containerWidth: number;
  columnsPerRow: number;
  actualRows: number;
  itemWidth: number;
  lastRowItems: number;
  remainingWidth: number;
  canFitButtons: boolean;
}

export interface ButtonPositionResult {
  strategy: 'inline' | 'newline';
  position: {
    row: number;
    align: 'left' | 'center' | 'right';
    width: string;
  };
}

export interface LayoutItem {
  element: HTMLElement;
  row: number;
  column: number;
  visible: boolean;
}

export interface LayoutResult {
  rows: number;
  columns: number;
  items: LayoutItem[];
  buttonPosition: ButtonPositionResult;
  availableSpace: SpaceCalculationResult;
}

// 事件类型定义
export type FormLayoutEventType = 
  | 'expand'
  | 'collapse'
  | 'reset'
  | 'submit'
  | 'layout-change'
  | 'button-position-change'
  | 'resize';

export interface FormLayoutEventMap {
  'expand': void;
  'collapse': void;
  'reset': void;
  'submit': FormData;
  'layout-change': LayoutResult;
  'button-position-change': ButtonPositionResult;
  'resize': { width: number; height: number; breakpoint: string };
}

// 框架适配器类型
export interface FrameworkAdapter<T = any> {
  mount(container: Element, config: FormLayoutConfig): T;
  unmount(instance: T): void;
  update(instance: T, config: Partial<FormLayoutConfig>): void;
  isSupported(): boolean;
  getVersion(): string;
}

// 插件接口
export interface FormLayoutPlugin {
  name: string;
  version: string;
  install(formLayout: FormLayout): void;
  uninstall?(formLayout: FormLayout): void;
}

// 主题接口
export interface Theme {
  name: string;
  variables: Record<string, string>;
  customCSS?: string;
  breakpoints?: Partial<BreakpointConfig>;
}
```

## 10. 工具函数实现

### utils/helpers.ts
```typescript
// 防抖函数
export function debounce<T extends (...args: any[]) => any>(
  func: T,
  delay: number
): (...args: Parameters<T>) => void {
  let timeoutId: number;
  
  return (...args: Parameters<T>) => {
    clearTimeout(timeoutId);
    timeoutId = setTimeout(() => func.apply(null, args), delay);
  };
}

// 节流函数
export function throttle<T extends (...args: any[]) => any>(
  func: T,
  delay: number
): (...args: Parameters<T>) => void {
  let lastCall = 0;
  
  return (...args: Parameters<T>) => {
    const now = Date.now();
    if (now - lastCall >= delay) {
      lastCall = now;
      func.apply(null, args);
    }
  };
}

// 深度合并对象
export function deepMerge<T extends object>(target: T, ...sources: Partial<T>[]): T {
  if (!sources.length) return target;
  const source = sources.shift();

  if (isObject(target) && isObject(source)) {
    for (const key in source) {
      if (isObject(source[key])) {
        if (!target[key]) Object.assign(target, { [key]: {} });
        deepMerge(target[key] as any, source[key] as any);
      } else {
        Object.assign(target, { [key]: source[key] });
      }
    }
  }

  return deepMerge(target, ...sources);
}

function isObject(item: any): item is object {
  return item && typeof item === 'object' && !Array.isArray(item);
}

// 获取元素尺寸信息
export function getElementDimensions(element: HTMLElement): {
  width: number;
  height: number;
  outerWidth: number;
  outerHeight: number;
} {
  const rect = element.getBoundingClientRect();
  const style = getComputedStyle(element);
  
  const marginLeft = parseFloat(style.marginLeft) || 0;
  const marginRight = parseFloat(style.marginRight) || 0;
  const marginTop = parseFloat(style.marginTop) || 0;
  const marginBottom = parseFloat(style.marginBottom) || 0;

  return {
    width: rect.width,
    height: rect.height,
    outerWidth: rect.width + marginLeft + marginRight,
    outerHeight: rect.height + marginTop + marginBottom
  };
}

// CSS类名工具
export function classNames(...args: (string | Record<string, boolean> | undefined)[]): string {
  const classes: string[] = [];

  args.forEach(arg => {
    if (!arg) return;

    if (typeof arg === 'string') {
      classes.push(arg);
    } else if (typeof arg === 'object') {
      Object.entries(arg).forEach(([key, value]) => {
        if (value) classes.push(key);
      });
    }
  });

  return classes.join(' ');
}

// 检测GPU加速支持
export function hasGPUAcceleration(): boolean {
  const canvas = document.createElement('canvas');
  const gl = canvas.getContext('webgl') || canvas.getContext('experimental-webgl');
  return !!gl;
}

// 检测触摸设备
export function isTouchDevice(): boolean {
  return 'ontouchstart' in window || navigator.maxTouchPoints > 0;
}

// 计算文本宽度
export function measureTextWidth(text: string, font: string): number {
  const canvas = document.createElement('canvas');
  const context = canvas.getContext('2d');
  if (context) {
    context.font = font;
    return context.measureText(text).width;
  }
  return 0;
}
```

这套实现示例提供了一个完整的通用表单布局系统的核心代码，包括：

1. **核心引擎**: 智能布局计算和空间检测
2. **状态管理**: 响应式状态和事件系统
3. **动画系统**: 平滑的展开收起动画
4. **框架适配**: React和Vue的完整适配实现
5. **样式系统**: 响应式CSS和主题支持
6. **工具函数**: 性能优化和辅助功能

这个系统具备高度的可扩展性和框架无关性，可以轻松集成到任何前端项目中。
