# 通用表单系统技术架构设计

## 整体架构

```
@ldesign/form-layout
├── core/                   # 核心布局引擎
│   ├── layout-engine/      # 布局计算引擎
│   ├── event-system/       # 事件管理系统
│   ├── animation/          # 动画引擎
│   └── utils/             # 工具函数
├── adapters/              # 框架适配器
│   ├── react/             # React适配器
│   ├── vue/               # Vue适配器
│   ├── angular/           # Angular适配器
│   └── vanilla/           # 原生JS适配器
├── themes/                # 主题系统
│   ├── default/           # 默认主题
│   ├── dark/              # 暗色主题
│   └── minimal/           # 简约主题
└── types/                 # TypeScript类型定义
```

## 核心架构设计

### 1. Grid布局引擎（Grid Layout Engine）

#### 职责
- 基于CSS Grid的表单项精确布局
- 标题和组件对齐管理
- 响应式布局处理
- 按钮组位置智能决策
- Grid网格空间检测算法

#### 核心类
```typescript
class LayoutEngine {
  private container: HTMLElement;
  private config: LayoutConfig;
  private items: FormItem[];
  
  constructor(container: HTMLElement, config: LayoutConfig);
  
  // 核心方法
  calculateLayout(): LayoutResult;
  updateLayout(): void;
  detectAvailableSpace(): SpaceInfo;
  repositionButtons(): void;
  
  // Grid相关
  applyGridTemplateColumns(): void; // 设置grid-template-columns，含label列
  applyLabelAlignment(): void;      // 应用label宽度与对齐
  
  // 私有方法
  private calculateGridLayout(): GridLayout;
  private optimizeLayout(): void;
}
```

#### 关键算法

**1. 空间检测算法**
```typescript
interface SpaceDetection {
  // 检测最后一行剩余空间
  detectLastRowSpace(): {
    availableWidth: number;
    requiredWidth: number;
    canFitButtons: boolean;
    remainingItems: number;
  };
  
  // 计算按钮组所需空间
  calculateButtonSpace(): {
    minWidth: number;
    preferredWidth: number;
    height: number;
  };
}
```

**2. 布局策略**
```typescript
enum ButtonLayoutStrategy {
  INLINE = 'inline',        // 行内显示
  NEW_LINE = 'newline',     // 新行显示
  OVERLAY = 'overlay'       // 悬浮显示（特殊情况）
}
```

### 2. 状态管理系统（State Manager）

#### 状态结构
```typescript
interface FormLayoutState {
  // 基础状态
  isExpanded: boolean;
  currentRows: number;
  totalRows: number;
  
  // 布局状态
  layout: {
    columnsPerRow: number;
    actualRows: number;
    buttonPosition: ButtonLayoutStrategy;
    availableSpace: SpaceInfo;
  };
  
  // 配置状态
  config: LayoutConfig;
  
  // 运行时状态
  isAnimating: boolean;
  isResizing: boolean;
  lastUpdateTime: number;
}
```

#### 状态管理器
```typescript
class StateManager {
  private state: FormLayoutState;
  private listeners: Map<string, EventListener[]>;
  
  // 状态操作
  setState(updates: Partial<FormLayoutState>): void;
  getState(): Readonly<FormLayoutState>;
  
  // 事件管理
  on(event: string, listener: EventListener): void;
  off(event: string, listener: EventListener): void;
  emit(event: string, data?: any): void;
  
  // 状态计算
  computeNextState(action: StateAction): FormLayoutState;
}
```

### 3. 动画引擎（Animation Engine）

#### 动画类型
- **展开动画**: 高度从0到auto的平滑过渡
- **收起动画**: 高度从auto到0的平滑过渡
- **按钮位移动画**: 按钮组位置变更时的平滑移动
- **布局重排动画**: 响应式变化时的布局调整

#### 动画管理器
```typescript
class AnimationManager {
  private activeAnimations: Map<string, Animation>;
  private config: AnimationConfig;
  
  // 动画控制
  expand(elements: Element[], duration?: number): Promise<void>;
  collapse(elements: Element[], duration?: number): Promise<void>;
  repositionButtons(button: Element, newPosition: Position): Promise<void>;
  
  // 动画队列
  queue(animation: AnimationTask): void;
  cancelAll(): void;
  
  // 性能优化
  enableGPUAcceleration(element: Element): void;
  cleanupAnimations(): void;
}
```

### 4. 事件系统（Event System）

#### 事件总线
```typescript
class EventBus {
  private events: Map<string, EventListener[]>;
  
  // 事件注册
  subscribe(event: FormLayoutEvent, listener: EventListener): () => void;
  unsubscribe(event: FormLayoutEvent, listener: EventListener): void;
  
  // 事件触发
  emit(event: FormLayoutEvent, payload?: any): void;
  
  // 批量操作
  subscribeMultiple(events: EventSubscription[]): () => void;
  clear(): void;
}
```

#### 标准事件定义
```typescript
type FormLayoutEvent = 
  | 'expand'
  | 'collapse' 
  | 'reset'
  | 'submit'
  | 'layout-change'
  | 'button-position-change'
  | 'resize'
  | 'item-add'
  | 'item-remove';
```

## 框架适配器架构

### 1. 适配器接口
```typescript
interface FrameworkAdapter<T = any> {
  // 生命周期
  mount(container: Element, config: LayoutConfig): T;
  unmount(instance: T): void;
  update(instance: T, config: Partial<LayoutConfig>): void;
  
  // 框架特定方法
  createComponent(definition: ComponentDefinition): T;
  bindEvents(instance: T, events: EventMap): void;
  
  // 工具方法
  isSupported(): boolean;
  getVersion(): string;
}
```

### 2. React适配器
```typescript
// React Hook实现
export function useFormLayout(config: LayoutConfig): FormLayoutInstance {
  const [state, setState] = useState<FormLayoutState>();
  const containerRef = useRef<HTMLElement>();
  const engineRef = useRef<LayoutEngine>();
  
  useEffect(() => {
    if (containerRef.current) {
      engineRef.current = new LayoutEngine(containerRef.current, config);
      // 初始化逻辑
    }
    
    return () => {
      engineRef.current?.destroy();
    };
  }, [config]);
  
  return {
    containerRef,
    expand: () => engineRef.current?.expand(),
    collapse: () => engineRef.current?.collapse(),
    // ... 其他方法
  };
}

// React组件封装
export const FormLayout: React.FC<FormLayoutProps> = (props) => {
  const layout = useFormLayout(props.config);
  
  return (
    <div ref={layout.containerRef} className="form-layout">
      {props.children}
      <ButtonGroup
        expanded={layout.state.isExpanded}
        onExpand={layout.expand}
        onCollapse={layout.collapse}
        onReset={layout.reset}
        onSubmit={layout.submit}
      />
    </div>
  );
};
```

### 3. Vue适配器
```typescript
// Vue Composition API
export function useFormLayout(config: Ref<LayoutConfig>) {
  const containerRef = ref<HTMLElement>();
  const state = reactive<FormLayoutState>({
    isExpanded: false,
    // ... 其他状态
  });
  
  const engine = computed(() => {
    if (containerRef.value) {
      return new LayoutEngine(containerRef.value, config.value);
    }
    return null;
  });
  
  const expand = () => {
    engine.value?.expand();
    state.isExpanded = true;
  };
  
  // ... 其他方法
  
  onUnmounted(() => {
    engine.value?.destroy();
  });
  
  return {
    containerRef,
    state: readonly(state),
    expand,
    collapse,
    reset,
    submit
  };
}
```

## 核心算法详解

### 1. 智能布局算法

#### 空间计算
```typescript
class SpaceCalculator {
  calculateAvailableSpace(
    container: HTMLElement,
    items: FormItem[],
    config: LayoutConfig
  ): SpaceCalculationResult {
    const containerWidth = container.clientWidth;
    const itemWidth = this.getItemWidth(config);
    const spacing = this.getSpacing(config);
    
    // 计算每行可容纳的列数
    const columnsPerRow = Math.floor(
      (containerWidth + spacing) / (itemWidth + spacing)
    );
    
    // 计算实际行数
    const actualRows = Math.ceil(items.length / columnsPerRow);
    
    // 计算最后一行剩余空间
    const lastRowItems = items.length % columnsPerRow || columnsPerRow;
    const usedWidth = lastRowItems * (itemWidth + spacing) - spacing;
    const remainingWidth = containerWidth - usedWidth;
    
    return {
      containerWidth,
      columnsPerRow,
      actualRows,
      remainingWidth,
      canFitButtons: remainingWidth >= this.getButtonGroupWidth()
    };
  }
  
  private getButtonGroupWidth(): number {
    // 计算三个按钮所需的最小宽度
    return 240; // 展开/收起(80px) + 重置(60px) + 查询(60px) + 间距(40px)
  }
}
```

#### 按钮定位策略
```typescript
class ButtonPositioning {
  determineButtonPosition(
    spaceInfo: SpaceCalculationResult,
    config: LayoutConfig
  ): ButtonPositionResult {
    const { canFitButtons, remainingWidth, actualRows } = spaceInfo;
    
    if (config.buttonPosition === 'newline') {
      return {
        strategy: ButtonLayoutStrategy.NEW_LINE,
        position: { row: actualRows + 1, align: 'right' }
      };
    }
    
    if (config.buttonPosition === 'inline' && canFitButtons) {
      return {
        strategy: ButtonLayoutStrategy.INLINE,
        position: { 
          row: actualRows, 
          align: 'right',
          width: remainingWidth
        }
      };
    }
    
    // 自动模式
    if (canFitButtons && remainingWidth > 200) {
      return {
        strategy: ButtonLayoutStrategy.INLINE,
        position: { row: actualRows, align: 'right' }
      };
    }
    
    return {
      strategy: ButtonLayoutStrategy.NEW_LINE,
      position: { row: actualRows + 1, align: 'right' }
    };
  }
}
```

### 2. 响应式系统

#### 断点管理
```typescript
interface BreakpointConfig {
  xs: number;  // < 576px
  sm: number;  // 576px - 768px
  md: number;  // 768px - 992px
  lg: number;  // 992px - 1200px
  xl: number;  // > 1200px
}

class ResponsiveManager {
  private breakpoints: BreakpointConfig;
  private currentBreakpoint: keyof BreakpointConfig;
  
  calculateColumnsForBreakpoint(width: number): number {
    if (width < this.breakpoints.xs) return 1;
    if (width < this.breakpoints.sm) return 2;
    if (width < this.breakpoints.md) return 3;
    if (width < this.breakpoints.lg) return 4;
    return 6;
  }
  
  onResize(callback: (breakpoint: string) => void): () => void {
    const resizeObserver = new ResizeObserver((entries) => {
      for (const entry of entries) {
        const newBreakpoint = this.getBreakpoint(entry.contentRect.width);
        if (newBreakpoint !== this.currentBreakpoint) {
          this.currentBreakpoint = newBreakpoint;
          callback(newBreakpoint);
        }
      }
    });
    
    return () => resizeObserver.disconnect();
  }
}
```

## 性能优化策略

### 1. 布局计算优化
```typescript
class LayoutOptimizer {
  private cache = new Map<string, LayoutResult>();
  private debounceResize = debounce(this.handleResize.bind(this), 16);
  
  // 缓存计算结果
  getCachedLayout(key: string): LayoutResult | null {
    return this.cache.get(key) || null;
  }
  
  // 增量更新
  updateLayoutIncremental(changes: LayoutChange[]): void {
    // 只重新计算受影响的部分
    const affectedAreas = this.getAffectedAreas(changes);
    this.recalculateAreas(affectedAreas);
  }
  
  // 虚拟化支持（大量表单项）
  enableVirtualization(threshold: number = 100): void {
    if (this.items.length > threshold) {
      this.virtualizer = new VirtualList({
        itemHeight: this.getItemHeight(),
        containerHeight: this.getContainerHeight()
      });
    }
  }
}
```

### 2. 内存管理
```typescript
class MemoryManager {
  private observers: Set<Observer> = new Set();
  private timers: Set<number> = new Set();
  
  // 清理资源
  cleanup(): void {
    // 清理观察器
    this.observers.forEach(observer => observer.disconnect());
    this.observers.clear();
    
    // 清理定时器
    this.timers.forEach(timer => clearTimeout(timer));
    this.timers.clear();
    
    // 清理事件监听器
    this.eventBus.clear();
    
    // 清理DOM引用
    this.domRefs.clear();
  }
  
  // 监控内存使用
  monitorMemoryUsage(): void {
    if (performance.memory) {
      const usage = performance.memory.usedJSHeapSize;
      if (usage > this.memoryThreshold) {
        this.triggerGarbageCollection();
      }
    }
  }
}
```

## 组件设计

### 1. 核心组件
```typescript
// 表单布局容器
class FormLayout {
  private engine: LayoutEngine;
  private stateManager: StateManager;
  private animationManager: AnimationManager;
  
  constructor(
    container: HTMLElement,
    config: FormLayoutConfig
  ) {
    this.engine = new LayoutEngine(container, config);
    this.stateManager = new StateManager();
    this.animationManager = new AnimationManager();
    
    this.initialize();
  }
  
  // 公共API
  expand(): Promise<void> {
    const hiddenItems = this.getHiddenItems();
    await this.animationManager.expand(hiddenItems);
    this.stateManager.setState({ isExpanded: true });
    this.engine.updateLayout();
  }
  
  collapse(): Promise<void> {
    const extraItems = this.getExtraItems();
    await this.animationManager.collapse(extraItems);
    this.stateManager.setState({ isExpanded: false });
    this.engine.updateLayout();
  }
}
```

### 2. 按钮组组件
```typescript
class ButtonGroup {
  private container: HTMLElement;
  private buttons: Map<ButtonType, HTMLElement>;
  
  constructor(container: HTMLElement, config: ButtonConfig) {
    this.container = container;
    this.createButtons(config);
    this.bindEvents();
  }
  
  private createButtons(config: ButtonConfig): void {
    // 展开/收起按钮
    this.buttons.set('expand', this.createButton({
      text: config.expandText || '展开',
      icon: config.expandIcon,
      className: 'btn-expand'
    }));
    
    // 重置按钮
    this.buttons.set('reset', this.createButton({
      text: config.resetText || '重置',
      icon: config.resetIcon,
      className: 'btn-reset'
    }));
    
    // 查询按钮
    this.buttons.set('submit', this.createButton({
      text: config.submitText || '查询',
      icon: config.submitIcon,
      className: 'btn-submit btn-primary'
    }));
  }
  
  updatePosition(position: ButtonPositionResult): void {
    this.container.className = `button-group ${position.strategy}`;
    
    if (position.strategy === ButtonLayoutStrategy.INLINE) {
      this.container.style.width = `${position.position.width}px`;
      this.container.style.justifyContent = 'flex-end';
    }
  }
}
```

## 扩展机制

### 1. 插件系统
```typescript
interface Plugin {
  name: string;
  version: string;
  install(formLayout: FormLayout): void;
  uninstall?(formLayout: FormLayout): void;
}

class PluginManager {
  private plugins: Map<string, Plugin> = new Map();
  
  register(plugin: Plugin): void {
    if (this.plugins.has(plugin.name)) {
      throw new Error(`Plugin ${plugin.name} already registered`);
    }
    
    this.plugins.set(plugin.name, plugin);
    plugin.install(this.formLayout);
  }
  
  unregister(pluginName: string): void {
    const plugin = this.plugins.get(pluginName);
    if (plugin?.uninstall) {
      plugin.uninstall(this.formLayout);
    }
    this.plugins.delete(pluginName);
  }
}
```

### 2. 主题扩展
```typescript
interface Theme {
  name: string;
  variables: Record<string, string>;
  customCSS?: string;
  breakpoints?: Partial<BreakpointConfig>;
}

class ThemeManager {
  private currentTheme: Theme;
  private customVariables: Record<string, string> = {};
  
  applyTheme(theme: Theme): void {
    // 应用CSS变量
    Object.entries(theme.variables).forEach(([key, value]) => {
      document.documentElement.style.setProperty(`--fl-${key}`, value);
    });
    
    // 应用自定义CSS
    if (theme.customCSS) {
      this.injectCustomCSS(theme.customCSS);
    }
    
    this.currentTheme = theme;
  }
  
  createCustomTheme(baseTheme: Theme, overrides: Partial<Theme>): Theme {
    return {
      ...baseTheme,
      ...overrides,
      variables: { ...baseTheme.variables, ...overrides.variables }
    };
  }
}
```

## 测试架构

### 1. 测试分层
```typescript
// 单元测试
describe('LayoutEngine', () => {
  test('should calculate correct layout for given items', () => {
    const engine = new LayoutEngine(container, config);
    const result = engine.calculateLayout();
    expect(result.rows).toBe(expectedRows);
  });
});

// 集成测试
describe('FormLayout Integration', () => {
  test('should handle expand/collapse correctly', async () => {
    const layout = new FormLayout(container, config);
    await layout.expand();
    expect(layout.state.isExpanded).toBe(true);
  });
});

// 端到端测试
describe('Cross-framework compatibility', () => {
  test('should work correctly in React', () => {
    // React组件测试
  });
  
  test('should work correctly in Vue', () => {
    // Vue组件测试
  });
});
```

### 2. 性能测试
```typescript
class PerformanceTester {
  measureLayoutCalculation(iterations: number = 1000): PerformanceResult {
    const start = performance.now();
    
    for (let i = 0; i < iterations; i++) {
      this.engine.calculateLayout();
    }
    
    const end = performance.now();
    return {
      averageTime: (end - start) / iterations,
      totalTime: end - start,
      memoryUsage: this.getMemoryUsage()
    };
  }
  
  measureAnimationPerformance(): AnimationPerformanceResult {
    return {
      fps: this.measureFPS(),
      frameDrops: this.countFrameDrops(),
      gpuAcceleration: this.checkGPUAcceleration()
    };
  }
}
```

## 构建和部署

### 1. 构建配置
```javascript
// rollup.config.js
export default [
  {
    input: 'src/core/index.ts',
    output: [
      { file: 'dist/core.esm.js', format: 'esm' },
      { file: 'dist/core.cjs.js', format: 'cjs' },
      { file: 'dist/core.umd.js', format: 'umd' }
    ],
    plugins: [
      typescript(),
      resolve(),
      terser()
    ]
  },
  // React适配器
  {
    input: 'src/adapters/react/index.ts',
    external: ['react', 'react-dom'],
    output: [
      { file: 'dist/react.esm.js', format: 'esm' },
      { file: 'dist/react.cjs.js', format: 'cjs' }
    ]
  }
  // ... 其他适配器配置
];
```

### 2. 包结构
```json
{
  "name": "@ldesign/form-layout",
  "version": "1.0.0",
  "main": "dist/core.cjs.js",
  "module": "dist/core.esm.js",
  "types": "dist/types/index.d.ts",
  "exports": {
    ".": {
      "import": "./dist/core.esm.js",
      "require": "./dist/core.cjs.js",
      "types": "./dist/types/index.d.ts"
    },
    "./react": {
      "import": "./dist/react.esm.js",
      "require": "./dist/react.cjs.js",
      "types": "./dist/types/react.d.ts"
    },
    "./vue": {
      "import": "./dist/vue.esm.js",
      "require": "./dist/vue.cjs.js", 
      "types": "./dist/types/vue.d.ts"
    },
    "./styles": "./dist/styles.css"
  }
}
```

## 总结

本技术架构设计采用了模块化、可扩展的设计理念，通过以下关键设计实现了项目目标：

1. **核心与适配分离**: 核心布局引擎独立于框架，通过适配器模式支持多框架
2. **智能布局算法**: 自动检测空间并智能决策按钮组位置
3. **高性能实现**: 通过缓存、增量更新、GPU加速等手段保证性能
4. **可扩展架构**: 插件系统和主题系统支持功能和外观扩展
5. **全面测试覆盖**: 分层测试确保代码质量和跨框架兼容性

该架构既满足了当前的功能需求，也为未来的扩展和优化留下了足够的空间。
