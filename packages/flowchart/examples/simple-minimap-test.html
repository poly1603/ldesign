<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ç®€å•å°åœ°å›¾æµ‹è¯•</title>
    <style>
        body {
            margin: 0;
            padding: 20px;
            font-family: Arial, sans-serif;
            background: #f5f5f5;
        }
        
        .container {
            width: 100%;
            height: 600px;
            background: white;
            border: 1px solid #ddd;
            border-radius: 8px;
            position: relative;
            overflow: hidden;
        }
        
        .controls {
            margin-bottom: 20px;
            padding: 10px;
            background: white;
            border-radius: 8px;
            border: 1px solid #ddd;
        }
        
        button {
            margin-right: 10px;
            padding: 8px 16px;
            border: 1px solid #722ed1;
            background: #722ed1;
            color: white;
            border-radius: 4px;
            cursor: pointer;
        }
        
        button:hover {
            background: #5e2aa7;
        }
        
        .info {
            margin-top: 20px;
            padding: 10px;
            background: #f0f8ff;
            border-radius: 4px;
            border: 1px solid #d0e7ff;
        }
    </style>
</head>
<body>
    <h1>ğŸ—ºï¸ æç®€å°åœ°å›¾åŠŸèƒ½æµ‹è¯•</h1>
    
    <div class="controls">
        <button onclick="addNode()">æ·»åŠ èŠ‚ç‚¹</button>
        <button onclick="addEdge()">æ·»åŠ è¿çº¿</button>
        <button onclick="clearAll()">æ¸…ç©ºç”»å¸ƒ</button>
        <button onclick="toggleMiniMap()">åˆ‡æ¢å°åœ°å›¾</button>
        <button onclick="zoomIn()">æ”¾å¤§</button>
        <button onclick="zoomOut()">ç¼©å°</button>
    </div>
    
    <div id="container" class="container"></div>
    
    <div class="info">
        <h3>æµ‹è¯•è¯´æ˜ï¼š</h3>
        <ul>
            <li>âœ… å°åœ°å›¾æ˜¾ç¤ºåœ¨å³ä¸‹è§’ï¼Œç´«è‰²è¾¹æ¡†</li>
            <li>âœ… ç‚¹å‡»å°åœ°å›¾ä»»æ„ä½ç½®ï¼Œä¸»ç”»å¸ƒè·³è½¬åˆ°å¯¹åº”åŒºåŸŸ</li>
            <li>âœ… æ‹–æ‹½å°åœ°å›¾ä¸­çš„è§†å£çª—å£ï¼Œä¸»ç”»å¸ƒè·Ÿéšç§»åŠ¨</li>
            <li>âœ… æ·»åŠ /åˆ é™¤èŠ‚ç‚¹æ—¶ï¼Œå°åœ°å›¾å®æ—¶æ›´æ–°</li>
            <li>âœ… ç¼©æ”¾ä¸»ç”»å¸ƒæ—¶ï¼Œå°åœ°å›¾è§†å£çª—å£å¤§å°åŒæ­¥è°ƒæ•´</li>
            <li>âœ… æ‹–åŠ¨ä¸»ç”»å¸ƒæ—¶ï¼Œå°åœ°å›¾è§†å£çª—å£ä½ç½®å®æ—¶æ›´æ–°</li>
        </ul>
    </div>

    <script src="https://unpkg.com/@logicflow/core@1.2.26/dist/index.umd.js"></script>
    <script>

        // ç›´æ¥åœ¨è¿™é‡Œå®šä¹‰MiniMapPluginç±»
        class MiniMapPlugin {
            constructor(lf, container, config = {}) {
                this.lf = lf
                this.container = container
                this.element = null
                this.canvas = null
                this.viewportRect = null
                this.ctx = null
                this.isDragging = false
                this.scale = 0.1
                this.bounds = { x: -1000, y: -1000, width: 2000, height: 2000 }
                this.currentViewport = { x: 0, y: 0, width: 800, height: 600 }

                this.config = {
                    width: config.width || 200,
                    height: config.height || 150,
                    position: config.position || 'bottom-right',
                    backgroundColor: config.backgroundColor || '#fafafa',
                    borderColor: config.borderColor || '#d9d9d9',
                    viewportColor: config.viewportColor || '#722ed1',
                    showGrid: config.showGrid !== false,
                    showViewport: config.showViewport !== false,
                    zIndex: config.zIndex || 1000
                }

                this.init()
            }

            init() {
                this.createElements()
                this.bindEvents()
                this.refresh()
            }

            refresh() {
                this.updateBounds()
                this.draw()
                this.updateViewportRect()
            }

            updateBounds() {
                const data = this.lf.getGraphData()
                const nodes = data.nodes || []

                if (nodes.length === 0) {
                    this.bounds = { x: -1000, y: -1000, width: 2000, height: 2000 }
                    this.scale = this.config.width / 2000
                    return
                }

                let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity

                nodes.forEach(node => {
                    minX = Math.min(minX, node.x - 50)
                    maxX = Math.max(maxX, node.x + 50)
                    minY = Math.min(minY, node.y - 30)
                    maxY = Math.max(maxY, node.y + 30)
                })

                const padding = 100
                this.bounds = {
                    x: minX - padding,
                    y: minY - padding,
                    width: maxX - minX + padding * 2,
                    height: maxY - minY + padding * 2
                }

                const scaleX = this.config.width / this.bounds.width
                const scaleY = this.config.height / this.bounds.height
                this.scale = Math.min(scaleX, scaleY)
            }

            createElements() {
                // åˆ›å»ºå®¹å™¨
                this.element = document.createElement('div')
                this.element.style.cssText = `
                    position: absolute;
                    width: ${this.config.width}px;
                    height: ${this.config.height}px;
                    background: ${this.config.backgroundColor};
                    border: 1px solid ${this.config.borderColor};
                    border-radius: 4px;
                    z-index: ${this.config.zIndex};
                    box-shadow: 0 2px 8px rgba(0,0,0,0.1);
                    ${this.getPosition()}
                    overflow: hidden;
                `

                // åˆ›å»ºç”»å¸ƒ
                this.canvas = document.createElement('canvas')
                this.canvas.width = this.config.width
                this.canvas.height = this.config.height
                this.canvas.style.cssText = 'display: block; width: 100%; height: 100%; cursor: pointer;'
                this.ctx = this.canvas.getContext('2d')

                // åˆ›å»ºè§†å£
                if (this.config.showViewport) {
                    this.viewportRect = document.createElement('div')
                    this.viewportRect.style.cssText = `
                        position: absolute;
                        border: 2px solid ${this.config.viewportColor};
                        background: rgba(114, 46, 209, 0.1);
                        cursor: move;
                        pointer-events: auto;
                        box-sizing: border-box;
                    `
                    this.element.appendChild(this.viewportRect)
                }

                this.element.appendChild(this.canvas)
                this.container.appendChild(this.element)
            }

            getPosition() {
                const margin = '10px'
                switch (this.config.position) {
                    case 'top-left': return `top: ${margin}; left: ${margin};`
                    case 'top-right': return `top: ${margin}; right: ${margin};`
                    case 'bottom-left': return `bottom: ${margin}; left: ${margin};`
                    default: return `bottom: ${margin}; right: ${margin};`
                }
            }

            bindEvents() {
                if (!this.canvas) return

                // ç‚¹å‡»å¯¼èˆª
                this.canvas.addEventListener('click', (e) => {
                    const rect = this.canvas.getBoundingClientRect()
                    const x = e.clientX - rect.left
                    const y = e.clientY - rect.top

                    const worldX = this.bounds.x + (x / this.scale)
                    const worldY = this.bounds.y + (y / this.scale)

                    this.lf.translateCenter(worldX, worldY)
                })

                // è§†å£æ‹–æ‹½
                if (this.viewportRect) {
                    this.viewportRect.addEventListener('mousedown', (e) => {
                        e.preventDefault()
                        this.isDragging = true
                    })

                    document.addEventListener('mousemove', (e) => {
                        if (!this.isDragging) return

                        const rect = this.element.getBoundingClientRect()
                        const x = e.clientX - rect.left
                        const y = e.clientY - rect.top

                        const worldX = this.bounds.x + (x / this.scale)
                        const worldY = this.bounds.y + (y / this.scale)

                        this.lf.translateCenter(worldX, worldY)
                    })

                    document.addEventListener('mouseup', () => {
                        this.isDragging = false
                    })
                }

                // ç›‘å¬äº‹ä»¶
                this.lf.on('graph:transform', () => this.refresh())
                this.lf.on('node:add', () => this.refresh())
                this.lf.on('node:delete', () => this.refresh())
                this.lf.on('node:drop', () => this.refresh())
                this.lf.on('edge:add', () => this.refresh())
                this.lf.on('edge:delete', () => this.refresh())
            }

            draw() {
                if (!this.ctx) return

                // æ¸…ç©ºç”»å¸ƒ
                this.ctx.clearRect(0, 0, this.config.width, this.config.height)

                // ç»˜åˆ¶èƒŒæ™¯ç½‘æ ¼
                if (this.config.showGrid) {
                    this.drawGrid()
                }

                // ç»˜åˆ¶å†…å®¹
                const data = this.lf.getGraphData()
                this.drawNodes(data.nodes || [])
                this.drawEdges(data.edges || [])
            }

            drawGrid() {
                if (!this.ctx) return

                this.ctx.strokeStyle = '#f0f0f0'
                this.ctx.lineWidth = 0.5

                const gridSize = 20 * this.scale
                if (gridSize < 2) return

                for (let x = 0; x <= this.config.width; x += gridSize) {
                    this.ctx.beginPath()
                    this.ctx.moveTo(x, 0)
                    this.ctx.lineTo(x, this.config.height)
                    this.ctx.stroke()
                }

                for (let y = 0; y <= this.config.height; y += gridSize) {
                    this.ctx.beginPath()
                    this.ctx.moveTo(0, y)
                    this.ctx.lineTo(this.config.width, y)
                    this.ctx.stroke()
                }
            }

            drawNodes(nodes) {
                if (!this.ctx) return

                nodes.forEach(node => {
                    const x = (node.x - this.bounds.x) * this.scale
                    const y = (node.y - this.bounds.y) * this.scale

                    // èŠ‚ç‚¹å¤§å°
                    const size = Math.max(3, 8 * this.scale)

                    // èŠ‚ç‚¹é¢œè‰²
                    let color = '#1890ff'
                    switch (node.type) {
                        case 'start': color = '#52c41a'; break
                        case 'end': color = '#f5222d'; break
                        case 'approval': color = '#722ed1'; break
                        case 'condition': color = '#fa8c16'; break
                        case 'gateway': color = '#13c2c2'; break
                        default: color = '#1890ff'
                    }

                    this.ctx.fillStyle = color
                    this.ctx.beginPath()
                    this.ctx.arc(x, y, size / 2, 0, 2 * Math.PI)
                    this.ctx.fill()
                })
            }

            drawEdges(edges) {
                if (!this.ctx) return

                this.ctx.strokeStyle = '#d9d9d9'
                this.ctx.lineWidth = Math.max(0.5, 1 * this.scale)

                edges.forEach(edge => {
                    if (!edge.startPoint || !edge.endPoint) return

                    const startX = (edge.startPoint.x - this.bounds.x) * this.scale
                    const startY = (edge.startPoint.y - this.bounds.y) * this.scale
                    const endX = (edge.endPoint.x - this.bounds.x) * this.scale
                    const endY = (edge.endPoint.y - this.bounds.y) * this.scale

                    this.ctx.beginPath()
                    this.ctx.moveTo(startX, startY)
                    this.ctx.lineTo(endX, endY)
                    this.ctx.stroke()
                })
            }

            updateViewportRect() {
                if (!this.viewportRect || !this.config.showViewport) return

                try {
                    const transform = this.lf.getTransform()
                    if (!transform) return

                    const container = this.lf.container || this.container
                    if (!container) return

                    const rect = container.getBoundingClientRect()

                    // è®¡ç®—å½“å‰è§†å£
                    const centerX = -transform.TRANSLATE_X / transform.SCALE_X
                    const centerY = -transform.TRANSLATE_Y / transform.SCALE_Y
                    const width = rect.width / transform.SCALE_X
                    const height = rect.height / transform.SCALE_Y

                    this.currentViewport = {
                        x: centerX - width / 2,
                        y: centerY - height / 2,
                        width,
                        height
                    }

                    // è®¡ç®—è§†å£åœ¨å°åœ°å›¾ä¸­çš„ä½ç½®
                    const x = (this.currentViewport.x - this.bounds.x) * this.scale
                    const y = (this.currentViewport.y - this.bounds.y) * this.scale
                    const w = this.currentViewport.width * this.scale
                    const h = this.currentViewport.height * this.scale

                    // é™åˆ¶åœ¨å°åœ°å›¾èŒƒå›´å†…
                    const left = Math.max(0, Math.min(x, this.config.width - w))
                    const top = Math.max(0, Math.min(y, this.config.height - h))
                    const finalWidth = Math.min(w, this.config.width - left)
                    const finalHeight = Math.min(h, this.config.height - top)

                    this.viewportRect.style.left = `${left}px`
                    this.viewportRect.style.top = `${top}px`
                    this.viewportRect.style.width = `${finalWidth}px`
                    this.viewportRect.style.height = `${finalHeight}px`
                } catch (error) {
                    console.warn('æ›´æ–°è§†å£å¤±è´¥:', error)
                }
            }

            setVisible(visible) {
                if (this.element) {
                    this.element.style.display = visible ? 'block' : 'none'
                }
            }

            forceUpdate() {
                this.refresh()
            }

            destroy() {
                if (this.lf) {
                    this.lf.off('graph:transform')
                    this.lf.off('node:add')
                    this.lf.off('node:delete')
                    this.lf.off('node:drop')
                    this.lf.off('edge:add')
                    this.lf.off('edge:delete')
                }

                if (this.element && this.container.contains(this.element)) {
                    this.container.removeChild(this.element)
                }

                this.element = null
                this.canvas = null
                this.viewportRect = null
                this.ctx = null
            }
        }
        
        // åˆå§‹åŒ–LogicFlow
        console.log('window.LogicFlow:', window.LogicFlow)
        const LogicFlow = window.LogicFlow?.default || window.LogicFlow
        console.log('LogicFlow:', LogicFlow)
        const lf = new LogicFlow({
            container: document.getElementById('container'),
            width: 800,
            height: 600,
            grid: {
                size: 20,
                visible: true,
                type: 'dot',
                config: {
                    color: '#ababab',
                    thickness: 1,
                }
            },
            background: {
                backgroundImage: 'url("data:image/svg+xml,%3csvg width=\'100\' height=\'100\' xmlns=\'http://www.w3.org/2000/svg\'%3e%3cdefs%3e%3cpattern id=\'a\' patternUnits=\'userSpaceOnUse\' width=\'100\' height=\'100\' patternTransform=\'translate(0,0) scale(0.5,0.5)\'%3e%3crect x=\'0\' y=\'0\' width=\'100%25\' height=\'100%25\' fill=\'hsla(0,0%25,100%25,1)\'/%3e%3cpath d=\'m 0 0 L 0 100 L 100 100 L 100 0 Z\' stroke-width=\'1\' stroke=\'hsla(258.5,59.4%25,59.4%25,0.07)\' fill=\'none\'/%3e%3c/pattern%3e%3c/defs%3e%3crect width=\'800%25\' height=\'800%25\' transform=\'translate(0,0)\' fill=\'url(%23a)\'/%3e%3c/svg%3e")',
                backgroundRepeat: 'repeat',
                backgroundSize: '50px 50px'
            }
        })
        
        // åˆå§‹åŒ–å°åœ°å›¾
        const miniMap = new MiniMapPlugin(lf, document.getElementById('container'), {
            width: 200,
            height: 150,
            position: 'bottom-right',
            backgroundColor: '#fafafa',
            borderColor: '#722ed1',
            viewportColor: '#722ed1',
            showGrid: true,
            showViewport: true
        })
        
        // æ·»åŠ ä¸€äº›åˆå§‹èŠ‚ç‚¹
        lf.render({
            nodes: [
                {
                    id: 'node1',
                    type: 'rect',
                    x: 100,
                    y: 100,
                    text: 'å¼€å§‹èŠ‚ç‚¹'
                },
                {
                    id: 'node2', 
                    type: 'rect',
                    x: 300,
                    y: 200,
                    text: 'å¤„ç†èŠ‚ç‚¹'
                },
                {
                    id: 'node3',
                    type: 'rect', 
                    x: 500,
                    y: 300,
                    text: 'ç»“æŸèŠ‚ç‚¹'
                }
            ],
            edges: [
                {
                    id: 'edge1',
                    sourceNodeId: 'node1',
                    targetNodeId: 'node2',
                    type: 'polyline'
                },
                {
                    id: 'edge2',
                    sourceNodeId: 'node2', 
                    targetNodeId: 'node3',
                    type: 'polyline'
                }
            ]
        })
        
        // å…¨å±€å‡½æ•°
        let nodeCount = 4
        let miniMapVisible = true
        
        window.addNode = function() {
            const x = Math.random() * 600 + 100
            const y = Math.random() * 400 + 100
            lf.addNode({
                id: `node${nodeCount++}`,
                type: 'rect',
                x: x,
                y: y,
                text: `èŠ‚ç‚¹${nodeCount - 1}`
            })
        }
        
        window.addEdge = function() {
            const nodes = lf.getGraphData().nodes
            if (nodes.length >= 2) {
                const source = nodes[Math.floor(Math.random() * nodes.length)]
                const target = nodes[Math.floor(Math.random() * nodes.length)]
                if (source.id !== target.id) {
                    lf.addEdge({
                        sourceNodeId: source.id,
                        targetNodeId: target.id,
                        type: 'polyline'
                    })
                }
            }
        }
        
        window.clearAll = function() {
            lf.clearData()
        }
        
        window.toggleMiniMap = function() {
            miniMapVisible = !miniMapVisible
            miniMap.setVisible(miniMapVisible)
        }
        
        window.zoomIn = function() {
            lf.zoom(true)
        }
        
        window.zoomOut = function() {
            lf.zoom(false)
        }
        
        console.log('å°åœ°å›¾æµ‹è¯•é¡µé¢åŠ è½½å®Œæˆ')
        console.log('LogicFlowå®ä¾‹:', lf)
        console.log('å°åœ°å›¾å®ä¾‹:', miniMap)
    </script>
</body>
</html>
