# 架构设计

## 整体架构

### 系统架构图

```
┌─────────────────────────────────────────────────────────────┐
│                    用户接口层 (API Layer)                      │
├─────────────────────────────────────────────────────────────┤
│  createWatermark  │  destroyWatermark  │  Vue Components    │
├─────────────────────────────────────────────────────────────┤
│                   核心管理层 (Core Layer)                      │
├─────────────────────────────────────────────────────────────┤
│  WatermarkCore   │  InstanceManager   │  EventSystem       │
├─────────────────────────────────────────────────────────────┤
│                   功能模块层 (Module Layer)                    │
├─────────────────────────────────────────────────────────────┤
│  Renderers  │  Security  │  Animation  │  Responsive       │
├─────────────────────────────────────────────────────────────┤
│                   基础设施层 (Infrastructure)                  │
├─────────────────────────────────────────────────────────────┤
│  Utils  │  Types  │  Config  │  Error Handling  │  Logger   │
└─────────────────────────────────────────────────────────────┘
```

### 架构特点

1. **分层设计** - 清晰的层次结构，职责分离
2. **模块化** - 功能模块独立，便于维护和扩展
3. **插件化** - 支持自定义渲染器和功能扩展
4. **事件驱动** - 通过事件机制实现模块间通信
5. **类型安全** - 完整的 TypeScript 类型系统

## 核心模块设计

### 1. WatermarkCore (核心引擎)

**职责**：
- 水印实例的创建、更新、销毁
- 渲染器的管理和调度
- 配置的合并和验证
- 生命周期的管理

**核心方法**：
```typescript
class WatermarkCore {
  async init(): Promise<void>
  async create(container: HTMLElement, config: WatermarkConfig): Promise<WatermarkInstance>
  async update(instanceId: string, config: Partial<WatermarkConfig>): Promise<void>
  async destroy(instanceId: string): Promise<void>
  async dispose(): Promise<void>
}
```

**设计特点**：
- 单例模式，全局唯一实例
- 异步 API，不阻塞主线程
- 完整的错误处理机制
- 支持批量操作

### 2. InstanceManager (实例管理器)

**职责**：
- 管理所有水印实例
- 提供实例查询和操作接口
- 处理实例间的关系
- 内存管理和清理

**核心方法**：
```typescript
class InstanceManager {
  add(instance: WatermarkInstance): void
  remove(instanceId: string): void
  get(instanceId: string): WatermarkInstance | undefined
  getAll(): WatermarkInstance[]
  clear(): void
}
```

**设计特点**：
- Map 数据结构，O(1) 查询性能
- 弱引用机制，防止内存泄漏
- 支持实例分组和批量操作
- 提供实例统计信息

### 3. EventSystem (事件系统)

**职责**：
- 事件的注册、触发、移除
- 事件的传播和处理
- 异步事件处理
- 错误事件的特殊处理

**核心方法**：
```typescript
class EventSystem {
  on(event: string, handler: EventHandler): void
  off(event: string, handler?: EventHandler): void
  emit(event: string, ...args: any[]): void
  once(event: string, handler: EventHandler): void
}
```

**设计特点**：
- 发布-订阅模式
- 支持异步事件处理
- 事件命名空间
- 错误事件的自动处理

## 渲染器架构

### 渲染器接口设计

```typescript
interface WatermarkRenderer {
  readonly type: RenderMode
  readonly supportsAnimation: boolean
  readonly supportsOpacity: boolean
  
  isSupported(): boolean
  render(config: WatermarkConfig, context: RenderContext): Promise<HTMLElement[]>
  update(elements: HTMLElement[], config: WatermarkConfig, context: RenderContext): Promise<void>
  destroy(elements: HTMLElement[]): Promise<void>
  dispose(): void
}
```

### 渲染器实现

#### 1. DOM 渲染器
```typescript
class DOMRendererImpl implements WatermarkRenderer {
  type = 'dom' as const
  supportsAnimation = true
  supportsOpacity = true
  
  // 创建 DOM 元素
  private createElement(config: WatermarkConfig): HTMLElement
  
  // 应用样式
  private applyStyles(element: HTMLElement, config: WatermarkConfig): void
  
  // 计算布局
  private calculateLayout(config: WatermarkConfig, containerRect: DOMRect): LayoutResult
}
```

#### 2. Canvas 渲染器
```typescript
class CanvasRendererImpl implements WatermarkRenderer {
  type = 'canvas' as const
  supportsAnimation = true
  supportsOpacity = true
  
  private canvas: HTMLCanvasElement
  private ctx: CanvasRenderingContext2D
  
  // 绘制文字
  private drawText(text: string, x: number, y: number, config: WatermarkConfig): void
  
  // 绘制图片
  private drawImage(image: HTMLImageElement, x: number, y: number, width: number, height: number): void
  
  // 清空画布
  private clear(): void
}
```

#### 3. SVG 渲染器
```typescript
class SVGRendererImpl implements WatermarkRenderer {
  type = 'svg' as const
  supportsAnimation = true
  supportsOpacity = true
  
  // 创建 SVG 元素
  private createSVGElement(config: WatermarkConfig): SVGElement
  
  // 创建文字元素
  private createTextElement(text: string, config: WatermarkConfig): SVGTextElement
  
  // 创建图片元素
  private createImageElement(src: string, config: WatermarkConfig): SVGImageElement
}
```

### 渲染器注册机制

```typescript
class RendererRegistry {
  private renderers = new Map<RenderMode, WatermarkRenderer>()
  
  register(mode: RenderMode, renderer: WatermarkRenderer): void
  unregister(mode: RenderMode): void
  get(mode: RenderMode): WatermarkRenderer | undefined
  getSupported(): RenderMode[]
}
```

## 安全模块架构

### 安全防护策略

```typescript
interface SecurityStrategy {
  readonly name: string
  readonly level: SecurityLevel
  
  enable(instance: WatermarkInstance): void
  disable(instance: WatermarkInstance): void
  isEnabled(): boolean
}
```

### 安全策略实现

#### 1. DOM 监控策略
```typescript
class MutationObserverStrategy implements SecurityStrategy {
  name = 'mutationObserver'
  level = 'medium' as const
  
  private observer: MutationObserver
  
  enable(instance: WatermarkInstance): void {
    this.observer = new MutationObserver((mutations) => {
      this.handleMutations(mutations, instance)
    })
    
    this.observer.observe(instance.container, {
      childList: true,
      subtree: true,
      attributes: true,
      attributeOldValue: true
    })
  }
  
  private handleMutations(mutations: MutationRecord[], instance: WatermarkInstance): void {
    // 检测水印元素是否被删除或修改
    // 如果检测到违规操作，重新创建水印
  }
}
```

#### 2. 样式保护策略
```typescript
class StyleProtectionStrategy implements SecurityStrategy {
  name = 'styleProtection'
  level = 'high' as const
  
  enable(instance: WatermarkInstance): void {
    // 监控样式变化
    // 防止通过 CSS 隐藏水印
  }
}
```

#### 3. Canvas 保护策略
```typescript
class CanvasProtectionStrategy implements SecurityStrategy {
  name = 'canvasProtection'
  level = 'high' as const
  
  enable(instance: WatermarkInstance): void {
    // 保护 Canvas 内容不被篡改
    // 监控 Canvas API 调用
  }
}
```

## 动画模块架构

### 动画引擎设计

```typescript
class AnimationEngine {
  private animations = new Map<string, Animation>()
  
  create(element: HTMLElement, config: AnimationConfig): Animation
  play(animationId: string): void
  pause(animationId: string): void
  stop(animationId: string): void
  destroy(animationId: string): void
}
```

### 动画类型实现

#### 1. 淡入淡出动画
```typescript
class FadeAnimation implements AnimationStrategy {
  type = 'fade' as const
  
  create(element: HTMLElement, config: AnimationConfig): Animation {
    return element.animate([
      { opacity: 0 },
      { opacity: 1 }
    ], {
      duration: config.duration,
      iterations: config.iteration,
      easing: config.easing
    })
  }
}
```

#### 2. 滑动动画
```typescript
class SlideAnimation implements AnimationStrategy {
  type = 'slide' as const
  
  create(element: HTMLElement, config: AnimationConfig): Animation {
    return element.animate([
      { transform: 'translateX(-100%)' },
      { transform: 'translateX(0)' }
    ], {
      duration: config.duration,
      iterations: config.iteration,
      easing: config.easing
    })
  }
}
```

## 响应式模块架构

### 响应式管理器

```typescript
class ResponsiveManager {
  private breakpoints: BreakpointConfig
  private listeners = new Set<ResponsiveListener>()
  
  init(config: ResponsiveConfig): void
  addListener(listener: ResponsiveListener): void
  removeListener(listener: ResponsiveListener): void
  getCurrentBreakpoint(): string
  
  private handleResize(): void
  private notifyListeners(breakpoint: string): void
}
```

### 断点检测

```typescript
class BreakpointDetector {
  detect(breakpoints: BreakpointConfig): string {
    const width = window.innerWidth
    
    for (const [name, config] of Object.entries(breakpoints)) {
      if (this.matchesBreakpoint(width, config)) {
        return name
      }
    }
    
    return 'default'
  }
  
  private matchesBreakpoint(width: number, config: BreakpointRule): boolean {
    if (config.minWidth && width < config.minWidth) return false
    if (config.maxWidth && width > config.maxWidth) return false
    return true
  }
}
```

## 配置系统架构

### 配置管理器

```typescript
class ConfigManager {
  private globalConfig: WatermarkConfig
  private validators = new Map<string, ConfigValidator>()
  
  setGlobalConfig(config: Partial<WatermarkConfig>): void
  getGlobalConfig(): WatermarkConfig
  mergeConfig(base: WatermarkConfig, override: Partial<WatermarkConfig>): WatermarkConfig
  validateConfig(config: WatermarkConfig): ValidationResult
  
  registerValidator(key: string, validator: ConfigValidator): void
}
```

### 配置验证

```typescript
interface ConfigValidator {
  validate(value: any): ValidationResult
}

class StyleValidator implements ConfigValidator {
  validate(style: WatermarkStyle): ValidationResult {
    const errors: string[] = []
    
    if (style.fontSize && (style.fontSize < 1 || style.fontSize > 200)) {
      errors.push('fontSize must be between 1 and 200')
    }
    
    if (style.opacity && (style.opacity < 0 || style.opacity > 1)) {
      errors.push('opacity must be between 0 and 1')
    }
    
    return {
      valid: errors.length === 0,
      errors
    }
  }
}
```

## 错误处理架构

### 错误类型定义

```typescript
abstract class WatermarkError extends Error {
  abstract readonly code: string
  abstract readonly category: ErrorCategory
  
  constructor(message: string, public readonly context?: any) {
    super(message)
    this.name = this.constructor.name
  }
}

class ConfigError extends WatermarkError {
  code = 'CONFIG_ERROR'
  category = 'configuration' as const
}

class RenderError extends WatermarkError {
  code = 'RENDER_ERROR'
  category = 'rendering' as const
}

class SecurityError extends WatermarkError {
  code = 'SECURITY_ERROR'
  category = 'security' as const
}
```

### 错误处理器

```typescript
class ErrorHandler {
  private handlers = new Map<string, ErrorHandlerFunction>()
  
  register(errorCode: string, handler: ErrorHandlerFunction): void
  handle(error: WatermarkError): void
  
  private getDefaultHandler(error: WatermarkError): ErrorHandlerFunction {
    switch (error.category) {
      case 'configuration':
        return this.handleConfigError
      case 'rendering':
        return this.handleRenderError
      case 'security':
        return this.handleSecurityError
      default:
        return this.handleGenericError
    }
  }
}
```

## 性能优化架构

### 虚拟化渲染

```typescript
class VirtualizationManager {
  private visibleElements = new Set<HTMLElement>()
  private observer: IntersectionObserver
  
  enable(container: HTMLElement): void {
    this.observer = new IntersectionObserver((entries) => {
      entries.forEach(entry => {
        if (entry.isIntersecting) {
          this.showElement(entry.target as HTMLElement)
        } else {
          this.hideElement(entry.target as HTMLElement)
        }
      })
    })
  }
  
  private showElement(element: HTMLElement): void
  private hideElement(element: HTMLElement): void
}
```

### 缓存管理

```typescript
class CacheManager {
  private cache = new Map<string, CacheEntry>()
  private maxSize = 100
  private ttl = 5 * 60 * 1000 // 5 minutes
  
  set(key: string, value: any): void
  get(key: string): any | undefined
  clear(): void
  
  private evictExpired(): void
  private evictLRU(): void
}
```

通过这样的架构设计，@ldesign/watermark 实现了高度的模块化、可扩展性和可维护性。每个模块都有明确的职责和接口，模块间通过事件系统进行通信，确保了系统的灵活性和稳定性。
