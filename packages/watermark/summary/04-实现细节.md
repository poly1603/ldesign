# 实现细节

## 核心实现

### 1. WatermarkCore 核心引擎

**主要职责**：
- 水印实例的生命周期管理
- 渲染器的调度和管理
- 配置的验证和合并
- 事件系统的协调

**关键实现**：

```typescript
export class WatermarkCore {
  // 性能优化：添加缓存机制
  private renderCache = new Map<string, HTMLElement[]>()
  private configCache = new Map<string, WatermarkConfig>()
  private contextCache = new Map<string, any>()
  
  // 资源管理
  private cleanupTasks: Array<() => void> = []
  private isDisposed = false

  async create(container: HTMLElement, config: Partial<WatermarkConfig>): Promise<WatermarkInstance> {
    // 性能优化：检查缓存
    const configKey = this.generateConfigKey(config)
    let validatedConfig = this.configCache.get(configKey)
    
    if (!validatedConfig) {
      validatedConfig = await this.configManager.validate(fullConfig)
      this.configCache.set(configKey, validatedConfig)
    }
    
    // 创建实例...
  }
}
```

**优化特点**：
- **智能缓存**：配置、渲染上下文、渲染结果三级缓存
- **内存管理**：自动清理过期缓存，防止内存泄漏
- **错误恢复**：完善的错误处理和恢复机制
- **资源清理**：统一的资源清理机制

### 2. 渲染器系统

#### DOM 渲染器
```typescript
export class DOMRendererImpl implements DOMRenderer {
  async render(config: WatermarkConfig, context: RenderContext): Promise<HTMLElement[]> {
    const layout = this.calculateLayout(config, context.containerRect)
    const elements: HTMLElement[] = []
    
    for (const position of layout.positions) {
      const element = await this.createWatermarkElement(config, layout, position.row, position.col)
      elements.push(element)
    }
    
    return elements
  }
  
  private calculateLayout(config: WatermarkConfig, containerRect: DOMRect): LayoutResult {
    // 智能布局算法
    const { gapX, gapY, width, height } = config.layout
    const positions: Position[] = []
    
    for (let y = 0; y < containerRect.height; y += gapY) {
      for (let x = 0; x < containerRect.width; x += gapX) {
        positions.push({ x, y, row: Math.floor(y / gapY), col: Math.floor(x / gapX) })
      }
    }
    
    return { positions, totalWidth: containerRect.width, totalHeight: containerRect.height }
  }
}
```

#### Canvas 渲染器
```typescript
export class CanvasRendererImpl implements CanvasRenderer {
  private canvas: HTMLCanvasElement
  private ctx: CanvasRenderingContext2D
  
  async render(config: WatermarkConfig, context: RenderContext): Promise<HTMLElement[]> {
    this.setupCanvas(context.containerRect)
    
    if (typeof config.content === 'string') {
      this.drawText(config.content, config)
    } else if (config.content?.image) {
      await this.drawImage(config.content.image, config)
    }
    
    return [this.canvas]
  }
  
  private drawText(text: string, config: WatermarkConfig): void {
    const { style } = config
    this.ctx.font = `${style.fontSize}px ${style.fontFamily}`
    this.ctx.fillStyle = style.color
    this.ctx.globalAlpha = style.opacity
    
    // 应用旋转
    this.ctx.save()
    this.ctx.rotate((style.rotate * Math.PI) / 180)
    this.ctx.fillText(text, 0, 0)
    this.ctx.restore()
  }
}
```

### 3. 配置管理系统

```typescript
export class ConfigManager {
  async validate(config: WatermarkConfig): Promise<WatermarkConfig> {
    const errors: string[] = []
    
    // 验证必需字段
    this.validateRequiredFields(config, errors)
    
    // 验证样式配置
    if (config.style) {
      this.validateStyleConfig(config.style, errors)
    }
    
    // 验证布局配置
    if (config.layout) {
      this.validateLayoutConfig(config.layout, errors)
    }
    
    if (errors.length > 0) {
      throw new WatermarkError(
        `Configuration validation failed: ${errors.join(', ')}`,
        WatermarkErrorCode.INVALID_CONFIG,
        ErrorSeverity.HIGH,
        { errors, config }
      )
    }
    
    return this.mergeWithDefaults(config)
  }
  
  private validateStyleConfig(style: WatermarkStyle, errors: string[]): void {
    // 颜色格式验证
    if (style.color && !this.isValidColor(style.color)) {
      errors.push('Invalid color format')
    }
    
    // 字体大小验证
    if (style.fontSize !== undefined && (style.fontSize < 1 || style.fontSize > 200)) {
      errors.push('Font size must be between 1 and 200')
    }
    
    // 透明度验证
    if (style.opacity !== undefined && (style.opacity < 0 || style.opacity > 1)) {
      errors.push('Opacity must be between 0 and 1')
    }
  }
  
  private isValidColor(color: string): boolean {
    const colorRegex = /^(#[0-9A-Fa-f]{3,8}|rgba?\([^)]+\)|hsla?\([^)]+\)|[a-zA-Z]+|transparent)$/
    return colorRegex.test(color)
  }
}
```

### 4. 安全防护系统

```typescript
export class SecurityManager {
  private strategies = new Map<string, SecurityStrategy>()
  
  async enableProtection(instance: WatermarkInstance): Promise<void> {
    const { level } = instance.config.security
    
    switch (level) {
      case 'high':
        await this.enableStrategy('mutationObserver', instance)
        await this.enableStrategy('styleProtection', instance)
        await this.enableStrategy('canvasProtection', instance)
        break
      case 'medium':
        await this.enableStrategy('mutationObserver', instance)
        await this.enableStrategy('styleProtection', instance)
        break
      case 'low':
        await this.enableStrategy('mutationObserver', instance)
        break
    }
  }
  
  private async enableStrategy(name: string, instance: WatermarkInstance): Promise<void> {
    const strategy = this.strategies.get(name)
    if (strategy) {
      strategy.enable(instance)
    }
  }
}

// DOM 监控策略
export class MutationObserverStrategy implements SecurityStrategy {
  enable(instance: WatermarkInstance): void {
    const observer = new MutationObserver((mutations) => {
      mutations.forEach((mutation) => {
        if (mutation.type === 'childList') {
          // 检查水印元素是否被删除
          this.checkWatermarkIntegrity(instance)
        }
      })
    })
    
    observer.observe(instance.container, {
      childList: true,
      subtree: true,
      attributes: true
    })
    
    instance.cleanupFunctions.push(() => observer.disconnect())
  }
  
  private checkWatermarkIntegrity(instance: WatermarkInstance): void {
    const existingElements = instance.container.querySelectorAll('.watermark-item')
    if (existingElements.length < instance.elements.length) {
      // 水印被删除，重新创建
      this.recreateWatermark(instance)
    }
  }
}
```

### 5. 事件系统

```typescript
export class EventManager {
  private listeners = new Map<string, Set<EventListener>>()
  private eventQueue: WatermarkEvent[] = []
  private processing = false
  
  async emit(event: WatermarkEvent): Promise<void> {
    this.eventQueue.push(event)
    
    if (!this.processing) {
      await this.processEventQueue()
    }
  }
  
  private async processEventQueue(): Promise<void> {
    this.processing = true
    
    while (this.eventQueue.length > 0) {
      const event = this.eventQueue.shift()!
      await this.processEvent(event)
    }
    
    this.processing = false
  }
  
  private async processEvent(event: WatermarkEvent): Promise<void> {
    const listeners = this.listeners.get(event.type)
    if (!listeners) return
    
    const promises = Array.from(listeners).map(async (listener) => {
      try {
        const startTime = performance.now()
        await listener(event)
        const endTime = performance.now()
        console.log(`Event ${event.type} processing time: ${endTime - startTime}ms`)
      } catch (error) {
        console.error(`Event listener error for ${event.type}:`, error)
      }
    })
    
    await Promise.all(promises)
  }
}
```

### 6. 动画引擎

```typescript
export class AnimationEngine {
  private animations = new Map<string, Animation>()
  
  async createAnimation(elementId: string, type: AnimationType): Promise<string> {
    const animationId = generateId('animation')
    
    const animationConfig = this.getAnimationConfig(type)
    const element = document.getElementById(elementId)
    
    if (element) {
      const animation = element.animate(
        animationConfig.keyframes,
        animationConfig.options
      )
      
      this.animations.set(animationId, animation)
      
      // 动画完成后清理
      animation.addEventListener('finish', () => {
        this.animations.delete(animationId)
      })
    }
    
    return animationId
  }
  
  private getAnimationConfig(type: AnimationType): AnimationConfig {
    const configs: Record<AnimationType, AnimationConfig> = {
      fade: {
        keyframes: [
          { opacity: 0 },
          { opacity: 1 }
        ],
        options: {
          duration: 2000,
          iterations: Infinity,
          direction: 'alternate'
        }
      },
      slide: {
        keyframes: [
          { transform: 'translateX(-100%)' },
          { transform: 'translateX(0%)' }
        ],
        options: {
          duration: 3000,
          iterations: Infinity
        }
      },
      rotate: {
        keyframes: [
          { transform: 'rotate(0deg)' },
          { transform: 'rotate(360deg)' }
        ],
        options: {
          duration: 10000,
          iterations: Infinity
        }
      }
    }
    
    return configs[type] || configs.fade
  }
}
```

## 性能优化实现

### 1. 虚拟化渲染

```typescript
export class VirtualizationManager {
  private observer: IntersectionObserver
  private visibleElements = new Set<HTMLElement>()
  
  enable(container: HTMLElement, elements: HTMLElement[]): void {
    this.observer = new IntersectionObserver((entries) => {
      entries.forEach((entry) => {
        const element = entry.target as HTMLElement
        
        if (entry.isIntersecting) {
          this.showElement(element)
          this.visibleElements.add(element)
        } else {
          this.hideElement(element)
          this.visibleElements.delete(element)
        }
      })
    }, {
      root: container,
      rootMargin: '50px',
      threshold: 0.1
    })
    
    elements.forEach(element => this.observer.observe(element))
  }
  
  private showElement(element: HTMLElement): void {
    element.style.display = 'flex'
  }
  
  private hideElement(element: HTMLElement): void {
    element.style.display = 'none'
  }
}
```

### 2. 智能缓存系统

```typescript
export class CacheManager {
  private cache = new Map<string, CacheEntry>()
  private maxSize = 100
  private ttl = 5 * 60 * 1000 // 5分钟
  
  set(key: string, value: any, customTTL?: number): void {
    const entry: CacheEntry = {
      value,
      timestamp: Date.now(),
      ttl: customTTL || this.ttl
    }
    
    this.cache.set(key, entry)
    this.evictIfNeeded()
  }
  
  get(key: string): any | undefined {
    const entry = this.cache.get(key)
    if (!entry) return undefined
    
    // 检查是否过期
    if (Date.now() - entry.timestamp > entry.ttl) {
      this.cache.delete(key)
      return undefined
    }
    
    return entry.value
  }
  
  private evictIfNeeded(): void {
    if (this.cache.size <= this.maxSize) return
    
    // LRU 淘汰策略
    const entries = Array.from(this.cache.entries())
    entries.sort((a, b) => a[1].timestamp - b[1].timestamp)
    
    const toDelete = entries.slice(0, entries.length - this.maxSize)
    toDelete.forEach(([key]) => this.cache.delete(key))
  }
}
```

## 错误处理实现

### 1. 分层错误处理

```typescript
export class ErrorManager {
  private handlers = new Map<ErrorCategory, Set<ErrorHandler>>()
  private recoveryStrategies = new Map<WatermarkErrorCode, ErrorRecoveryStrategy>()
  
  async handleError(error: WatermarkError): Promise<void> {
    // 记录错误
    this.logError(error)
    
    // 尝试恢复
    const recovered = await this.tryRecover(error)
    
    if (!recovered) {
      // 通知错误处理器
      await this.notifyHandlers(error)
    }
  }
  
  private async tryRecover(error: WatermarkError): Promise<boolean> {
    const strategy = this.recoveryStrategies.get(error.code)
    if (!strategy) return false
    
    try {
      await strategy.recover(error)
      return true
    } catch (recoveryError) {
      console.error('Recovery failed:', recoveryError)
      return false
    }
  }
  
  private logError(error: WatermarkError): void {
    const logEntry = {
      timestamp: new Date().toISOString(),
      code: error.code,
      message: error.message,
      severity: error.severity,
      category: error.category,
      instanceId: error.instanceId,
      context: error.context,
      stackTrace: error.stackTrace
    }
    
    console.error(`[WatermarkError] ${error.code}: ${error.message}`, logEntry)
  }
}
```

### 2. 自动恢复策略

```typescript
export class InstanceRecoveryStrategy implements ErrorRecoveryStrategy {
  async recover(error: WatermarkError): Promise<void> {
    if (error.code === WatermarkErrorCode.INSTANCE_CREATION_FAILED) {
      console.log('Attempting to recover from instance creation failure...')
      
      // 清理可能的残留状态
      this.cleanupFailedInstance(error.instanceId)
      
      // 重试创建
      if (error.context?.config && error.context?.container) {
        await this.retryCreateInstance(error.context.config, error.context.container)
      }
    }
  }
  
  private cleanupFailedInstance(instanceId?: string): void {
    if (instanceId) {
      // 清理DOM元素
      const elements = document.querySelectorAll(`[data-watermark-id="${instanceId}"]`)
      elements.forEach(el => el.remove())
    }
  }
  
  private async retryCreateInstance(config: WatermarkConfig, container: HTMLElement): Promise<void> {
    // 使用简化配置重试
    const fallbackConfig = {
      ...config,
      renderMode: 'dom' as const,
      security: { level: 'none' as const },
      animation: { type: 'none' as const }
    }
    
    // 这里应该调用核心创建方法
    // await watermarkCore.create(container, fallbackConfig)
  }
}
```

通过这些详细的实现，@ldesign/watermark 实现了高性能、高可靠性、易维护的水印系统。每个模块都经过精心设计，确保了系统的稳定性和扩展性。
