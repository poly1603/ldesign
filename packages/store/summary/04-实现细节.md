# @ldesign/store 实现细节

## 核心实现原理

### 1. BaseStore 实现机制

#### 构造函数设计
```typescript
class BaseStore<TState, TActions, TGetters> {
  protected _id: string
  protected _store: Store<TState & TActions & TGetters>
  protected _optimizer: PerformanceOptimizer
  protected _subscriptions: (() => void)[] = []

  constructor(id: string, options: StoreOptions<TState, TActions, TGetters>) {
    this._id = id

    // 创建性能优化器
    this._optimizer = new PerformanceOptimizer({
      cache: options?.cache,
      persistence: typeof options?.persist === 'object' ? options.persist : undefined,
    })

    // 创建 Pinia Store
    this._store = defineStore(id, {
      state: options.state,
      actions: this._bindActions(options.actions || {}),
      getters: options.getters || {}
    })()

    // 初始化持久化
    if (options.persist) {
      this._initializePersistence()
    }
  }
}
```

#### 动作绑定机制
```typescript
private _bindActions(actions: TActions): TActions {
  const boundActions = {} as TActions

  for (const [key, action] of Object.entries(actions)) {
    boundActions[key] = (...args: any[]) => {
      // 性能监控
      const startTime = performance.now()

      try {
        // 执行原始动作，绑定正确的 this 上下文
        const result = action.apply(this._store, args)

        // 如果是 Promise，处理异步情况
        if (result instanceof Promise) {
          return result.finally(() => {
            this._recordActionMetrics(key, performance.now() - startTime)
          })
        }

        this._recordActionMetrics(key, performance.now() - startTime)
        return result
      } catch (error) {
        this._handleActionError(key, error)
        throw error
      }
    }
  }

  return boundActions
}
```

### 2. FunctionalStore 实现机制

#### 创建流程
```typescript
export function createFunctionalStore<TState, TActions, TGetters>(
  options: FunctionalStoreOptions<TState, TActions, TGetters>
): FunctionalStoreInstance<TState, TActions, TGetters> {
  // 创建性能优化器
  const optimizer = new PerformanceOptimizer({
    cache: options.cache,
    persistence: options.persist
  })

  // 创建 Pinia Store 定义
  const storeDefinition = defineStore(options.id, {
    state: options.state,
    actions: options.actions || ({} as TActions),
    getters: options.getters || ({} as TGetters),
  })

  // 返回工厂函数
  return () => {
    const store = storeDefinition()

    // 包装 Store 实例，添加扩展功能
    return createStoreWrapper(store, optimizer, options)
  }
}
```

#### Store 包装器实现
```typescript
function createStoreWrapper<TState, TActions, TGetters>(
  store: Store,
  optimizer: PerformanceOptimizer,
  options: FunctionalStoreOptions<TState, TActions, TGetters>
): FunctionalStoreInstance<TState, TActions, TGetters> {
  const subscriptions: (() => void)[] = []

  return {
    // 基础属性
    $id: store.$id,
    $state: store.$state,
    $actions: store as any,
    $getters: store as any,

    // 扩展方法
    $patch: (partialStateOrMutator) => {
      if (typeof partialStateOrMutator === 'function') {
        store.$patch(partialStateOrMutator as any)
      } else {
        store.$patch(partialStateOrMutator)
      }

      // 触发持久化
      if (options.persist) {
        optimizer.persistence.save(options.id, store.$state)
      }
    },

    $reset: () => {
      store.$reset()
    },

    $subscribe: (callback, options) => {
      const unsubscribe = store.$subscribe(callback, options)
      if (!options?.detached) {
        subscriptions.push(unsubscribe)
      }
      return unsubscribe
    },

    // 缓存方法
    $getCache: (key) => optimizer.cache.get(key),
    $setCache: (key, value, ttl) => optimizer.cache.set(key, value, ttl),
    $deleteCache: (key) => optimizer.cache.delete(key),
    $clearCache: () => optimizer.cache.clear(),

    // 持久化方法
    $persist: () => {
      if (options.persist) {
        optimizer.persistence.save(options.id, store.$state)
      }
    },

    $hydrate: () => {
      if (options.persist) {
        const persistedState = optimizer.persistence.load(options.id)
        if (persistedState) {
          store.$patch(persistedState)
        }
      }
    },

    // 清理方法
    $dispose: () => {
      subscriptions.forEach(unsubscribe => unsubscribe())
      subscriptions.length = 0
      optimizer.dispose()
    },

    // 元数据方法
    getStore: () => store,
    getStoreDefinition: () => storeDefinition
  }
}
```

### 3. CompositionStore 实现机制

#### 上下文创建
```typescript
function createCompositionStoreContext(
  optimizer: PerformanceOptimizer,
  options: CompositionStoreOptions
): CompositionStoreContext {
  const cleanupFunctions: (() => void)[] = []

  return {
    // 响应式状态
    state: <T>(initialValue: T): Ref<T> => {
      return ref(initialValue)
    },

    // 计算属性
    computed: <T>(getter: () => T): ComputedRef<T> => {
      return computed(getter)
    },

    // 响应式对象
    reactive: <T extends object>(obj: T): T => {
      return reactive(obj)
    },

    // 监听器
    watch: (source, callback, options) => {
      const stop = watch(source, callback, options)
      cleanupFunctions.push(stop)
      return stop
    },

    // 生命周期
    onUnmounted: (callback) => {
      cleanupFunctions.push(callback)
    },

    // 缓存管理
    cache: optimizer.cache,

    // 持久化管理
    persist: {
      save: () => {
        const currentState = storeDefinition().$state
        optimizer.persistence.save(options.id, currentState)
      },
      load: () => {
        const persistedState = optimizer.persistence.load(options.id)
        if (persistedState) {
          const currentState = storeDefinition().$state
          if (typeof currentState === 'object' && currentState !== null) {
            Object.assign(currentState as Record<string, any>, persistedState)
          }
        }
      },
      clear: () => optimizer.persistence.remove(options.id),
    },

    // 清理函数
    cleanup: () => {
      cleanupFunctions.forEach(fn => fn())
      cleanupFunctions.length = 0
    }
  }
}
```

### 4. 性能优化实现

#### 缓存管理器实现
```typescript
class CacheManager {
  private cache = new Map<string, CacheEntry>()
  private accessOrder = new Map<string, number>()
  private currentTime = 0

  constructor(
    private maxSize: number = 100,
    private defaultTTL: number = 5 * 60 * 1000 // 5分钟
  ) {}

  set(key: string, value: any, ttl?: number): void {
    const now = Date.now()
    const expireTime = now + (ttl ?? this.defaultTTL)

    // 如果缓存已满，执行 LRU 淘汰
    if (this.cache.size >= this.maxSize && !this.cache.has(key)) {
      this.evictLRU()
    }

    this.cache.set(key, { value, expireTime })
    this.accessOrder.set(key, ++this.currentTime)
  }

  get(key: string): any | undefined {
    const entry = this.cache.get(key)
    if (!entry) return undefined

    // 检查是否过期
    if (Date.now() > entry.expireTime) {
      this.cache.delete(key)
      this.accessOrder.delete(key)
      return undefined
    }

    // 更新访问顺序
    this.accessOrder.set(key, ++this.currentTime)
    return entry.value
  }

  private evictLRU(): void {
    let oldestKey: string | undefined
    let oldestTime = Infinity

    for (const [key, time] of this.accessOrder) {
      if (time < oldestTime) {
        oldestTime = time
        oldestKey = key
      }
    }

    if (oldestKey) {
      this.cache.delete(oldestKey)
      this.accessOrder.delete(oldestKey)
    }
  }

  cleanup(): void {
    const now = Date.now()
    const expiredKeys: string[] = []

    for (const [key, entry] of this.cache) {
      if (now > entry.expireTime) {
        expiredKeys.push(key)
      }
    }

    expiredKeys.forEach(key => {
      this.cache.delete(key)
      this.accessOrder.delete(key)
    })
  }
}
```

#### 防抖管理器实现
```typescript
class DebounceManager {
  private timers = new Map<string, NodeJS.Timeout>()

  debounce<T extends (...args: any[]) => any>(
    key: string,
    fn: T,
    delay: number
  ): T {
    return ((...args: any[]) => {
      // 清除之前的定时器
      const existingTimer = this.timers.get(key)
      if (existingTimer) {
        clearTimeout(existingTimer)
      }

      // 创建新的定时器
      const timer = setTimeout(() => {
        this.timers.delete(key)
        fn.apply(this, args)
      }, delay)

      this.timers.set(key, timer)
    }) as T
  }

  cancel(key: string): void {
    const timer = this.timers.get(key)
    if (timer) {
      clearTimeout(timer)
      this.timers.delete(key)
    }
  }

  clear(): void {
    for (const timer of this.timers.values()) {
      clearTimeout(timer)
    }
    this.timers.clear()
  }
}
```

### 5. 装饰器实现机制

#### 状态装饰器
```typescript
export function State(options: StateOptions = {}): PropertyDecorator {
  return function (target: any, propertyKey: string | symbol) {
    // 获取或创建元数据
    const metadata = getMetadata(target) || {}

    // 记录状态属性
    metadata.states = metadata.states || {}
    metadata.states[propertyKey as string] = {
      default: options.default,
      reactive: options.reactive ?? true,
      readonly: options.readonly ?? false
    }

    // 设置元数据
    setMetadata(target, metadata)

    // 定义属性描述符
    const descriptor: PropertyDescriptor = {
      get() {
        return this._store?.[propertyKey] ?? options.default
      },
      set(value) {
        if (this._store) {
          this._store[propertyKey] = value
        }
      },
      enumerable: true,
      configurable: true
    }

    // 如果是只读属性，移除 setter
    if (options.readonly) {
      delete descriptor.set
    }

    Object.defineProperty(target, propertyKey, descriptor)
  }
}
```

#### 动作装饰器
```typescript
export function Action(options: ActionOptions = {}): MethodDecorator {
  return function (target: any, propertyKey: string | symbol, descriptor: PropertyDescriptor) {
    const originalMethod = descriptor.value

    // 包装原始方法
    descriptor.value = function (...args: any[]) {
      const startTime = performance.now()

      try {
        // 执行原始方法
        const result = originalMethod.apply(this, args)

        // 处理异步方法
        if (result instanceof Promise) {
          return result.finally(() => {
            this._recordActionMetrics?.(propertyKey as string, performance.now() - startTime)
          })
        }

        this._recordActionMetrics?.(propertyKey as string, performance.now() - startTime)
        return result
      } catch (error) {
        this._handleActionError?.(propertyKey as string, error)
        throw error
      }
    }

    // 记录元数据
    const metadata = getMetadata(target) || {}
    metadata.actions = metadata.actions || {}
    metadata.actions[propertyKey as string] = options
    setMetadata(target, metadata)

    return descriptor
  }
}
```

#### 缓存装饰器
```typescript
export function Cache(options: CacheDecoratorOptions = {}): MethodDecorator {
  return function (target: any, propertyKey: string | symbol, descriptor: PropertyDescriptor) {
    const originalMethod = descriptor.value
    const cacheKey = `${target.constructor.name}.${propertyKey as string}`

    descriptor.value = function (...args: any[]) {
      // 生成缓存键
      const fullCacheKey = args.length > 0
        ? `${cacheKey}:${JSON.stringify(args)}`
        : cacheKey

      // 检查缓存
      const cached = this._optimizer?.cache.get(fullCacheKey)
      if (cached !== undefined) {
        return cached
      }

      // 执行原始方法
      const result = originalMethod.apply(this, args)

      // 缓存结果
      if (result instanceof Promise) {
        return result.then(value => {
          this._optimizer?.cache.set(fullCacheKey, value, options.ttl)
          return value
        })
      } else {
        this._optimizer?.cache.set(fullCacheKey, result, options.ttl)
        return result
      }
    }

    return descriptor
  }
}
```

### 6. Store 工厂实现

#### 工厂创建逻辑
```typescript
class StoreFactory {
  private static definitions = new Map<string, any>()
  private static instances = new Map<string, any>()

  static create(options: StoreFactoryOptions): any {
    const id = (options as any).id

    if (!id) {
      throw new Error('Store id is required')
    }

    // 检查是否已经创建过
    if (this.definitions.has(id)) {
      console.warn(`Store with id "${id}" already exists. Returning existing definition.`)
      return this.definitions.get(id)
    }

    let storeFactory: any

    switch (options.type) {
      case StoreType.CLASS:
        storeFactory = this.createClassStore(options as ClassStoreOptions)
        break
      case StoreType.FUNCTIONAL:
        storeFactory = this.createFunctionalStore(options as FunctionalStoreOptions)
        break
      case StoreType.COMPOSITION:
        storeFactory = this.createCompositionStore(options as CompositionStoreOptions)
        break
      default:
        throw new Error(`Unknown store type: ${(options as any).type}`)
    }

    // 缓存定义
    this.definitions.set(id, storeFactory)

    // 包装工厂函数以支持实例管理
    return () => {
      if (!this.instances.has(id)) {
        const instance = storeFactory()
        this.instances.set(id, instance)
      }
      return this.instances.get(id)
    }
  }

  private static createClassStore(options: ClassStoreOptions): () => any {
    return () => new options.storeClass(options.id)
  }

  private static createFunctionalStore(options: FunctionalStoreOptions): () => any {
    return createFunctionalStore(options)
  }

  private static createCompositionStore(options: CompositionStoreOptions): () => any {
    return createCompositionStore(options, options.setup)
  }
}
```

### 7. 错误处理实现

#### 错误分类和处理
```typescript
class ErrorHandler {
  static handleConfigError(error: ConfigError): void {
    console.error(`[Store Config Error] ${error.message}`)
    if (process.env.NODE_ENV === 'development') {
      console.error('Stack:', error.stack)
      console.error('Suggestions:', error.suggestions)
    }
  }

  static handleTypeError(error: TypeError): void {
    console.error(`[Store Type Error] ${error.message}`)
    if (process.env.NODE_ENV === 'development') {
      console.error('Expected type:', error.expectedType)
      console.error('Actual type:', error.actualType)
    }
  }

  static handleRuntimeError(error: RuntimeError): void {
    console.error(`[Store Runtime Error] ${error.message}`)
    if (process.env.NODE_ENV === 'development') {
      console.error('Context:', error.context)
      console.error('Recovery suggestions:', error.recoverySuggestions)
    }
  }
}
```

### 8. 性能监控实现

#### 指标收集
```typescript
class PerformanceMonitor {
  private metrics = new Map<string, Metric>()
  private timers = new Map<string, number>()

  startTiming(key: string): void {
    this.timers.set(key, performance.now())
  }

  endTiming(key: string): number {
    const startTime = this.timers.get(key)
    if (!startTime) return 0

    const duration = performance.now() - startTime
    this.timers.delete(key)

    // 记录指标
    const metric = this.metrics.get(key) || {
      count: 0,
      totalTime: 0,
      avgTime: 0,
      minTime: Infinity,
      maxTime: 0
    }

    metric.count++
    metric.totalTime += duration
    metric.avgTime = metric.totalTime / metric.count
    metric.minTime = Math.min(metric.minTime, duration)
    metric.maxTime = Math.max(metric.maxTime, duration)

    this.metrics.set(key, metric)
    return duration
  }

  getOptimizationSuggestions(): Suggestion[] {
    const suggestions: Suggestion[] = []

    for (const [key, metric] of this.metrics) {
      if (metric.avgTime > 100) { // 超过100ms
        suggestions.push({
          type: 'performance',
          message: `Action "${key}" is slow (avg: ${metric.avgTime.toFixed(2)}ms). Consider caching or optimization.`,
          severity: 'warning'
        })
      }

      if (metric.count > 1000) { // 调用次数过多
        suggestions.push({
          type: 'frequency',
          message: `Action "${key}" is called frequently (${metric.count} times). Consider debouncing or throttling.`,
          severity: 'info'
        })
      }
    }

    return suggestions
  }
}
```

---

这些实现细节展示了 @ldesign/store 如何在保持简洁 API 的同时，提供强大的功能和优异的性能。每个组件都经过精心设计，确保可扩展性和可维护性。
