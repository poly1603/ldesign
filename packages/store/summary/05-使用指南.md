# @ldesign/store 使用指南

## 快速开始

### 安装和配置

```bash
# 安装依赖
pnpm add @ldesign/store pinia

# 配置 Pinia
import { createApp } from 'vue'
import { createPinia } from 'pinia'
import App from './App.vue'

const app = createApp(App)
app.use(createPinia())
app.mount('#app')
```

## 使用方式详解

### 1. 类式 Store（推荐用于复杂业务）

#### 基础用法
```typescript
import { BaseStore } from '@ldesign/store'

class UserStore extends BaseStore<
  { users: User[]; loading: boolean },
  { fetchUsers: () => Promise<void>; addUser: (user: User) => void },
  { activeUsers: User[]; userCount: number }
> {
  constructor() {
    super('user', {
      state: () => ({
        users: [],
        loading: false
      }),
      actions: {
        async fetchUsers() {
          this.loading = true
          try {
            this.users = await api.getUsers()
          } finally {
            this.loading = false
          }
        },
        addUser(user: User) {
          this.users.push(user)
        }
      },
      getters: {
        activeUsers: (state) => state.users.filter(u => u.active),
        userCount: (state) => state.users.length
      }
    })
  }
}

// 使用
const useUserStore = () => new UserStore()
```

#### 装饰器增强
```typescript
import { BaseStore, State, Action, Getter, Cache, Debounce } from '@ldesign/store'

class UserStore extends BaseStore {
  @State()
  users: User[] = []

  @State()
  loading: boolean = false

  @Action()
  @Cache({ ttl: 5000 }) // 缓存5秒
  async fetchUsers() {
    this.loading = true
    try {
      this.users = await api.getUsers()
    } finally {
      this.loading = false
    }
  }

  @Action()
  @Debounce(300) // 防抖300ms
  async searchUsers(query: string) {
    this.users = await api.searchUsers(query)
  }

  @Getter()
  @Cache() // 缓存计算结果
  get activeUsers() {
    return this.users.filter(user => user.active)
  }
}
```

### 2. 函数式 Store（推荐用于快速开发）

#### 基础配置
```typescript
import { createFunctionalStore } from '@ldesign/store'

const useUserStore = createFunctionalStore({
  id: 'user',
  state: () => ({
    users: [] as User[],
    loading: false,
    error: null as string | null
  }),
  actions: {
    async fetchUsers() {
      this.loading = true
      this.error = null
      try {
        this.users = await api.getUsers()
      } catch (error) {
        this.error = error.message
      } finally {
        this.loading = false
      }
    },
    addUser(user: User) {
      this.users.push(user)
    },
    removeUser(id: string) {
      const index = this.users.findIndex(u => u.id === id)
      if (index > -1) {
        this.users.splice(index, 1)
      }
    }
  },
  getters: {
    activeUsers: (state) => state.users.filter(u => u.active),
    userCount: (state) => state.users.length,
    hasError: (state) => !!state.error
  }
})
```

#### 性能优化配置
```typescript
const useOptimizedStore = createFunctionalStore({
  id: 'optimized',
  state: () => ({ data: [], cache: new Map() }),

  // 缓存配置
  cache: {
    maxSize: 100,
    defaultTTL: 5000,
    cleanupInterval: 60000
  },

  // 持久化配置
  persist: {
    storage: localStorage,
    paths: ['data'], // 只持久化 data 字段
    serializer: {
      serialize: JSON.stringify,
      deserialize: JSON.parse
    }
  },

  actions: {
    async fetchData(params: any) {
      const cacheKey = `fetchData:${JSON.stringify(params)}`

      // 检查缓存
      const cached = this.$getCache(cacheKey)
      if (cached) return cached

      // 获取数据
      const data = await api.getData(params)

      // 缓存结果
      this.$setCache(cacheKey, data, 10000)
      this.data = data

      return data
    }
  }
})
```

### 3. Composition Store（推荐用于现代化开发）

#### 基础用法
```typescript
import { createCompositionStore } from '@ldesign/store'

const useUserStore = createCompositionStore(
  { id: 'user' },
  ({ state, computed, watch }) => {
    // 响应式状态
    const users = state<User[]>([])
    const loading = state(false)
    const searchQuery = state('')

    // 计算属性
    const activeUsers = computed(() =>
      users.value.filter(user => user.active)
    )

    const filteredUsers = computed(() => {
      if (!searchQuery.value) return users.value
      return users.value.filter(user =>
        user.name.toLowerCase().includes(searchQuery.value.toLowerCase())
      )
    })

    // 监听器
    watch(searchQuery, (newQuery) => {
      if (newQuery) {
        searchUsers(newQuery)
      }
    })

    // 方法
    const fetchUsers = async () => {
      loading.value = true
      try {
        users.value = await api.getUsers()
      } finally {
        loading.value = false
      }
    }

    const searchUsers = async (query: string) => {
      users.value = await api.searchUsers(query)
    }

    return {
      // 状态
      users,
      loading,
      searchQuery,

      // 计算属性
      activeUsers,
      filteredUsers,

      // 方法
      fetchUsers,
      searchUsers
    }
  }
)
```

#### 高级用法
```typescript
const useAdvancedStore = createCompositionStore(
  {
    id: 'advanced',
    cache: { maxSize: 50 },
    persist: { storage: sessionStorage }
  },
  ({ state, computed, watch, onUnmounted, cache, persist }) => {
    const data = state([])
    const filters = state({ status: 'all', category: '' })

    // 使用缓存
    const expensiveComputation = computed(() => {
      const cacheKey = `computation:${JSON.stringify(filters.value)}`
      const cached = cache.get(cacheKey)
      if (cached) return cached

      const result = data.value
        .filter(item => filters.value.status === 'all' || item.status === filters.value.status)
        .filter(item => !filters.value.category || item.category === filters.value.category)
        .reduce((acc, item) => acc + item.value, 0)

      cache.set(cacheKey, result, 5000)
      return result
    })

    // 自动持久化
    watch([data, filters], () => {
      persist.save()
    }, { deep: true })

    // 清理资源
    onUnmounted(() => {
      console.log('Store unmounted, cleaning up...')
    })

    return { data, filters, expensiveComputation }
  }
)
```

### 4. Store 工厂模式

#### 统一管理
```typescript
import { StoreFactory, StoreType } from '@ldesign/store'

// 创建不同类型的 Store
const userStoreFactory = StoreFactory.create({
  type: StoreType.CLASS,
  id: 'user',
  storeClass: UserStore
})

const settingsStoreFactory = StoreFactory.create({
  type: StoreType.FUNCTIONAL,
  id: 'settings',
  state: () => ({ theme: 'light', language: 'zh-CN' }),
  actions: {
    toggleTheme() {
      this.theme = this.theme === 'light' ? 'dark' : 'light'
    },
    setLanguage(lang: string) {
      this.language = lang
    }
  }
})

// 使用
const userStore = userStoreFactory()
const settingsStore = settingsStoreFactory()

// 管理功能
console.log(StoreFactory.getIds()) // ['user', 'settings']
console.log(StoreFactory.getStats()) // 统计信息
```

## 在组件中使用

### Vue 组件集成
```vue
<script setup lang="ts">
import { ref, onMounted } from 'vue'
import { useUserStore } from '@/stores/user'

const userStore = useUserStore()
const searchQuery = ref('')

// 防抖搜索
const handleSearch = debounce((event) => {
  userStore.searchUsers(event.target.value)
}, 300)

onMounted(() => {
  userStore.fetchUsers()
})

function debounce(fn: Function, delay: number) {
  let timer: NodeJS.Timeout
  return (...args: any[]) => {
    clearTimeout(timer)
    timer = setTimeout(() => fn.apply(this, args), delay)
  }
}
</script>

<template>
  <div class="user-management">
    <!-- 加载状态 -->
    <div v-if="userStore.loading" class="loading">
      加载中...
    </div>

    <!-- 错误状态 -->
    <div v-else-if="userStore.error" class="error">
      {{ userStore.error }}
    </div>

    <!-- 用户列表 -->
    <div v-else>
      <div class="search">
        <input
          v-model="searchQuery"
          placeholder="搜索用户..."
          @input="handleSearch"
        >
      </div>

      <div class="stats">
        <span>总用户数: {{ userStore.userCount }}</span>
        <span>活跃用户: {{ userStore.activeUsers.length }}</span>
      </div>

      <div class="user-list">
        <div
          v-for="user in userStore.users"
          :key="user.id"
          class="user-item"
        >
          <span>{{ user.name }}</span>
          <button @click="userStore.removeUser(user.id)">删除</button>
        </div>
      </div>

      <button @click="userStore.fetchUsers">刷新</button>
    </div>
  </div>
</template>
```

### Hooks 使用方式
```typescript
import { useStoreState, useStoreActions, useStoreGetters } from '@ldesign/store'

function useUserManagement() {
  const userStore = useUserStore()

  // 响应式状态
  const users = useStoreState(userStore, 'users')
  const loading = useStoreState(userStore, 'loading')
  const error = useStoreState(userStore, 'error')

  // 动作方法
  const { fetchUsers, addUser, removeUser } = useStoreActions(userStore, [
    'fetchUsers',
    'addUser',
    'removeUser'
  ])

  // 计算属性
  const { activeUsers, userCount } = useStoreGetters(userStore, [
    'activeUsers',
    'userCount'
  ])

  return {
    // 状态
    users,
    loading,
    error,

    // 计算属性
    activeUsers,
    userCount,

    // 方法
    fetchUsers,
    addUser,
    removeUser
  }
}
```

## 最佳实践

### 1. Store 设计原则
```typescript
// ✅ 好的设计 - 单一职责
class UserStore extends BaseStore {
  // 只管理用户相关状态
}

class AuthStore extends BaseStore {
  // 只管理认证相关状态
}

// ❌ 避免的设计 - 职责混乱
class AppStore extends BaseStore {
  // 混合了用户、认证、设置等多种职责
}
```

### 2. 性能优化策略
```typescript
class OptimizedStore extends BaseStore {
  // 合理使用缓存
  @Getter()
  @Cache({ ttl: 5000 })
  get expensiveComputation() {
    return this.data.reduce((acc, item) => acc + item.value, 0)
  }

  // 防抖频繁操作
  @Action()
  @Debounce(300)
  async search(query: string) {
    // 搜索逻辑
  }

  // 节流高频更新
  @Action()
  @Throttle(100)
  updatePosition(x: number, y: number) {
    // 位置更新逻辑
  }
}
```

### 3. 错误处理
```typescript
const useRobustStore = createFunctionalStore({
  id: 'robust',
  state: () => ({
    data: [],
    loading: false,
    error: null,
    retryCount: 0
  }),
  actions: {
    async fetchData() {
      this.loading = true
      this.error = null

      try {
        this.data = await api.getData()
        this.retryCount = 0 // 重置重试次数
      } catch (error) {
        this.error = error.message

        // 自动重试机制
        if (this.retryCount < 3) {
          this.retryCount++
          setTimeout(() => this.fetchData(), 1000 * this.retryCount)
        }
      } finally {
        this.loading = false
      }
    }
  }
})
```

### 4. 类型安全实践
```typescript
// 定义严格的接口
interface UserState {
  users: User[]
  loading: boolean
  error: string | null
}

interface UserActions {
  fetchUsers(): Promise<void>
  addUser(user: Omit<User, 'id'>): Promise<User>
  removeUser(id: string): Promise<void>
}

interface UserGetters {
  activeUsers: User[]
  userCount: number
  getUserById: (id: string) => User | undefined
}

// 使用严格类型约束
class UserStore extends BaseStore<UserState, UserActions, UserGetters> {
  // TypeScript 会确保实现符合接口定义
}
```

---

通过这些使用方式和最佳实践，你可以充分发挥 @ldesign/store 的强大功能，构建高性能、可维护的状态管理系统。
