# @ldesign/store 架构设计

## 整体架构概览

@ldesign/store 采用分层架构设计，从底层到顶层分为以下几个层次：

```
┌─────────────────────────────────────────────────────────────┐
│                    用户接口层 (User API Layer)                │
├─────────────────┬─────────────────┬─────────────────────────┤
│   类式 Store     │   函数式 Store   │   Composition Store     │
│   BaseStore     │ FunctionalStore │  CompositionStore       │
├─────────────────┴─────────────────┴─────────────────────────┤
│                    核心功能层 (Core Layer)                   │
├─────────────────┬─────────────────┬─────────────────────────┤
│   性能优化模块   │   装饰器系统     │   Hooks 系统            │
│ PerformanceOpt  │   Decorators    │   Hooks                 │
├─────────────────┴─────────────────┴─────────────────────────┤
│                   适配层 (Adapter Layer)                    │
├─────────────────────────────────────────────────────────────┤
│                   Pinia 核心 (Pinia Core)                   │
└─────────────────────────────────────────────────────────────┘
```

## 核心模块设计

### 1. 用户接口层 (User API Layer)

#### BaseStore - 类式 Store 基类
```typescript
abstract class BaseStore<TState, TActions, TGetters> {
  protected _id: string
  protected _store: Store
  protected _optimizer: PerformanceOptimizer

  constructor(id: string, options: StoreOptions<TState, TActions, TGetters>)

  // 核心方法
  $patch(partialState: Partial<TState>): void
  $reset(): void
  $subscribe(callback: SubscriptionCallback): () => void
  $dispose(): void

  // 性能优化方法
  $getCache(key: string): any
  $setCache(key: string, value: any, ttl?: number): void
  $persist(): void
  $hydrate(): void
}
```

**设计特点**:
- 泛型约束确保类型安全
- 内置性能优化器
- 提供完整的生命周期管理
- 支持装饰器扩展

#### FunctionalStore - 函数式 Store
```typescript
interface FunctionalStoreOptions<TState, TActions, TGetters> {
  id: string
  state: () => TState
  actions?: TActions
  getters?: TGetters
  cache?: CacheOptions
  persist?: PersistOptions
}

function createFunctionalStore<TState, TActions, TGetters>(
  options: FunctionalStoreOptions<TState, TActions, TGetters>
): FunctionalStoreInstance<TState, TActions, TGetters>
```

**设计特点**:
- 配置化创建
- 自动类型推导
- 内置性能优化
- 简洁的 API 设计

#### CompositionStore - 组合式 Store
```typescript
interface CompositionStoreContext {
  state: <T>(initialValue: T) => Ref<T>
  computed: <T>(getter: () => T) => ComputedRef<T>
  watch: typeof watch
  onUnmounted: typeof onUnmounted
  cache: CacheManager
  persist: PersistenceManager
}

function createCompositionStore<T>(
  options: CompositionStoreOptions,
  setup: (context: CompositionStoreContext) => T
): () => CompositionStoreInstance<T>
```

**设计特点**:
- Vue 3 原生体验
- 完整的 Composition API 支持
- 灵活的状态组合
- 自动资源清理

### 2. 核心功能层 (Core Layer)

#### PerformanceOptimizer - 性能优化器
```typescript
class PerformanceOptimizer {
  cache: CacheManager
  persistence: PersistenceManager
  debounce: DebounceManager
  throttle: ThrottleManager

  constructor(options?: PerformanceOptions)
  dispose(): void
}
```

**组件设计**:

##### CacheManager - 缓存管理器
```typescript
class CacheManager {
  private cache: Map<string, CacheEntry>
  private maxSize: number
  private defaultTTL: number

  set(key: string, value: any, ttl?: number): void
  get(key: string): any | undefined
  delete(key: string): boolean
  clear(): void
  cleanup(): void // 清理过期缓存
  size(): number
}
```

**特性**:
- LRU 淘汰策略
- TTL 过期机制
- 自动清理
- 内存限制

##### PersistenceManager - 持久化管理器
```typescript
class PersistenceManager {
  private storage: Storage
  private serializer: Serializer

  save(key: string, state: any, paths?: string[]): void
  load(key: string): any | null
  remove(key: string): void
  clear(): void
}
```

**特性**:
- 多种存储支持 (localStorage, sessionStorage, IndexedDB)
- 自定义序列化器
- 选择性持久化
- 错误处理

##### DebounceManager - 防抖管理器
```typescript
class DebounceManager {
  private timers: Map<string, NodeJS.Timeout>

  debounce<T extends (...args: any[]) => any>(
    key: string,
    fn: T,
    delay: number
  ): T

  cancel(key: string): void
  clear(): void
}
```

##### ThrottleManager - 节流管理器
```typescript
class ThrottleManager {
  private lastExecTime: Map<string, number>

  throttle<T extends (...args: any[]) => any>(
    key: string,
    fn: T,
    delay: number
  ): T

  reset(key: string): void
  clear(): void
}
```

#### 装饰器系统
```typescript
// 状态装饰器
function State(options?: StateOptions): PropertyDecorator

// 动作装饰器
function Action(options?: ActionOptions): MethodDecorator

// 计算属性装饰器
function Getter(options?: GetterOptions): MethodDecorator

// 性能装饰器
function Cache(options?: CacheOptions): MethodDecorator
function Debounce(delay: number): MethodDecorator
function Throttle(delay: number): MethodDecorator
```

**实现原理**:
- 基于 reflect-metadata
- 编译时类型检查
- 运行时功能增强
- 元数据驱动

#### Hooks 系统
```typescript
// 状态 Hook
function useStoreState<T, K extends keyof T>(
  store: T,
  key: K
): Ref<T[K]>

// 动作 Hook
function useStoreActions<T, K extends keyof T>(
  store: T,
  keys: K[]
): Pick<T, K>

// 计算属性 Hook
function useStoreGetters<T, K extends keyof T>(
  store: T,
  keys: K[]
): Pick<T, K>

// 订阅 Hook
function useStoreSubscription<T>(
  store: T,
  callback: SubscriptionCallback
): void
```

### 3. Store 工厂系统

#### StoreFactory - 统一工厂
```typescript
enum StoreType {
  CLASS = 'class',
  FUNCTIONAL = 'functional',
  COMPOSITION = 'composition'
}

class StoreFactory {
  private static definitions = new Map<string, any>()
  private static instances = new Map<string, any>()

  static create(options: StoreFactoryOptions): () => any
  static get(id: string): any
  static has(id: string): boolean
  static delete(id: string): boolean
  static clear(): void
  static getIds(): string[]
  static getStats(): StoreStats
}
```

**管理功能**:
- 统一创建接口
- 实例缓存和复用
- 生命周期管理
- 统计和监控

## 数据流设计

### 1. 状态更新流程
```
用户操作 → Action 调用 → 状态变更 → 响应式更新 → 视图更新
    ↓           ↓           ↓           ↓
  装饰器增强  性能优化    持久化保存   缓存更新
```

### 2. 缓存策略
```
计算请求 → 缓存检查 → 命中返回 / 未命中计算 → 结果缓存 → 返回结果
    ↓           ↓                ↓           ↓
  性能监控    TTL检查         LRU更新     统计更新
```

### 3. 持久化流程
```
状态变更 → 持久化检查 → 序列化 → 存储写入 → 完成回调
    ↓           ↓          ↓        ↓
  变更监听    路径过滤   错误处理  性能统计
```

## 类型系统设计

### 1. 核心类型定义
```typescript
// 状态定义
type StateDefinition<T = any> = () => T

// 动作定义
interface ActionDefinition<TState = any> {
  [key: string]: (this: TState, ...args: any[]) => any
}

// 计算属性定义
interface GetterDefinition<TState = any> {
  [key: string]: (state: TState) => any
}

// Store 选项
interface StoreOptions<TState, TActions, TGetters> {
  state: StateDefinition<TState>
  actions?: TActions
  getters?: TGetters
  cache?: CacheOptions
  persist?: PersistOptions
  devtools?: boolean
}
```

### 2. 类型推导机制
```typescript
// 自动推导 this 类型
type InferThis<TState, TActions> = TState & {
  [K in keyof TActions]: TActions[K]
}

// 推导 Store 实例类型
interface StoreInstance<TState, TActions, TGetters> {
  $id: string
  $state: TState
  $actions: TActions
  $getters: TGetters
  // ... 其他方法
}
```

## 插件系统设计

### 1. 插件接口
```typescript
interface Plugin {
  name: string
  version?: string
  install(store: BaseStore, options?: any): void
  uninstall?(store: BaseStore): void
}
```

### 2. 插件管理
```typescript
class PluginManager {
  private plugins: Map<string, Plugin>

  register(plugin: Plugin): void
  unregister(name: string): void
  install(store: BaseStore, name: string, options?: any): void
  uninstall(store: BaseStore, name: string): void
}
```

## 错误处理设计

### 1. 错误分类
- **配置错误**: Store 配置不正确
- **类型错误**: 类型不匹配
- **运行时错误**: 执行过程中的错误
- **性能警告**: 性能问题提醒

### 2. 错误处理策略
```typescript
class ErrorHandler {
  static handleConfigError(error: ConfigError): void
  static handleTypeError(error: TypeError): void
  static handleRuntimeError(error: RuntimeError): void
  static handlePerformanceWarning(warning: PerformanceWarning): void
}
```

## 性能监控设计

### 1. 监控指标
- Action 执行时间
- Getter 计算时间
- 缓存命中率
- 内存使用情况
- 状态更新频率

### 2. 监控实现
```typescript
class PerformanceMonitor {
  private metrics: Map<string, Metric>

  startTiming(key: string): void
  endTiming(key: string): number
  recordCacheHit(key: string): void
  recordCacheMiss(key: string): void
  getMetrics(): MetricsSummary
  getOptimizationSuggestions(): Suggestion[]
}
```

---

这个架构设计确保了 @ldesign/store 的可扩展性、可维护性和高性能，为用户提供了灵活而强大的状态管理解决方案。
