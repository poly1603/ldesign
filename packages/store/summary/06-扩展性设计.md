# @ldesign/store 扩展性设计

## 扩展性架构概述

@ldesign/store 从设计之初就考虑了扩展性，采用了多层次的扩展机制，确保库能够适应不同的使用场景和未来的发展需求。

## 核心扩展机制

### 1. 插件系统 (Plugin System)

#### 插件接口设计
```typescript
interface Plugin {
  name: string
  version?: string
  install(store: BaseStore, options?: any): void
  uninstall?(store: BaseStore): void
}

interface PluginWithHooks extends Plugin {
  beforeAction?(actionName: string, args: any[]): void
  afterAction?(actionName: string, result: any): void
  onStateChange?(mutation: any, state: any): void
  onError?(error: Error, context: string): void
}
```

#### 插件管理器
```typescript
class PluginManager {
  private plugins = new Map<string, Plugin>()
  private installedPlugins = new WeakMap<BaseStore, Set<string>>()

  register(plugin: Plugin): void {
    if (this.plugins.has(plugin.name)) {
      console.warn(`Plugin ${plugin.name} is already registered`)
      return
    }
    this.plugins.set(plugin.name, plugin)
  }

  install(store: BaseStore, pluginName: string, options?: any): void {
    const plugin = this.plugins.get(pluginName)
    if (!plugin) {
      throw new Error(`Plugin ${pluginName} not found`)
    }

    const installed = this.installedPlugins.get(store) || new Set()
    if (installed.has(pluginName)) {
      console.warn(`Plugin ${pluginName} is already installed on this store`)
      return
    }

    plugin.install(store, options)
    installed.add(pluginName)
    this.installedPlugins.set(store, installed)
  }

  uninstall(store: BaseStore, pluginName: string): void {
    const plugin = this.plugins.get(pluginName)
    const installed = this.installedPlugins.get(store)

    if (plugin?.uninstall && installed?.has(pluginName)) {
      plugin.uninstall(store)
      installed.delete(pluginName)
    }
  }
}
```

#### 内置插件示例
```typescript
// 日志插件
const LoggerPlugin: Plugin = {
  name: 'logger',
  version: '1.0.0',
  install(store: BaseStore, options = {}) {
    const { level = 'info', prefix = '[Store]' } = options

    store.$subscribe((mutation, state) => {
      if (level === 'debug' || level === 'info') {
        console.log(`${prefix} State changed:`, mutation, state)
      }
    })

    store.$onAction(({ name, args, after, onError }) => {
      const startTime = Date.now()

      if (level === 'debug') {
        console.log(`${prefix} Action ${name} called with:`, args)
      }

      after((result) => {
        const duration = Date.now() - startTime
        console.log(`${prefix} Action ${name} completed in ${duration}ms`)
      })

      onError((error) => {
        console.error(`${prefix} Action ${name} failed:`, error)
      })
    })
  }
}

// 性能监控插件
const PerformancePlugin: Plugin = {
  name: 'performance',
  install(store: BaseStore, options = {}) {
    const metrics = new Map<string, { count: number; totalTime: number }>()

    store.$onAction(({ name, after }) => {
      const startTime = performance.now()

      after(() => {
        const duration = performance.now() - startTime
        const metric = metrics.get(name) || { count: 0, totalTime: 0 }

        metric.count++
        metric.totalTime += duration
        metrics.set(name, metric)

        // 性能警告
        if (duration > 100) {
          console.warn(`Action ${name} took ${duration.toFixed(2)}ms`)
        }
      })
    })

    // 暴露性能数据
    ;(store as any).$getMetrics = () => {
      const result = new Map()
      for (const [name, metric] of metrics) {
        result.set(name, {
          ...metric,
          avgTime: metric.totalTime / metric.count
        })
      }
      return result
    }
  }
}
```

### 2. 钩子系统 (Hook System)

#### 生命周期钩子
```typescript
interface StoreHooks {
  beforeCreate?: (options: StoreOptions) => void
  created?: (store: BaseStore) => void
  beforeMount?: (store: BaseStore) => void
  mounted?: (store: BaseStore) => void
  beforeUpdate?: (mutation: any, state: any) => void
  updated?: (mutation: any, state: any) => void
  beforeDestroy?: (store: BaseStore) => void
  destroyed?: (store: BaseStore) => void
}

class HookManager {
  private hooks = new Map<string, Function[]>()

  on(hookName: string, callback: Function): () => void {
    const callbacks = this.hooks.get(hookName) || []
    callbacks.push(callback)
    this.hooks.set(hookName, callbacks)

    // 返回取消订阅函数
    return () => {
      const index = callbacks.indexOf(callback)
      if (index > -1) {
        callbacks.splice(index, 1)
      }
    }
  }

  emit(hookName: string, ...args: any[]): void {
    const callbacks = this.hooks.get(hookName) || []
    callbacks.forEach(callback => {
      try {
        callback(...args)
      } catch (error) {
        console.error(`Hook ${hookName} error:`, error)
      }
    })
  }

  off(hookName: string, callback?: Function): void {
    if (!callback) {
      this.hooks.delete(hookName)
      return
    }

    const callbacks = this.hooks.get(hookName) || []
    const index = callbacks.indexOf(callback)
    if (index > -1) {
      callbacks.splice(index, 1)
    }
  }
}
```

#### 动作钩子
```typescript
interface ActionHooks {
  beforeAction?: (name: string, args: any[]) => void | false
  afterAction?: (name: string, result: any) => void
  onActionError?: (name: string, error: Error) => void
}

// 在 BaseStore 中集成钩子
class BaseStore<TState, TActions, TGetters> {
  private hookManager = new HookManager()

  // 注册钩子
  onBeforeAction(callback: (name: string, args: any[]) => void | false): () => void {
    return this.hookManager.on('beforeAction', callback)
  }

  onAfterAction(callback: (name: string, result: any) => void): () => void {
    return this.hookManager.on('afterAction', callback)
  }

  onActionError(callback: (name: string, error: Error) => void): () => void {
    return this.hookManager.on('actionError', callback)
  }

  // 在动作执行时触发钩子
  private executeAction(name: string, action: Function, args: any[]): any {
    // 前置钩子
    const shouldContinue = this.hookManager.emit('beforeAction', name, args)
    if (shouldContinue === false) {
      return // 阻止执行
    }

    try {
      const result = action.apply(this, args)

      if (result instanceof Promise) {
        return result
          .then(value => {
            this.hookManager.emit('afterAction', name, value)
            return value
          })
          .catch(error => {
            this.hookManager.emit('actionError', name, error)
            throw error
          })
      } else {
        this.hookManager.emit('afterAction', name, result)
        return result
      }
    } catch (error) {
      this.hookManager.emit('actionError', name, error)
      throw error
    }
  }
}
```

### 3. 装饰器扩展系统

#### 自定义装饰器接口
```typescript
interface DecoratorFactory {
  name: string
  create(options?: any): MethodDecorator | PropertyDecorator
}

class DecoratorRegistry {
  private decorators = new Map<string, DecoratorFactory>()

  register(factory: DecoratorFactory): void {
    this.decorators.set(factory.name, factory)
  }

  get(name: string): DecoratorFactory | undefined {
    return this.decorators.get(name)
  }

  create(name: string, options?: any): any {
    const factory = this.decorators.get(name)
    if (!factory) {
      throw new Error(`Decorator ${name} not found`)
    }
    return factory.create(options)
  }
}
```

#### 自定义装饰器示例
```typescript
// 重试装饰器
const RetryDecoratorFactory: DecoratorFactory = {
  name: 'retry',
  create(options: { maxRetries?: number; delay?: number } = {}) {
    const { maxRetries = 3, delay = 1000 } = options

    return function (target: any, propertyKey: string, descriptor: PropertyDescriptor) {
      const originalMethod = descriptor.value

      descriptor.value = async function (...args: any[]) {
        let lastError: Error

        for (let i = 0; i <= maxRetries; i++) {
          try {
            return await originalMethod.apply(this, args)
          } catch (error) {
            lastError = error

            if (i < maxRetries) {
              await new Promise(resolve => setTimeout(resolve, delay * (i + 1)))
            }
          }
        }

        throw lastError
      }

      return descriptor
    }
  }
}

// 验证装饰器
const ValidateDecoratorFactory: DecoratorFactory = {
  name: 'validate',
  create(validator: (args: any[]) => boolean | string) {
    return function (target: any, propertyKey: string, descriptor: PropertyDescriptor) {
      const originalMethod = descriptor.value

      descriptor.value = function (...args: any[]) {
        const validationResult = validator(args)

        if (validationResult !== true) {
          const message = typeof validationResult === 'string'
            ? validationResult
            : `Validation failed for ${propertyKey}`
          throw new Error(message)
        }

        return originalMethod.apply(this, args)
      }

      return descriptor
    }
  }
}

// 使用自定义装饰器
const Retry = DecoratorRegistry.create('retry')
const Validate = DecoratorRegistry.create('validate')

class ApiStore extends BaseStore {
  @Action()
  @Retry({ maxRetries: 3, delay: 1000 })
  @Validate((args) => args[0] && typeof args[0] === 'string')
  async fetchData(url: string) {
    return await fetch(url).then(res => res.json())
  }
}
```

### 4. 中间件系统

#### 中间件接口
```typescript
interface Middleware {
  name: string
  process(context: MiddlewareContext, next: () => void): void
}

interface MiddlewareContext {
  store: BaseStore
  action: string
  args: any[]
  result?: any
  error?: Error
}

class MiddlewareManager {
  private middlewares: Middleware[] = []

  use(middleware: Middleware): void {
    this.middlewares.push(middleware)
  }

  async execute(context: MiddlewareContext): Promise<void> {
    let index = 0

    const next = async (): Promise<void> => {
      if (index >= this.middlewares.length) return

      const middleware = this.middlewares[index++]
      await middleware.process(context, next)
    }

    await next()
  }
}
```

#### 中间件示例
```typescript
// 日志中间件
const LoggingMiddleware: Middleware = {
  name: 'logging',
  process(context, next) {
    console.log(`[${context.store.$id}] Action ${context.action} started`)
    const startTime = Date.now()

    next()

    const duration = Date.now() - startTime
    console.log(`[${context.store.$id}] Action ${context.action} completed in ${duration}ms`)
  }
}

// 缓存中间件
const CachingMiddleware: Middleware = {
  name: 'caching',
  process(context, next) {
    const cacheKey = `${context.store.$id}:${context.action}:${JSON.stringify(context.args)}`
    const cached = context.store.$getCache?.(cacheKey)

    if (cached) {
      context.result = cached
      return
    }

    next()

    if (context.result && !context.error) {
      context.store.$setCache?.(cacheKey, context.result, 5000)
    }
  }
}
```

### 5. 类型扩展系统

#### 模块增强
```typescript
// 扩展 BaseStore 类型
declare module '@ldesign/store' {
  interface BaseStore<TState, TActions, TGetters> {
    // 添加自定义方法
    $customMethod(): void
    $getMetrics(): Map<string, any>
  }

  // 扩展装饰器
  interface DecoratorOptions {
    customOption?: boolean
  }
}

// 实现扩展
BaseStore.prototype.$customMethod = function () {
  console.log('Custom method called')
}
```

#### 泛型扩展
```typescript
// 扩展状态类型
interface ExtendedState<T = any> extends Record<string, any> {
  metadata?: {
    version: number
    lastUpdated: Date
    source: string
  }
  data: T
}

// 扩展 Store 选项
interface ExtendedStoreOptions<TState, TActions, TGetters> extends StoreOptions<TState, TActions, TGetters> {
  middleware?: Middleware[]
  plugins?: string[]
  hooks?: StoreHooks
}
```

## 实际扩展示例

### 1. 创建自定义 Store 类型
```typescript
// 创建带有 API 集成的 Store
class ApiStore<TState, TActions, TGetters> extends BaseStore<TState, TActions, TGetters> {
  private apiClient: ApiClient

  constructor(id: string, options: ExtendedStoreOptions<TState, TActions, TGetters>) {
    super(id, options)
    this.apiClient = new ApiClient(options.apiConfig)

    // 安装中间件
    options.middleware?.forEach(middleware => {
      this.use(middleware)
    })
  }

  // 扩展方法
  async $fetch<T>(endpoint: string, options?: RequestOptions): Promise<T> {
    return this.apiClient.request<T>(endpoint, options)
  }

  $batch(operations: BatchOperation[]): Promise<any[]> {
    return Promise.all(operations.map(op => this.$fetch(op.endpoint, op.options)))
  }
}

// 使用扩展的 Store
class UserApiStore extends ApiStore<UserState, UserActions, UserGetters> {
  constructor() {
    super('userApi', {
      state: () => ({ users: [], loading: false }),
      actions: {
        async fetchUsers() {
          this.loading = true
          try {
            this.users = await this.$fetch<User[]>('/users')
          } finally {
            this.loading = false
          }
        }
      },
      apiConfig: {
        baseURL: 'https://api.example.com',
        timeout: 5000
      },
      middleware: [LoggingMiddleware, CachingMiddleware]
    })
  }
}
```

### 2. 创建领域特定的装饰器
```typescript
// 权限检查装饰器
function RequirePermission(permission: string): MethodDecorator {
  return function (target: any, propertyKey: string, descriptor: PropertyDescriptor) {
    const originalMethod = descriptor.value

    descriptor.value = function (...args: any[]) {
      const authStore = useAuthStore()
      if (!authStore.hasPermission(permission)) {
        throw new Error(`Permission ${permission} required for ${propertyKey}`)
      }

      return originalMethod.apply(this, args)
    }

    return descriptor
  }
}

// 审计日志装饰器
function AuditLog(action: string): MethodDecorator {
  return function (target: any, propertyKey: string, descriptor: PropertyDescriptor) {
    const originalMethod = descriptor.value

    descriptor.value = function (...args: any[]) {
      const auditStore = useAuditStore()
      const startTime = Date.now()

      try {
        const result = originalMethod.apply(this, args)

        auditStore.log({
          action,
          method: propertyKey,
          args,
          duration: Date.now() - startTime,
          success: true
        })

        return result
      } catch (error) {
        auditStore.log({
          action,
          method: propertyKey,
          args,
          duration: Date.now() - startTime,
          success: false,
          error: error.message
        })

        throw error
      }
    }

    return descriptor
  }
}

// 使用领域装饰器
class AdminStore extends BaseStore {
  @Action()
  @RequirePermission('admin:users:delete')
  @AuditLog('DELETE_USER')
  async deleteUser(userId: string) {
    await api.deleteUser(userId)
    this.users = this.users.filter(u => u.id !== userId)
  }
}
```

## 扩展性最佳实践

### 1. 保持向后兼容
- 新功能通过可选参数添加
- 废弃功能提供迁移路径
- 版本化 API 设计

### 2. 文档化扩展点
- 清晰的扩展接口文档
- 完整的示例代码
- 最佳实践指南

### 3. 测试扩展功能
- 单元测试覆盖
- 集成测试验证
- 性能测试评估

### 4. 社区友好
- 开放的插件生态
- 贡献指南
- 代码审查流程

---

通过这些扩展机制，@ldesign/store 能够适应各种复杂的使用场景，同时保持核心的简洁性和性能优势。
