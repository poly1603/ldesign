<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>LDesign Editor - 性能测试</title>
  <style>
    /* 基础样式 */
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    body {
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      min-height: 100vh;
      padding: 20px;
    }

    .app-container {
      max-width: 1400px;
      margin: 0 auto;
      background: white;
      border-radius: 12px;
      box-shadow: 0 20px 40px rgba(0, 0, 0, 0.1);
      overflow: hidden;
    }

    .header {
      background: #722ED1;
      color: white;
      padding: 30px;
      text-align: center;
      position: relative;
    }

    .header::before {
      content: '⚡';
      position: absolute;
      top: 20px;
      right: 30px;
      font-size: 2rem;
      opacity: 0.7;
      animation: pulse 2s ease-in-out infinite;
    }

    @keyframes pulse {
      0%, 100% { transform: scale(1); opacity: 0.7; }
      50% { transform: scale(1.1); opacity: 1; }
    }

    .header h1 {
      font-size: 2.5rem;
      margin-bottom: 10px;
    }

    .header p {
      font-size: 1.1rem;
      opacity: 0.9;
    }

    .main-content {
      padding: 30px;
    }

    .performance-dashboard {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
      gap: 20px;
      margin-bottom: 30px;
    }

    .metric-card {
      background: #f8f9fa;
      border: 1px solid #e9ecef;
      border-radius: 8px;
      padding: 20px;
      text-align: center;
      transition: all 0.3s ease;
    }

    .metric-card:hover {
      transform: translateY(-3px);
      box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1);
    }

    .metric-value {
      font-size: 2rem;
      font-weight: bold;
      color: #722ED1;
      margin-bottom: 5px;
    }

    .metric-label {
      font-size: 0.9rem;
      color: #666;
      margin-bottom: 5px;
    }

    .metric-unit {
      font-size: 0.8rem;
      color: #999;
    }

    .test-controls {
      background: #f8f9fa;
      border-radius: 8px;
      padding: 20px;
      margin-bottom: 30px;
    }

    .test-controls h3 {
      margin-bottom: 15px;
      color: #333;
    }

    .control-group {
      display: flex;
      gap: 15px;
      align-items: center;
      margin-bottom: 15px;
      flex-wrap: wrap;
    }

    .btn {
      padding: 10px 20px;
      border: 1px solid #d9d9d9;
      border-radius: 6px;
      background: white;
      cursor: pointer;
      transition: all 0.2s ease;
      font-size: 0.9rem;
    }

    .btn:hover {
      background: #f0f0f0;
      border-color: #722ED1;
    }

    .btn.primary {
      background: #722ED1;
      color: white;
      border-color: #722ED1;
    }

    .btn.primary:hover {
      background: #5e2aa7;
    }

    .btn.danger {
      background: #dc3545;
      color: white;
      border-color: #dc3545;
    }

    .btn.danger:hover {
      background: #c82333;
    }

    .btn:disabled {
      opacity: 0.6;
      cursor: not-allowed;
    }

    .form-control {
      padding: 8px 12px;
      border: 1px solid #d9d9d9;
      border-radius: 4px;
      font-size: 0.9rem;
    }

    .editors-grid {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 30px;
      margin-bottom: 30px;
    }

    .editor-section {
      background: #f8f9fa;
      border-radius: 8px;
      padding: 20px;
      border: 1px solid #e9ecef;
    }

    .editor-section h3 {
      margin-bottom: 15px;
      color: #333;
      display: flex;
      align-items: center;
      gap: 8px;
    }

    .editor-container {
      border: 1px solid #d9d9d9;
      border-radius: 6px;
      min-height: 300px;
      background: white;
      padding: 15px;
      outline: none;
      margin-bottom: 15px;
      overflow-y: auto;
      max-height: 400px;
    }

    .editor-stats {
      display: grid;
      grid-template-columns: repeat(2, 1fr);
      gap: 10px;
      font-size: 0.85rem;
      color: #666;
    }

    .progress-bar {
      width: 100%;
      height: 8px;
      background: #e9ecef;
      border-radius: 4px;
      overflow: hidden;
      margin: 10px 0;
    }

    .progress-fill {
      height: 100%;
      background: linear-gradient(90deg, #722ED1, #8c5ad3);
      width: 0%;
      transition: width 0.3s ease;
    }

    .log-panel {
      background: #1a1a1a;
      color: #00ff00;
      border-radius: 8px;
      padding: 15px;
      font-family: 'Monaco', 'Menlo', monospace;
      font-size: 0.85rem;
      max-height: 200px;
      overflow-y: auto;
      margin-top: 20px;
    }

    .log-entry {
      margin-bottom: 5px;
      opacity: 0;
      animation: fadeInLog 0.3s ease forwards;
    }

    @keyframes fadeInLog {
      to { opacity: 1; }
    }

    .benchmark-results {
      background: #fff3cd;
      border: 1px solid #ffeaa7;
      border-radius: 8px;
      padding: 20px;
      margin-top: 20px;
    }

    .benchmark-results h4 {
      color: #856404;
      margin-bottom: 15px;
    }

    .benchmark-table {
      width: 100%;
      border-collapse: collapse;
      font-size: 0.9rem;
    }

    .benchmark-table th,
    .benchmark-table td {
      padding: 8px 12px;
      text-align: left;
      border-bottom: 1px solid #dee2e6;
    }

    .benchmark-table th {
      background: #f8f9fa;
      font-weight: 600;
      color: #495057;
    }

    .status-indicator {
      display: inline-block;
      width: 8px;
      height: 8px;
      border-radius: 50%;
      margin-right: 8px;
    }

    .status-running {
      background: #ffc107;
      animation: pulse 1s ease-in-out infinite;
    }

    .status-success {
      background: #28a745;
    }

    .status-error {
      background: #dc3545;
    }

    .status-idle {
      background: #6c757d;
    }

    @media (max-width: 768px) {
      .main-content {
        padding: 20px;
      }
      
      .header {
        padding: 20px;
      }
      
      .header h1 {
        font-size: 2rem;
      }
      
      .editors-grid {
        grid-template-columns: 1fr;
      }
      
      .performance-dashboard {
        grid-template-columns: repeat(2, 1fr);
      }
      
      .control-group {
        flex-direction: column;
        align-items: stretch;
      }
    }
  </style>
</head>
<body>
  <div class="app-container">
    <div class="header">
      <h1>LDesign Editor</h1>
      <p>性能测试与基准测试 - 编辑器性能分析工具</p>
    </div>

    <div class="main-content">
      <!-- 性能仪表板 -->
      <div class="performance-dashboard">
        <div class="metric-card">
          <div class="metric-value" id="fpsValue">60</div>
          <div class="metric-label">帧率 (FPS)</div>
          <div class="metric-unit">frames/sec</div>
        </div>

        <div class="metric-card">
          <div class="metric-value" id="memoryValue">0</div>
          <div class="metric-label">内存使用</div>
          <div class="metric-unit">MB</div>
        </div>

        <div class="metric-card">
          <div class="metric-value" id="renderTime">0</div>
          <div class="metric-label">渲染时间</div>
          <div class="metric-unit">ms</div>
        </div>

        <div class="metric-card">
          <div class="metric-value" id="inputLatency">0</div>
          <div class="metric-label">输入延迟</div>
          <div class="metric-unit">ms</div>
        </div>

        <div class="metric-card">
          <div class="metric-value" id="domNodes">0</div>
          <div class="metric-label">DOM 节点</div>
          <div class="metric-unit">nodes</div>
        </div>

        <div class="metric-card">
          <div class="metric-value" id="contentSize">0</div>
          <div class="metric-label">内容大小</div>
          <div class="metric-unit">KB</div>
        </div>
      </div>

      <!-- 测试控制面板 -->
      <div class="test-controls">
        <h3>🧪 性能测试控制</h3>

        <div class="control-group">
          <label>测试类型:</label>
          <select id="testType" class="form-control" style="width: 200px;">
            <option value="typing">打字性能测试</option>
            <option value="content">大内容加载测试</option>
            <option value="formatting">格式化性能测试</option>
            <option value="memory">内存泄漏测试</option>
            <option value="stress">压力测试</option>
          </select>

          <label>测试强度:</label>
          <select id="testIntensity" class="form-control" style="width: 150px;">
            <option value="light">轻度</option>
            <option value="medium">中度</option>
            <option value="heavy">重度</option>
            <option value="extreme">极限</option>
          </select>
        </div>

        <div class="control-group">
          <button class="btn primary" onclick="startPerformanceTest()">
            <span class="status-indicator status-idle"></span>
            开始测试
          </button>
          <button class="btn danger" onclick="stopPerformanceTest()" disabled>
            停止测试
          </button>
          <button class="btn" onclick="clearResults()">清空结果</button>
          <button class="btn" onclick="exportResults()">导出报告</button>
        </div>

        <div class="progress-bar">
          <div class="progress-fill" id="testProgress"></div>
        </div>
        <div style="text-align: center; margin-top: 10px; font-size: 0.9rem; color: #666;">
          <span id="testStatus">就绪</span>
        </div>
      </div>

      <!-- 编辑器测试区域 -->
      <div class="editors-grid">
        <div class="editor-section">
          <h3>📝 测试编辑器 A</h3>
          <div id="editorA" class="editor-container" contenteditable="true">
            <h2>性能测试编辑器 A</h2>
            <p>这是用于性能测试的编辑器。在这里输入内容来测试编辑器的响应性能。</p>
            <ul>
              <li>实时性能监控</li>
              <li>输入延迟测量</li>
              <li>渲染性能分析</li>
            </ul>
            <p>开始输入内容，观察右侧的性能指标变化...</p>
          </div>

          <div class="editor-stats">
            <div>字符数: <span id="editorAChars">0</span></div>
            <div>DOM节点: <span id="editorANodes">0</span></div>
            <div>最后更新: <span id="editorAUpdate">-</span></div>
            <div>输入频率: <span id="editorAFreq">0</span> 次/秒</div>
          </div>
        </div>

        <div class="editor-section">
          <h3>📊 测试编辑器 B</h3>
          <div id="editorB" class="editor-container" contenteditable="true">
            <h2>性能测试编辑器 B</h2>
            <p>这是第二个测试编辑器，用于对比测试。</p>
            <blockquote>
              通过对比两个编辑器的性能表现，可以更好地分析性能瓶颈。
            </blockquote>
            <p>在两个编辑器中同时输入内容，比较性能差异...</p>
          </div>

          <div class="editor-stats">
            <div>字符数: <span id="editorBChars">0</span></div>
            <div>DOM节点: <span id="editorBNodes">0</span></div>
            <div>最后更新: <span id="editorBUpdate">-</span></div>
            <div>输入频率: <span id="editorBFreq">0</span> 次/秒</div>
          </div>
        </div>
      </div>

      <!-- 基准测试结果 -->
      <div class="benchmark-results" id="benchmarkResults" style="display: none;">
        <h4>📈 基准测试结果</h4>
        <table class="benchmark-table">
          <thead>
            <tr>
              <th>测试项目</th>
              <th>编辑器 A</th>
              <th>编辑器 B</th>
              <th>差异</th>
              <th>评级</th>
            </tr>
          </thead>
          <tbody id="benchmarkTableBody">
            <!-- 动态生成 -->
          </tbody>
        </table>
      </div>

      <!-- 实时日志 -->
      <div class="log-panel" id="logPanel">
        <div class="log-entry">[系统] 性能监控系统已启动</div>
        <div class="log-entry">[信息] 等待开始性能测试...</div>
      </div>
    </div>
  </div>

  <script>
    // 性能监控类
    class PerformanceMonitor {
      constructor() {
        this.isRunning = false;
        this.startTime = 0;
        this.frameCount = 0;
        this.lastFrameTime = 0;
        this.fps = 60;
        this.metrics = {
          renderTime: 0,
          inputLatency: 0,
          memoryUsage: 0,
          domNodes: 0,
          contentSize: 0
        };
        this.inputTimes = [];
        this.renderTimes = [];
        this.testResults = [];

        this.initMonitoring();
      }

      initMonitoring() {
        // FPS 监控
        this.monitorFPS();

        // 内存监控
        this.monitorMemory();

        // DOM 监控
        this.monitorDOM();

        // 输入延迟监控
        this.monitorInputLatency();
      }

      monitorFPS() {
        const measureFPS = (timestamp) => {
          if (this.lastFrameTime === 0) {
            this.lastFrameTime = timestamp;
          }

          const delta = timestamp - this.lastFrameTime;
          this.fps = Math.round(1000 / delta);
          this.lastFrameTime = timestamp;

          document.getElementById('fpsValue').textContent = this.fps;

          if (this.isRunning) {
            requestAnimationFrame(measureFPS);
          }
        };

        requestAnimationFrame(measureFPS);
      }

      monitorMemory() {
        if (performance.memory) {
          setInterval(() => {
            const memory = performance.memory;
            const usedMB = Math.round(memory.usedJSHeapSize / 1024 / 1024);
            this.metrics.memoryUsage = usedMB;
            document.getElementById('memoryValue').textContent = usedMB;
          }, 1000);
        }
      }

      monitorDOM() {
        setInterval(() => {
          const nodeCount = document.querySelectorAll('*').length;
          this.metrics.domNodes = nodeCount;
          document.getElementById('domNodes').textContent = nodeCount;
        }, 2000);
      }

      monitorInputLatency() {
        ['editorA', 'editorB'].forEach(editorId => {
          const editor = document.getElementById(editorId);
          let inputStartTime = 0;

          editor.addEventListener('keydown', () => {
            inputStartTime = performance.now();
          });

          editor.addEventListener('input', () => {
            if (inputStartTime > 0) {
              const latency = performance.now() - inputStartTime;
              this.inputTimes.push(latency);

              // 保持最近100次的记录
              if (this.inputTimes.length > 100) {
                this.inputTimes.shift();
              }

              const avgLatency = this.inputTimes.reduce((a, b) => a + b, 0) / this.inputTimes.length;
              this.metrics.inputLatency = Math.round(avgLatency);
              document.getElementById('inputLatency').textContent = this.metrics.inputLatency;

              inputStartTime = 0;
            }
          });
        });
      }

      measureRenderTime(callback) {
        const startTime = performance.now();

        requestAnimationFrame(() => {
          const endTime = performance.now();
          const renderTime = endTime - startTime;
          this.renderTimes.push(renderTime);

          if (this.renderTimes.length > 50) {
            this.renderTimes.shift();
          }

          const avgRenderTime = this.renderTimes.reduce((a, b) => a + b, 0) / this.renderTimes.length;
          this.metrics.renderTime = Math.round(avgRenderTime * 100) / 100;
          document.getElementById('renderTime').textContent = this.metrics.renderTime;

          if (callback) callback();
        });
      }

      start() {
        this.isRunning = true;
        this.startTime = performance.now();
        this.frameCount = 0;
        this.log('性能监控已启动');
      }

      stop() {
        this.isRunning = false;
        this.log('性能监控已停止');
      }

      log(message, type = 'info') {
        const logPanel = document.getElementById('logPanel');
        const timestamp = new Date().toLocaleTimeString();
        const logEntry = document.createElement('div');
        logEntry.className = 'log-entry';

        const typePrefix = {
          info: '[信息]',
          warning: '[警告]',
          error: '[错误]',
          success: '[成功]'
        };

        logEntry.textContent = `${timestamp} ${typePrefix[type]} ${message}`;
        logPanel.appendChild(logEntry);
        logPanel.scrollTop = logPanel.scrollHeight;

        // 限制日志条数
        const entries = logPanel.querySelectorAll('.log-entry');
        if (entries.length > 100) {
          entries[0].remove();
        }
      }

      getMetrics() {
        return {
          ...this.metrics,
          fps: this.fps,
          avgInputLatency: this.inputTimes.length > 0
            ? this.inputTimes.reduce((a, b) => a + b, 0) / this.inputTimes.length
            : 0,
          avgRenderTime: this.renderTimes.length > 0
            ? this.renderTimes.reduce((a, b) => a + b, 0) / this.renderTimes.length
            : 0
        };
      }
    }

    // 性能测试类
    class PerformanceTest {
      constructor(monitor) {
        this.monitor = monitor;
        this.isRunning = false;
        this.currentTest = null;
        this.testProgress = 0;
        this.testResults = [];
      }

      async startTest(testType, intensity) {
        if (this.isRunning) return;

        this.isRunning = true;
        this.currentTest = testType;
        this.testProgress = 0;

        this.updateUI('running');
        this.monitor.log(`开始 ${testType} 测试 (强度: ${intensity})`);

        try {
          switch (testType) {
            case 'typing':
              await this.runTypingTest(intensity);
              break;
            case 'content':
              await this.runContentTest(intensity);
              break;
            case 'formatting':
              await this.runFormattingTest(intensity);
              break;
            case 'memory':
              await this.runMemoryTest(intensity);
              break;
            case 'stress':
              await this.runStressTest(intensity);
              break;
          }

          this.monitor.log(`${testType} 测试完成`, 'success');
          this.updateUI('success');
        } catch (error) {
          this.monitor.log(`测试失败: ${error.message}`, 'error');
          this.updateUI('error');
        } finally {
          this.isRunning = false;
        }
      }

      async runTypingTest(intensity) {
        const iterations = { light: 100, medium: 500, heavy: 1000, extreme: 2000 }[intensity];
        const editorA = document.getElementById('editorA');
        const editorB = document.getElementById('editorB');

        const testText = 'The quick brown fox jumps over the lazy dog. ';

        for (let i = 0; i < iterations; i++) {
          // 模拟打字
          const char = testText[i % testText.length];

          // 在编辑器A中插入字符
          this.insertCharacter(editorA, char);

          // 在编辑器B中插入字符
          this.insertCharacter(editorB, char);

          // 更新进度
          this.testProgress = (i / iterations) * 100;
          this.updateProgress();

          // 测量渲染时间
          await new Promise(resolve => {
            this.monitor.measureRenderTime(resolve);
          });

          // 控制测试速度
          if (intensity !== 'extreme') {
            await this.delay(10);
          }
        }
      }

      async runContentTest(intensity) {
        const sizes = { light: 1000, medium: 5000, heavy: 10000, extreme: 20000 }[intensity];
        const editorA = document.getElementById('editorA');

        this.monitor.log(`生成 ${sizes} 字符的大内容`);

        let content = '<h1>大内容测试</h1>';
        for (let i = 0; i < sizes / 100; i++) {
          content += `<p>这是第 ${i + 1} 段测试内容。`.repeat(10) + '</p>';

          if (i % 10 === 0) {
            content += '<ul>';
            for (let j = 0; j < 5; j++) {
              content += `<li>列表项 ${j + 1}</li>`;
            }
            content += '</ul>';
          }

          // 更新进度
          this.testProgress = (i / (sizes / 100)) * 100;
          this.updateProgress();

          await this.delay(1);
        }

        // 一次性插入大内容
        const startTime = performance.now();
        editorA.innerHTML = content;
        const endTime = performance.now();

        this.monitor.log(`大内容加载耗时: ${(endTime - startTime).toFixed(2)}ms`);

        // 更新内容大小统计
        const contentSize = Math.round(new Blob([content]).size / 1024);
        document.getElementById('contentSize').textContent = contentSize;
      }

      async runFormattingTest(intensity) {
        const iterations = { light: 50, medium: 200, heavy: 500, extreme: 1000 }[intensity];
        const editorA = document.getElementById('editorA');

        const commands = ['bold', 'italic', 'underline', 'heading1', 'heading2', 'bulletList'];

        for (let i = 0; i < iterations; i++) {
          const command = commands[i % commands.length];

          // 选择一些文本
          this.selectRandomText(editorA);

          // 执行格式化命令
          const startTime = performance.now();
          document.execCommand(command, false, null);
          const endTime = performance.now();

          this.monitor.log(`格式化命令 ${command} 耗时: ${(endTime - startTime).toFixed(2)}ms`);

          // 更新进度
          this.testProgress = (i / iterations) * 100;
          this.updateProgress();

          await this.delay(50);
        }
      }

      async runMemoryTest(intensity) {
        const iterations = { light: 10, medium: 50, heavy: 100, extreme: 200 }[intensity];
        const editorA = document.getElementById('editorA');

        const initialMemory = performance.memory ? performance.memory.usedJSHeapSize : 0;

        for (let i = 0; i < iterations; i++) {
          // 创建大量DOM节点
          const content = '<div>'.repeat(100) + '内容'.repeat(100) + '</div>'.repeat(100);
          editorA.innerHTML += content;

          // 强制垃圾回收（如果可用）
          if (window.gc) {
            window.gc();
          }

          // 更新进度
          this.testProgress = (i / iterations) * 100;
          this.updateProgress();

          await this.delay(100);
        }

        const finalMemory = performance.memory ? performance.memory.usedJSHeapSize : 0;
        const memoryIncrease = Math.round((finalMemory - initialMemory) / 1024 / 1024);

        this.monitor.log(`内存增长: ${memoryIncrease}MB`, memoryIncrease > 50 ? 'warning' : 'info');
      }

      async runStressTest(intensity) {
        this.monitor.log('开始压力测试 - 综合所有测试项目');

        // 依次运行所有测试
        await this.runTypingTest(intensity);
        await this.runContentTest(intensity);
        await this.runFormattingTest(intensity);
        await this.runMemoryTest(intensity);

        this.monitor.log('压力测试完成', 'success');
      }

      insertCharacter(editor, char) {
        const selection = window.getSelection();
        const range = document.createRange();

        // 将光标移到编辑器末尾
        range.selectNodeContents(editor);
        range.collapse(false);
        selection.removeAllRanges();
        selection.addRange(range);

        // 插入字符
        document.execCommand('insertText', false, char);
      }

      selectRandomText(editor) {
        const textNodes = this.getTextNodes(editor);
        if (textNodes.length === 0) return;

        const randomNode = textNodes[Math.floor(Math.random() * textNodes.length)];
        const text = randomNode.textContent;
        const startOffset = Math.floor(Math.random() * text.length);
        const endOffset = Math.min(startOffset + Math.floor(Math.random() * 10) + 1, text.length);

        const selection = window.getSelection();
        const range = document.createRange();
        range.setStart(randomNode, startOffset);
        range.setEnd(randomNode, endOffset);
        selection.removeAllRanges();
        selection.addRange(range);
      }

      getTextNodes(element) {
        const textNodes = [];
        const walker = document.createTreeWalker(
          element,
          NodeFilter.SHOW_TEXT,
          null,
          false
        );

        let node;
        while (node = walker.nextNode()) {
          if (node.textContent.trim().length > 0) {
            textNodes.push(node);
          }
        }

        return textNodes;
      }

      delay(ms) {
        return new Promise(resolve => setTimeout(resolve, ms));
      }

      updateProgress() {
        const progressFill = document.getElementById('testProgress');
        progressFill.style.width = `${this.testProgress}%`;

        const status = document.getElementById('testStatus');
        status.textContent = `测试进行中... ${Math.round(this.testProgress)}%`;
      }

      updateUI(state) {
        const startBtn = document.querySelector('.btn.primary');
        const stopBtn = document.querySelector('.btn.danger');
        const statusIndicator = startBtn.querySelector('.status-indicator');
        const status = document.getElementById('testStatus');

        switch (state) {
          case 'running':
            startBtn.disabled = true;
            stopBtn.disabled = false;
            statusIndicator.className = 'status-indicator status-running';
            status.textContent = '测试运行中...';
            break;
          case 'success':
            startBtn.disabled = false;
            stopBtn.disabled = true;
            statusIndicator.className = 'status-indicator status-success';
            status.textContent = '测试完成';
            this.showBenchmarkResults();
            break;
          case 'error':
            startBtn.disabled = false;
            stopBtn.disabled = true;
            statusIndicator.className = 'status-indicator status-error';
            status.textContent = '测试失败';
            break;
          default:
            startBtn.disabled = false;
            stopBtn.disabled = true;
            statusIndicator.className = 'status-indicator status-idle';
            status.textContent = '就绪';
        }
      }

      showBenchmarkResults() {
        const resultsPanel = document.getElementById('benchmarkResults');
        const tableBody = document.getElementById('benchmarkTableBody');

        const metrics = this.monitor.getMetrics();
        const results = [
          { name: '平均FPS', valueA: metrics.fps, valueB: metrics.fps, unit: 'fps' },
          { name: '渲染时间', valueA: metrics.avgRenderTime, valueB: metrics.avgRenderTime, unit: 'ms' },
          { name: '输入延迟', valueA: metrics.avgInputLatency, valueB: metrics.avgInputLatency, unit: 'ms' },
          { name: '内存使用', valueA: metrics.memoryUsage, valueB: metrics.memoryUsage, unit: 'MB' },
          { name: 'DOM节点', valueA: metrics.domNodes, valueB: metrics.domNodes, unit: 'nodes' }
        ];

        tableBody.innerHTML = results.map(result => {
          const diff = Math.abs(result.valueA - result.valueB);
          const rating = this.getRating(result.name, result.valueA);

          return `
            <tr>
              <td>${result.name}</td>
              <td>${result.valueA.toFixed(2)} ${result.unit}</td>
              <td>${result.valueB.toFixed(2)} ${result.unit}</td>
              <td>${diff.toFixed(2)} ${result.unit}</td>
              <td>${rating}</td>
            </tr>
          `;
        }).join('');

        resultsPanel.style.display = 'block';
      }

      getRating(metricName, value) {
        const ratings = {
          '平均FPS': value >= 55 ? '优秀' : value >= 30 ? '良好' : '需优化',
          '渲染时间': value <= 16 ? '优秀' : value <= 33 ? '良好' : '需优化',
          '输入延迟': value <= 50 ? '优秀' : value <= 100 ? '良好' : '需优化',
          '内存使用': value <= 100 ? '优秀' : value <= 200 ? '良好' : '需优化',
          'DOM节点': value <= 1000 ? '优秀' : value <= 2000 ? '良好' : '需优化'
        };

        return ratings[metricName] || '未知';
      }

      stop() {
        this.isRunning = false;
        this.updateUI('idle');
        this.monitor.log('测试已停止');
      }
    }

    // 全局变量
    let performanceMonitor;
    let performanceTest;

    // 初始化
    document.addEventListener('DOMContentLoaded', function() {
      performanceMonitor = new PerformanceMonitor();
      performanceTest = new PerformanceTest(performanceMonitor);

      performanceMonitor.start();

      // 初始化编辑器统计
      initEditorStats();

      performanceMonitor.log('性能测试系统初始化完成', 'success');
    });

    // 编辑器统计初始化
    function initEditorStats() {
      ['A', 'B'].forEach(suffix => {
        const editor = document.getElementById(`editor${suffix}`);
        let inputCount = 0;
        let lastInputTime = Date.now();

        editor.addEventListener('input', function() {
          const now = Date.now();
          inputCount++;

          // 更新字符数
          const charCount = editor.textContent.length;
          document.getElementById(`editor${suffix}Chars`).textContent = charCount;

          // 更新DOM节点数
          const nodeCount = editor.querySelectorAll('*').length;
          document.getElementById(`editor${suffix}Nodes`).textContent = nodeCount;

          // 更新最后更新时间
          document.getElementById(`editor${suffix}Update`).textContent = new Date().toLocaleTimeString();

          // 计算输入频率
          if (now - lastInputTime >= 1000) {
            document.getElementById(`editor${suffix}Freq`).textContent = inputCount;
            inputCount = 0;
            lastInputTime = now;
          }

          // 更新内容大小
          const contentSize = Math.round(new Blob([editor.innerHTML]).size / 1024);
          document.getElementById('contentSize').textContent = contentSize;
        });
      });
    }

    // 全局函数
    function startPerformanceTest() {
      const testType = document.getElementById('testType').value;
      const intensity = document.getElementById('testIntensity').value;

      performanceTest.startTest(testType, intensity);
    }

    function stopPerformanceTest() {
      performanceTest.stop();
    }

    function clearResults() {
      document.getElementById('benchmarkResults').style.display = 'none';
      document.getElementById('logPanel').innerHTML = '<div class="log-entry">[系统] 结果已清空</div>';

      // 重置编辑器内容
      document.getElementById('editorA').innerHTML = '<h2>性能测试编辑器 A</h2><p>内容已重置</p>';
      document.getElementById('editorB').innerHTML = '<h2>性能测试编辑器 B</h2><p>内容已重置</p>';

      performanceMonitor.log('测试结果已清空');
    }

    function exportResults() {
      const metrics = performanceMonitor.getMetrics();
      const report = {
        timestamp: new Date().toISOString(),
        metrics: metrics,
        testType: document.getElementById('testType').value,
        intensity: document.getElementById('testIntensity').value,
        userAgent: navigator.userAgent,
        viewport: {
          width: window.innerWidth,
          height: window.innerHeight
        }
      };

      const blob = new Blob([JSON.stringify(report, null, 2)], { type: 'application/json' });
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      a.download = `performance-report-${Date.now()}.json`;
      a.click();
      URL.revokeObjectURL(url);

      performanceMonitor.log('性能报告已导出', 'success');
    }
  </script>
</body>
</html>
