{
  "timestamp": "2025-09-24T02:40:34.185Z",
  "analysis": {
    "main": {
      "size": 2055,
      "gzipSize": 904,
      "compressionRatio": "56.0",
      "imports": 2,
      "exports": 11,
      "reExports": 7,
      "functions": 1,
      "classes": 0,
      "interfaces": 0,
      "content": "/**\r\n * @ldesign/engine - Vue3应用引擎\r\n *\r\n * 🚀 一个强大的Vue3应用引擎，提供插件系统、中间件支持、全局管理等核心功能\r\n *\r\n * @example\r\n * ```typescript\r\n * import { createEngine } from '@ldesign/engine'\r\n *\r\n * const engine = createEngine({\r\n *   config: {\r\n *     app: { name: 'My App', version: '1.0.0' },\r\n *     debug: true\r\n *   }\r\n * })\r\n *\r\n * engine.createApp(App).mount('#app')\r\n * ```\r\n *\r\n * @example 按需导入\r\n * ```typescript\r\n * // 只导入核心功能\r\n * import { createEngine } from '@ldesign/engine/core'\r\n *\r\n * // 只导入管理器\r\n * import { createCacheManager } from '@ldesign/engine/managers'\r\n *\r\n * // 只导入工具函数\r\n * import { debounce, throttle } from '@ldesign/engine/utils'\r\n *\r\n * // 只导入Vue集成\r\n * import { useEngine } from '@ldesign/engine/vue'\r\n * ```\r\n */\r\n\r\nimport type { App } from 'vue'\r\nimport type { CreateEngineOptions, Engine } from './types'\r\n\r\n// 核心功能 - 最常用的导出\r\nexport { createEngine, createApp, createAndMountApp } from './core/factory'\r\nexport { EngineImpl } from './core/engine'\r\n\r\n// 基础管理器 - 最常用的管理器\r\nexport { createConfigManager } from './config/config-manager'\r\nexport { createEventManager, ENGINE_EVENTS } from './events/event-manager'\r\nexport { createLogger } from './logger/logger'\r\n\r\n// 常用工具函数\r\nexport { debounce, throttle, deepClone, generateId } from './utils/index'\r\n\r\n// Vue集成 - 最常用的Vue功能\r\nexport { useEngine } from './vue/composables/useEngine'\r\n\r\n// 常量\r\nexport * from './constants'\r\n\r\n// 基础类型导出\r\nexport type {\r\n  Engine,\r\n  EngineConfig,\r\n  CreateEngineOptions,\r\n  ConfigManager,\r\n  EventManager,\r\n} from './types'\r\n\r\n// 版本信息\r\nexport const version = '0.1.0'\r\n\r\nexport async function install(app: App, options: CreateEngineOptions = {}): Promise<Engine> {\r\n  // 动态导入避免循环依赖\r\n  const { createEngine } = await import('./core/factory')\r\n  const engine = createEngine(options)\r\n  engine.install(app)\r\n  return engine\r\n}\r\n"
    },
    "core": {
      "size": 1704,
      "gzipSize": 751,
      "compressionRatio": "55.9",
      "imports": 0,
      "exports": 14,
      "reExports": 11,
      "functions": 0,
      "classes": 0,
      "interfaces": 0,
      "content": "/**\r\n * @ldesign/engine - 核心导出\r\n *\r\n * 精简版导出，只包含最常用的核心功能。\r\n * 重量级模块请通过子路径按需引入：\r\n * - @ldesign/engine/notifications\r\n * - @ldesign/engine/dialog\r\n * - @ldesign/engine/performance\r\n * - @ldesign/engine/logging\r\n * - @ldesign/engine/config\r\n * - @ldesign/engine/cache\r\n */\r\n\r\n// 基础管理器（精简导出）\r\nexport { createConfigManager } from './config/config-manager'\r\n// 核心引擎\r\nexport { EngineImpl } from './core/engine'\r\n\r\nexport { createAndMountApp, createApp, createEngine } from './core/factory'\r\nexport { createDirectiveManager } from './directives/directive-manager'\r\nexport { createErrorManager } from './errors/error-manager'\r\nexport { createEventManager, ENGINE_EVENTS } from './events/event-manager'\r\nexport { createLogger } from './logger/logger'\r\nexport { createMiddlewareManager } from './middleware/middleware-manager'\r\nexport { createPluginManager } from './plugins/plugin-manager'\r\nexport { createStateManager } from './state/state-manager'\r\n\r\n// 类型导出（不占体积）\r\nexport type {\r\n  ConfigManager,\r\n  CreateEngineOptions,\r\n  DirectiveManager,\r\n  Engine,\r\n  EngineConfig,\r\n  ErrorManager,\r\n  EventManager,\r\n  EventMap,\r\n  Logger,\r\n  LogLevel,\r\n  Middleware,\r\n  MiddlewareContext,\r\n  MiddlewareManager,\r\n  Plugin,\r\n  PluginContext,\r\n  PluginManager,\r\n  StateManager,\r\n} from './types'\r\n\r\n// 工具函数（精简版）\r\nexport {\r\n  isArray,\r\n  isBoolean,\r\n  isFunction,\r\n  isNumber,\r\n  isPromise,\r\n  isString,\r\n  isValidObject,\r\n  safeDeepClone,\r\n  safeMerge,\r\n} from './utils/type-safety'\r\n\r\n// Vue集成\r\nexport * from './vue'\r\n\r\n// 版本信息\r\nexport const version = '1.0.0-alpha.1'\n"
    },
    "lib": {
      "size": 25,
      "gzipSize": 45,
      "compressionRatio": "-80.0",
      "imports": 0,
      "exports": 1,
      "reExports": 0,
      "functions": 0,
      "classes": 0,
      "interfaces": 0,
      "content": "export * from './index'\r\n"
    },
    "esm": {
      "size": 1352,
      "gzipSize": 637,
      "compressionRatio": "52.9",
      "imports": 0,
      "exports": 9,
      "reExports": 8,
      "functions": 1,
      "classes": 0,
      "interfaces": 0,
      "content": "/*!\n * ***********************************\n * @ldesign/engine v0.1.0          *\n * Built with rollup               *\n * Build time: 2024-09-24 10:39:17 *\n * Build mode: production          *\n * Minified: No                    *\n * ***********************************\n */\nexport { createAndMountApp, createApp, createEngine } from './core/factory.js';\nexport { EngineImpl } from './core/engine.js';\nexport { createConfigManager } from './config/config-manager.js';\nexport { ENGINE_EVENTS, createEventManager } from './events/event-manager.js';\nexport { createLogger } from './logger/logger.js';\nexport { debounce, deepClone, generateId, throttle } from './utils/index.js';\nexport { useEngine } from './vue/composables/useEngine.js';\nexport { CACHE_STRATEGIES, DEFAULT_CONFIG, ENVIRONMENTS, ERROR_CODES, EVENTS, FEATURE_FLAGS, LIMITS, LOG_LEVELS, NOTIFICATION_ANIMATIONS, NOTIFICATION_POSITIONS, NOTIFICATION_THEMES, NOTIFICATION_TYPES, PERFORMANCE_CONSTANTS, PERFORMANCE_THRESHOLDS, SECURITY_CONFIG, STORAGE_KEYS, TIME, VERSION } from './constants/index.js';\n\nconst version = \"0.1.0\";\nasync function install(app, options = {}) {\n  const { createEngine: createEngine2 } = await import('./core/factory.js');\n  const engine = createEngine2(options);\n  engine.install(app);\n  return engine;\n}\n\nexport { install, version };\n//# sourceMappingURL=index.js.map\n"
    },
    "cjs": {
      "size": 2526,
      "gzipSize": 829,
      "compressionRatio": "67.2",
      "imports": 0,
      "exports": 0,
      "reExports": 0,
      "functions": 1,
      "classes": 0,
      "interfaces": 0,
      "content": "/*!\n * ***********************************\n * @ldesign/engine v0.1.0          *\n * Built with rollup               *\n * Build time: 2024-09-24 10:39:19 *\n * Build mode: production          *\n * Minified: No                    *\n * ***********************************\n */\n'use strict';\n\nvar factory = require('./core/factory.cjs');\nvar engine = require('./core/engine.cjs');\nvar configManager = require('./config/config-manager.cjs');\nvar eventManager = require('./events/event-manager.cjs');\nvar logger = require('./logger/logger.cjs');\nvar index = require('./utils/index.cjs');\nvar useEngine = require('./vue/composables/useEngine.cjs');\nvar index$1 = require('./constants/index.cjs');\n\nconst version = \"0.1.0\";\nasync function install(app, options = {}) {\n  const { createEngine: createEngine2 } = await Promise.resolve().then(function () { return require('./core/factory.cjs'); });\n  const engine = createEngine2(options);\n  engine.install(app);\n  return engine;\n}\n\nexports.createAndMountApp = factory.createAndMountApp;\nexports.createApp = factory.createApp;\nexports.createEngine = factory.createEngine;\nexports.EngineImpl = engine.EngineImpl;\nexports.createConfigManager = configManager.createConfigManager;\nexports.ENGINE_EVENTS = eventManager.ENGINE_EVENTS;\nexports.createEventManager = eventManager.createEventManager;\nexports.createLogger = logger.createLogger;\nexports.debounce = index.debounce;\nexports.deepClone = index.deepClone;\nexports.generateId = index.generateId;\nexports.throttle = index.throttle;\nexports.useEngine = useEngine.useEngine;\nexports.CACHE_STRATEGIES = index$1.CACHE_STRATEGIES;\nexports.DEFAULT_CONFIG = index$1.DEFAULT_CONFIG;\nexports.ENVIRONMENTS = index$1.ENVIRONMENTS;\nexports.ERROR_CODES = index$1.ERROR_CODES;\nexports.EVENTS = index$1.EVENTS;\nexports.FEATURE_FLAGS = index$1.FEATURE_FLAGS;\nexports.LIMITS = index$1.LIMITS;\nexports.LOG_LEVELS = index$1.LOG_LEVELS;\nexports.NOTIFICATION_ANIMATIONS = index$1.NOTIFICATION_ANIMATIONS;\nexports.NOTIFICATION_POSITIONS = index$1.NOTIFICATION_POSITIONS;\nexports.NOTIFICATION_THEMES = index$1.NOTIFICATION_THEMES;\nexports.NOTIFICATION_TYPES = index$1.NOTIFICATION_TYPES;\nexports.PERFORMANCE_CONSTANTS = index$1.PERFORMANCE_CONSTANTS;\nexports.PERFORMANCE_THRESHOLDS = index$1.PERFORMANCE_THRESHOLDS;\nexports.SECURITY_CONFIG = index$1.SECURITY_CONFIG;\nexports.STORAGE_KEYS = index$1.STORAGE_KEYS;\nexports.TIME = index$1.TIME;\nexports.VERSION = index$1.VERSION;\nexports.install = install;\nexports.version = version;\n//# sourceMappingURL=index.cjs.map\n"
    },
    "umd": {
      "size": 279269,
      "gzipSize": 56679,
      "compressionRatio": "79.7",
      "imports": 0,
      "exports": 0,
      "reExports": 0,
      "functions": 39,
      "classes": 40,
      "interfaces": 0,
      "content": "/*!\n * ***********************************\n * @ldesign/engine v0.1.0          *\n * Built with rollup               *\n * Build time: 2024-09-24 10:39:19 *\n * Build mode: production          *\n * Minified: No                    *\n * ***********************************\n */\n(function (global, factory) {\n    typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('vue')) :\n    typeof define === 'function' && define.amd ? define(['exports', 'vue'], factory) :\n    (global = typeof globalThis !== 'undefined' ? globalThis : global || self, factory(global.MyLibrary = {}, global.Vue));\n})(this, (function (exports, vue) { 'use strict';\n\n    function checkDirectiveType(directive) {\n      if (!directive)\n        return \"engine\";\n      const obj = typeof directive === \"object\" && directive !== null ? directive : void 0;\n      const hasVueHooks = [\"created\", \"beforeMount\", \"mounted\", \"beforeUpdate\", \"updated\", \"beforeUnmount\", \"unmounted\"].some((hook) => !!obj && typeof obj[hook] === \"function\" && obj[hook].length >= 2);\n      const hasEngineHooks = [\"beforeCreate\", \"created\", \"beforeMount\", \"mounted\", \"beforeUpdate\", \"updated\", \"beforeUnmount\", \"unmounted\"].some((hook) => !!obj && typeof obj[hook] === \"function\" && obj[hook].length === 0);\n      if (hasVueHooks && hasEngineHooks)\n        return \"hybrid\";\n      if (hasVueHooks)\n        return \"vue\";\n      return \"engine\";\n    }\n    function convertVueToEngineDirective(vueDirective) {\n      const engineDirective = {\n        name: \"converted-vue-directive\",\n        description: \"Converted from Vue directive\",\n        version: \"1.0.0\"\n      };\n      if (typeof vueDirective === \"object\" && vueDirective !== null) {\n        const d = vueDirective;\n        if (typeof d.created === \"function\") {\n          engineDirective.created = d.created;\n        }\n        if (typeof d.beforeMount === \"function\") {\n          engineDirective.beforeMount = d.beforeMount;\n        }\n        if (typeof d.mounted === \"function\") {\n          engineDirective.mounted = d.mounted;\n        }\n        if (typeof d.beforeUpdate === \"function\") {\n          engineDirective.beforeUpdate = d.beforeUpdate;\n        }\n        if (typeof d.updated === \"function\") {\n          engineDirective.updated = d.updated;\n        }\n        if (typeof d.beforeUnmount === \"function\") {\n          engineDirective.beforeUnmount = d.beforeUnmount;\n        }\n        if (typeof d.unmounted === \"function\") {\n          engineDirective.unmounted = d.unmounted;\n        }\n      } else if (typeof vueDirective === \"function\") {\n        engineDirective.mounted = (el, binding) => {\n          vueDirective(el, binding);\n        };\n      }\n      return engineDirective;\n    }\n    function convertEngineToVueDirective(engineDirective) {\n      const vueDirective = {};\n      if (engineDirective.created) {\n        if (typeof engineDirective.created === \"function\") {\n          if (engineDirective.created.length === 0) {\n            vueDirective.created = (_el, _binding) => {\n              engineDirective.created();\n            };\n          } else {\n            vueDirective.created = engineDirective.created;\n          }\n        }\n      }\n      if (engineDirective.beforeMount) {\n        if (typeof engineDirective.beforeMount === \"function\") {\n          if (engineDirective.beforeMount.length === 0) {\n            vueDirective.beforeMount = (_el, _binding) => {\n              engineDirective.beforeMount();\n            };\n          } else {\n            vueDirective.beforeMount = engineDirective.beforeMount;\n          }\n        }\n      }\n      if (engineDirective.mounted) {\n        if (typeof engineDirective.mounted === \"function\") {\n          if (engineDirective.mounted.length === 0) {\n            vueDirective.mounted = (_el, _binding) => {\n              engineDirective.mounted();\n            };\n          } else {\n            vueDirective.mounted = engineDirective.mounted;\n          }\n        }\n      }\n      if (engineDirective.beforeUpdate) {\n        if (typeof engineDirective.beforeUpdate === \"function\") {\n          if (engineDirective.beforeUpdate.length === 0) {\n            vueDirective.beforeUpdate = (_el, _binding) => {\n              engineDirective.beforeUpdate();\n            };\n          } else {\n            vueDirective.beforeUpdate = engineDirective.beforeUpdate;\n          }\n        }\n      }\n      if (engineDirective.updated) {\n        if (typeof engineDirective.updated === \"function\") {\n          if (engineDirective.updated.length === 0) {\n            vueDirective.updated = (_el, _binding) => {\n              engineDirective.updated();\n            };\n          } else {\n            vueDirective.updated = engineDirective.updated;\n          }\n        }\n      }\n      if (engineDirective.beforeUnmount) {\n        if (typeof engineDirective.beforeUnmount === \"function\") {\n          if (engineDirective.beforeUnmount.length === 0) {\n            vueDirective.beforeUnmount = (_el, _binding) => {\n              engineDirective.beforeUnmount();\n            };\n          } else {\n            vueDirective.beforeUnmount = engineDirective.beforeUnmount;\n          }\n        }\n      }\n      if (engineDirective.unmounted) {\n        if (typeof engineDirective.unmounted === \"function\") {\n          if (engineDirective.unmounted.length === 0) {\n            vueDirective.unmounted = (_el, _binding) => {\n              engineDirective.unmounted();\n            };\n          } else {\n            vueDirective.unmounted = engineDirective.unmounted;\n          }\n        }\n      }\n      return vueDirective;\n    }\n    function createHybridDirectiveAdapter(directive) {\n      const type = checkDirectiveType(directive);\n      switch (type) {\n        case \"vue\":\n          return convertVueToEngineDirective(directive);\n        case \"engine\":\n          return directive;\n        case \"hybrid\":\n          return directive;\n        default:\n          return directive;\n      }\n    }\n\n    class DirectiveManagerImpl {\n      constructor(logger) {\n        this.directives = /* @__PURE__ */ new Map();\n        this.logger = logger;\n      }\n      register(name, directive) {\n        if (this.directives.has(name)) {\n          console.warn(`Directive \"${name}\" is already registered. It will be replaced.`);\n        }\n        const engineDirective = createHybridDirectiveAdapter(directive);\n        this.directives.set(name, engineDirective);\n        this.logger?.debug(`Directive \"${name}\" registered`);\n      }\n      unregister(name) {\n        this.directives.delete(name);\n      }\n      get(name) {\n        return this.directives.get(name);\n      }\n      getAll() {\n        return Array.from(this.directives.values());\n      }\n      // 检查指令是否存在\n      has(name) {\n        return this.directives.has(name);\n      }\n      // 获取所有指令名称\n      getNames() {\n        return Array.from(this.directives.keys());\n      }\n      // 获取指令数量\n      size() {\n        return this.directives.size;\n      }\n      // 清空所有指令\n      clear() {\n        this.directives.clear();\n      }\n      // 批量注册指令\n      registerBatch(directives) {\n        for (const [name, directive] of Object.entries(directives)) {\n          this.register(name, directive);\n        }\n      }\n      // 批量卸载指令\n      unregisterBatch(names) {\n        for (const name of names) {\n          this.unregister(name);\n        }\n      }\n      // 按分类获取指令\n      getByCategory(category) {\n        return Array.from(this.directives.values()).filter((directive) => directive.category === category);\n      }\n      // 按标签获取指令\n      getByTag(tag) {\n        return Array.from(this.directives.values()).filter((directive) => directive.tags?.includes(tag));\n      }\n      // 启用指令\n      enable(name) {\n        const directive = this.directives.get(name);\n        if (directive) {\n          this.logger?.debug(`Directive \"${name}\" enabled`);\n        }\n      }\n      // 禁用指令\n      disable(name) {\n        const directive = this.directives.get(name);\n        if (directive) {\n          this.logger?.debug(`Directive \"${name}\" disabled`);\n        }\n      }\n      // 重新加载指令\n      reload(name) {\n        const directive = this.directives.get(name);\n        if (directive) {\n          this.logger?.debug(`Directive \"${name}\" reloaded`);\n        }\n      }\n      // 验证指令\n      validate(_directive) {\n        return {\n          isValid: true,\n          errors: [],\n          warnings: [],\n          suggestions: []\n        };\n      }\n    }\n    function createDirectiveManager(logger) {\n      return new DirectiveManagerImpl(logger);\n    }\n    const commonDirectives = {\n      // 点击外部区域指令\n      clickOutside: {\n        mounted(el, binding) {\n          const elWith = el;\n          elWith._clickOutsideHandler = (event) => {\n            if (!(el === event.target || el.contains(event.target))) {\n              const handler = binding.value;\n              if (typeof handler === \"function\")\n                handler(event);\n            }\n          };\n          document.addEventListener(\"click\", elWith._clickOutsideHandler);\n        },\n        unmounted(el) {\n          const elWith = el;\n          if (elWith._clickOutsideHandler) {\n            document.removeEventListener(\"click\", elWith._clickOutsideHandler);\n            delete elWith._clickOutsideHandler;\n          }\n        }\n      },\n      // 复制到剪贴板指令\n      copy: {\n        mounted(el, binding) {\n          const elWith = el;\n          elWith._copyHandler = async () => {\n            try {\n              const val = binding.value;\n              const text = typeof val === \"string\" ? val : val?.text ?? el.textContent ?? \"\";\n              await navigator.clipboard.writeText(text);\n              const cb = typeof val === \"object\" && val && typeof val.callback === \"function\" ? val.callback : void 0;\n              if (binding.arg === \"success\" && cb) {\n                cb(text);\n              }\n              el.classList.add(\"copy-success\");\n              setTimeout(() => {\n                el.classList.remove(\"copy-success\");\n              }, 1e3);\n            } catch (error) {\n              console.error(\"Failed to copy text:\", error);\n              const val = binding.value;\n              const cb = val && typeof val.callback === \"function\" ? val.callback : void 0;\n              if (binding.arg === \"error\" && cb) {\n                cb(error);\n              }\n            }\n          };\n          el.addEventListener(\"click\", elWith._copyHandler);\n          el.style.cursor = \"pointer\";\n        },\n        unmounted(el) {\n          const elWith = el;\n          if (elWith._copyHandler) {\n            el.removeEventListener(\"click\", elWith._copyHandler);\n            delete elWith._copyHandler;\n          }\n        }\n      },\n      // 懒加载指令\n      lazy: {\n        mounted(el, binding) {\n          const val = binding.value;\n          const options = {\n            threshold: 0.1,\n            rootMargin: \"50px\",\n            ...typeof val === \"object\" && val ? val.options ?? {} : {}\n          };\n          const elWith = el;\n          elWith._lazyObserver = new IntersectionObserver((entries) => {\n            entries.forEach((entry) => {\n              if (entry.isIntersecting) {\n                if (typeof val === \"function\") {\n                  val(el);\n                } else if (typeof val?.callback === \"function\") {\n                  val.callback(el);\n                }\n                el._lazyObserver?.unobserve(el);\n              }\n            });\n          }, options);\n          elWith._lazyObserver.observe(el);\n        },\n        unmounted(el) {\n          if (el._lazyObserver) {\n            el._lazyObserver.disconnect();\n            delete el._lazyObserver;\n          }\n        }\n      },\n      // 防抖指令\n      debounce: {\n        mounted(el, binding) {\n          const val = binding.value;\n          const delay = (typeof val === \"object\" && val ? val.delay : void 0) ?? 300;\n          const event = binding.arg || (typeof val === \"object\" && val ? val.event : void 0) || \"click\";\n          el._debounceHandler = (...args) => {\n            clearTimeout(el._debounceTimer);\n            el._debounceTimer = window.setTimeout(() => {\n              if (typeof val === \"function\") {\n                val(...args);\n              } else if (typeof val?.callback === \"function\") {\n                val.callback(...args);\n              }\n            }, delay);\n          };\n          el.addEventListener(event, el._debounceHandler);\n        },\n        updated(el, binding) {\n          const val = binding.value;\n          const delay = val?.delay ?? 300;\n          el._debounceDelay = delay;\n        },\n        unmounted(el) {\n          if (el._debounceTimer) {\n            clearTimeout(el._debounceTimer);\n          }\n          if (el._debounceHandler) {\n            const event = \"click\";\n            el.removeEventListener(event, el._debounceHandler);\n            delete el._debounceHandler;\n          }\n        }\n      },\n      // 节流指令\n      throttle: {\n        mounted(el, binding) {\n          const val = binding.value;\n          const delay = (typeof val === \"object\" && val ? val.delay : void 0) ?? 300;\n          const event = binding.arg || (typeof val === \"object\" && val ? val.event : void 0) || \"click\";\n          let lastTime = 0;\n          el._throttleHandler = (...args) => {\n            const now = Date.now();\n            if (now - lastTime >= delay) {\n              lastTime = now;\n              if (typeof val === \"function\") {\n                val(...args);\n              } else if (typeof val?.callback === \"function\") {\n                val.callback(...args);\n              }\n            }\n          };\n          el.addEventListener(event, el._throttleHandler);\n        },\n        unmounted(el) {\n          if (el._throttleHandler) {\n            const event = \"click\";\n            el.removeEventListener(event, el._throttleHandler);\n            delete el._throttleHandler;\n          }\n        }\n      },\n      // 权限控制指令\n      permission: {\n        mounted(el, binding) {\n          const val = binding.value;\n          const permissions = Array.isArray(val) ? val : [val].filter((v) => typeof v === \"string\");\n          const hasPermission = permissions.some((permission) => {\n            return checkPermission();\n          });\n          if (!hasPermission) {\n            if (binding.modifiers.hide) {\n              el.style.display = \"none\";\n            } else if (binding.modifiers.disable) {\n              el.setAttribute(\"disabled\", \"true\");\n              el.style.opacity = \"0.5\";\n              el.style.pointerEvents = \"none\";\n            } else {\n              el.remove();\n            }\n          }\n        }\n      },\n      // 焦点指令\n      focus: {\n        mounted(el, binding) {\n          if (binding.value !== false) {\n            el.focus();\n          }\n        },\n        updated(el, binding) {\n          if (binding.value && !binding.oldValue) {\n            el.focus();\n          }\n        }\n      }\n    };\n    function checkPermission(_permission) {\n      return true;\n    }\n\n    var CacheStrategy;\n    (function(CacheStrategy2) {\n      CacheStrategy2[\"LRU\"] = \"lru\";\n      CacheStrategy2[\"LFU\"] = \"lfu\";\n      CacheStrategy2[\"FIFO\"] = \"fifo\";\n      CacheStrategy2[\"TTL\"] = \"ttl\";\n    })(CacheStrategy || (CacheStrategy = {}));\n    class LRUCache {\n      constructor(maxSize = 100, onEvict) {\n        this.cache = /* @__PURE__ */ new Map();\n        this.cleanupQueue = [];\n        this.CLEANUP_BATCH_SIZE = 20;\n        this.CLEANUP_INTERVAL = 5e3;\n        this.MAX_CLEANUP_QUEUE_SIZE = 1e3;\n        this.adaptiveCleanupInterval = 5e3;\n        this.lastCleanupPerformance = 0;\n        this.lastCleanupTime = 0;\n        this.maxItemSize = 1024 * 1024;\n        this.maxSize = maxSize;\n        this.onEvict = onEvict;\n        this.stats = {\n          hits: 0,\n          misses: 0,\n          sets: 0,\n          deletes: 0,\n          evictions: 0,\n          size: 0,\n          hitRate: 0\n        };\n        this.startCleanupTimer();\n      }\n      get(key) {\n        const item = this.cache.get(key);\n        if (!item) {\n          this.stats.misses++;\n          this.updateHitRate();\n          return void 0;\n        }\n        if (item.ttl && Date.now() - item.timestamp > item.ttl) {\n          this.scheduleCleanup(key);\n          this.stats.misses++;\n          this.stats.evictions++;\n          this.updateHitRate();\n          return void 0;\n        }\n        item.lastAccessed = Date.now();\n        item.accessCount++;\n        this.cache.delete(key);\n        this.cache.set(key, item);\n        this.stats.hits++;\n        this.updateHitRate();\n        return item.value;\n      }\n      set(key, value, ttl) {\n        const itemSize = this.estimateItemSize(key, value);\n        if (itemSize > this.maxItemSize) {\n          console.warn(`Cache item \"${key}\" exceeds maximum size limit (${itemSize} bytes)`);\n          return;\n        }\n        if (this.cache.has(key)) {\n          this.cache.delete(key);\n        } else if (this.cache.size >= this.maxSize) {\n          const firstKey = this.cache.keys().next().value;\n          if (firstKey !== void 0) {\n            const evictedItem = this.cache.get(firstKey);\n            this.cache.delete(firstKey);\n            this.stats.evictions++;\n            if (evictedItem && this.onEvict) {\n              this.onEvict(firstKey, evictedItem.value);\n            }\n          }\n        }\n        const item = {\n          key,\n          value,\n          timestamp: Date.now(),\n          ttl,\n          accessCount: 0,\n          lastAccessed: Date.now(),\n          size: itemSize\n          // 记录项目大小\n        };\n        this.cache.set(key, item);\n        this.stats.sets++;\n        this.stats.size = this.cache.size;\n      }\n      has(key) {\n        const item = this.cache.get(key);\n        if (!item)\n          return false;\n        if (item.ttl && Date.now() - item.timestamp > item.ttl) {\n          this.cache.delete(key);\n          this.stats.evictions++;\n          this.stats.size = this.cache.size;\n          return false;\n        }\n        return true;\n      }\n      delete(key) {\n        const deleted = this.cache.delete(key);\n        if (deleted) {\n          this.stats.deletes++;\n          this.stats.size = this.cache.size;\n        }\n        return deleted;\n      }\n      clear() {\n        this.cache.clear();\n        this.stats.size = 0;\n      }\n      size() {\n        return this.cache.size;\n      }\n      keys() {\n        return Array.from(this.cache.keys());\n      }\n      values() {\n        const values = [];\n        const now = Date.now();\n        for (const [key, item] of this.cache.entries()) {\n          if (item.ttl && now - item.timestamp > item.ttl) {\n            this.cache.delete(key);\n            this.stats.evictions++;\n            continue;\n          }\n          values.push(item.value);\n        }\n        this.stats.size = this.cache.size;\n        return values;\n      }\n      entries() {\n        const entries = [];\n        const now = Date.now();\n        for (const [key, item] of this.cache.entries()) {\n          if (item.ttl && now - item.timestamp > item.ttl) {\n            this.cache.delete(key);\n            this.stats.evictions++;\n            continue;\n          }\n          entries.push([key, item.value]);\n        }\n        this.stats.size = this.cache.size;\n        return entries;\n      }\n      // 新增：批量清理过期项的方法\n      resetStats() {\n        this.stats = {\n          hits: 0,\n          misses: 0,\n          sets: 0,\n          deletes: 0,\n          evictions: 0,\n          size: this.cache.size,\n          hitRate: 0\n        };\n      }\n      // 获取内部缓存映射（用于统计计算）\n      get internalCache() {\n        return this.cache;\n      }\n      // 安全获取统计信息\n      getStats() {\n        return this.stats;\n      }\n      updateHitRate() {\n        const total = this.stats.hits + this.stats.misses;\n        this.stats.hitRate = total > 0 ? this.stats.hits / total : 0;\n      }\n      // 清理过期项\n      cleanup() {\n        const now = Date.now();\n        const keysToDelete = [];\n        for (const [key, item] of this.cache) {\n          if (item.ttl && now - item.timestamp > item.ttl) {\n            keysToDelete.push(key);\n          }\n        }\n        for (const key of keysToDelete) {\n          this.cache.delete(key);\n          this.stats.evictions++;\n        }\n        this.stats.size = this.cache.size;\n      }\n      /**\n       * 估算缓存项目大小\n       */\n      estimateItemSize(key, value) {\n        const keySize = key.length * 2;\n        let valueSize = 0;\n        try {\n          const serialized = JSON.stringify(value);\n          valueSize = serialized.length * 2;\n        } catch {\n          valueSize = 1024;\n        }\n        return keySize + valueSize;\n      }\n      /**\n       * 性能优化：智能清理策略启动\n       */\n      startCleanupTimer() {\n        this.cleanupTimer = setInterval(() => {\n          this.intelligentCleanup();\n        }, this.adaptiveCleanupInterval);\n      }\n      /**\n       * 智能清理策略\n       */\n      intelligentCleanup() {\n        const startTime = performance.now();\n        const usage = this.cache.size / this.maxSize;\n        if (usage > 0.8) {\n          this.cleanup();\n        } else if (this.cleanupQueue.length > 0) {\n          this.processCleanupQueue();\n        }\n        const endTime = performance.now();\n        this.lastCleanupPerformance = endTime - startTime;\n        this.lastCleanupTime = endTime;\n        this.adjustCleanupInterval();\n      }\n      /**\n       * 动态调整清理间隔\n       */\n      adjustCleanupInterval() {\n        if (this.lastCleanupPerformance > 50) {\n          this.adaptiveCleanupInterval = Math.min(this.adaptiveCleanupInterval * 1.5, 3e4);\n        } else if (this.lastCleanupPerformance < 5 && this.cache.size > this.maxSize * 0.7) {\n          this.adaptiveCleanupInterval = Math.max(this.adaptiveCleanupInterval * 0.8, 1e3);\n        }\n        if (this.cleanupTimer) {\n          clearInterval(this.cleanupTimer);\n          this.cleanupTimer = setInterval(() => {\n            this.intelligentCleanup();\n          }, this.adaptiveCleanupInterval);\n        }\n      }\n      /**\n       * 性能优化：调度清理任务\n       */\n      scheduleCleanup(key) {\n        if (this.cleanupQueue.length >= this.MAX_CLEANUP_QUEUE_SIZE) {\n          this.processCleanupQueue();\n        }\n        if (!this.cleanupQueue.includes(key)) {\n          this.cleanupQueue.push(key);\n        }\n        if (this.cleanupQueue.length >= this.CLEANUP_BATCH_SIZE) {\n          this.processCleanupQueue();\n        }\n      }\n      /**\n       * 性能优化：批量处理清理队列\n       */\n      processCleanupQueue() {\n        if (this.cleanupQueue.length === 0)\n          return;\n        const keysToProcess = this.cleanupQueue.splice(0, this.CLEANUP_BATCH_SIZE);\n        for (const key of keysToProcess) {\n          this.cache.delete(key);\n        }\n        this.stats.size = this.cache.size;\n      }\n      /**\n       * 手动触发清理队列处理（主要用于测试）\n       */\n      forceCleanup() {\n        this.processCleanupQueue();\n      }\n      /**\n       * 增强的销毁方法\n       */\n      destroy() {\n        if (this.cleanupTimer) {\n          clearInterval(this.cleanupTimer);\n          this.cleanupTimer = void 0;\n        }\n        this.cache.clear();\n        this.cleanupQueue.length = 0;\n        this.stats.size = 0;\n        this.onEvict = void 0;\n      }\n      /**\n       * 获取性能指标\n       */\n      getPerformanceMetrics() {\n        let memoryUsage = 0;\n        for (const [_key, item] of this.cache.entries()) {\n          if (!item.ttl || Date.now() - item.timestamp <= item.ttl) {\n            memoryUsage += item.size || 0;\n          }\n        }\n        return {\n          adaptiveInterval: this.adaptiveCleanupInterval,\n          lastCleanupTime: this.lastCleanupTime,\n          lastCleanupPerformance: this.lastCleanupPerformance,\n          cleanupQueueLength: this.cleanupQueue.length,\n          memoryUsageEstimate: memoryUsage\n        };\n      }\n      // 获取缓存健康状态\n      getHealthStatus() {\n        const hitRate = this.stats.hitRate;\n        const memoryUsage = this.cache.size / this.maxSize;\n        const recommendations = [];\n        let status = \"healthy\";\n        if (hitRate < 0.5) {\n          status = \"warning\";\n          recommendations.push(\"\\u7F13\\u5B58\\u547D\\u4E2D\\u7387\\u8F83\\u4F4E\\uFF0C\\u8003\\u8651\\u8C03\\u6574\\u7F13\\u5B58\\u7B56\\u7565\");\n        }\n        if (hitRate < 0.2) {\n          status = \"critical\";\n          recommendations.push(\"\\u7F13\\u5B58\\u547D\\u4E2D\\u7387\\u8FC7\\u4F4E\\uFF0C\\u9700\\u8981\\u91CD\\u65B0\\u8BC4\\u4F30\\u7F13\\u5B58\\u914D\\u7F6E\");\n        }\n        if (memoryUsage > 0.9) {\n          status = \"critical\";\n          recommendations.push(\"\\u7F13\\u5B58\\u4F7F\\u7528\\u7387\\u8FC7\\u9AD8\\uFF0C\\u8003\\u8651\\u589E\\u52A0\\u7F13\\u5B58\\u5927\\u5C0F\\u6216\\u8C03\\u6574TTL\");\n        } else if (memoryUsage > 0.7) {\n          status = \"warning\";\n          recommendations.push(\"\\u7F13\\u5B58\\u4F7F\\u7528\\u7387\\u8F83\\u9AD8\\uFF0C\\u5EFA\\u8BAE\\u76D1\\u63A7\\u5185\\u5B58\\u4F7F\\u7528\\u60C5\\u51B5\");\n        }\n        if (this.stats.evictions > this.stats.sets * 0.3) {\n          recommendations.push(\"\\u7F13\\u5B58\\u6DD8\\u6C70\\u7387\\u8F83\\u9AD8\\uFF0C\\u8003\\u8651\\u589E\\u52A0\\u7F13\\u5B58\\u5927\\u5C0F\");\n        }\n        return {\n          status,\n          hitRate,\n          memoryUsage,\n          recommendations\n        };\n      }\n    }\n    class CacheManagerImpl {\n      constructor(config = {}) {\n        this.namespaces = /* @__PURE__ */ new Map();\n        this.config = {\n          maxSize: 100,\n          defaultTTL: 0,\n          // 0表示永不过期\n          strategy: CacheStrategy.LRU,\n          enableStats: true,\n          onEvict: () => {\n          },\n          ...config\n        };\n        this.cache = new LRUCache(this.config.maxSize, this.config.onEvict);\n      }\n      get(key) {\n        return this.cache.get(key);\n      }\n      set(key, value, ttl) {\n        const finalTTL = ttl ?? this.config.defaultTTL;\n        this.cache.set(key, value, finalTTL > 0 ? finalTTL : void 0);\n      }\n      has(key) {\n        return this.cache.has(key);\n      }\n      delete(key) {\n        const prev = this.cache.get(key);\n        const deleted = this.cache.delete(key);\n        if (deleted && this.config.onEvict && prev !== void 0) {\n          this.config.onEvict(key, prev);\n        }\n        return deleted;\n      }\n      clear() {\n        this.cache.clear();\n      }\n      size() {\n        return this.cache.size();\n      }\n      keys() {\n        return this.cache.keys();\n      }\n      values() {\n        this.cache.cleanup();\n        const values = [];\n        for (const key of this.cache.keys()) {\n          const value = this.cache.get(key);\n          if (value !== void 0) {\n            values.push(value);\n          }\n        }\n        return values;\n      }\n      entries() {\n        this.cache.cleanup();\n        const entries = [];\n        for (const key of this.cache.keys()) {\n          const value = this.cache.get(key);\n          if (value !== void 0) {\n            entries.push([key, value]);\n          }\n        }\n        return entries;\n      }\n      getStats() {\n        const baseStats = this.cache.getStats();\n        const hitRate = baseStats.hits + baseStats.misses > 0 ? baseStats.hits / (baseStats.hits + baseStats.misses) : 0;\n        let memoryUsage = 0;\n        for (const [key, item] of this.cache.internalCache.entries()) {\n          if (!item.ttl || Date.now() - item.timestamp <= item.ttl) {\n            memoryUsage += key.length * 2;\n            memoryUsage += JSON.stringify(item.value).length * 2;\n          }\n        }\n        const currentSize = this.size();\n        const averageItemSize = currentSize > 0 ? memoryUsage / currentSize : 0;\n        return {\n          ...baseStats,\n          hitRate: Math.round(hitRate * 100) / 100,\n          memoryUsage,\n          averageItemSize: Math.round(averageItemSize)\n        };\n      }\n      resetStats() {\n        this.cache.resetStats();\n      }\n      /**\n       * 手动触发清理队列处理（主要用于测试）\n       */\n      forceCleanup() {\n        this.cache.forceCleanup();\n      }\n      /**\n       * 新增：智能预加载功能\n       * 根据访问模式预加载可能需要的数据\n       */\n      async preload(keys, loader, options) {\n        const { ttl, priority = \"normal\" } = options || {};\n        const loadPromises = keys.map(async (key) => {\n          if (!this.has(key)) {\n            try {\n              const value = await loader(key);\n              this.set(key, value, ttl);\n            } catch (error) {\n              console.warn(`Failed to preload cache key: ${key}`, error);\n            }\n          }\n        });\n        if (priority === \"high\") {\n          return Promise.all(loadPromises).then(() => {\n          });\n        } else {\n          Promise.all(loadPromises).catch(() => {\n          });\n          return Promise.resolve();\n        }\n      }\n      /**\n       * 新增：缓存预热功能\n       * 在系统启动时预热常用数据\n       */\n      async warmup(warmupData) {\n        const warmupPromises = warmupData.map(async ({ key, loader, ttl }) => {\n          try {\n            const value = await loader();\n            this.set(key, value, ttl);\n          } catch (error) {\n            console.warn(`Failed to warmup cache key: ${key}`, error);\n          }\n        });\n        await Promise.all(warmupPromises);\n      }\n      namespace(name) {\n        if (!this.namespaces.has(name)) {\n          this.namespaces.set(name, new NamespacedCacheManager(this, name));\n        }\n        return this.namespaces.get(name);\n      }\n    }\n    class NamespacedCacheManager {\n      constructor(parent, namespaceName) {\n        this.parent = parent;\n        this.namespaceName = namespaceName;\n      }\n      getKey(key) {\n        return `${this.namespaceName}:${key}`;\n      }\n      get(key) {\n        return this.parent.get(this.getKey(key));\n      }\n      set(key, value, ttl) {\n        this.parent.set(this.getKey(key), value, ttl);\n      }\n      has(key) {\n        return this.parent.has(this.getKey(key));\n      }\n      delete(key) {\n        return this.parent.delete(this.getKey(key));\n      }\n      clear() {\n        const prefix = `${this.namespaceName}:`;\n        const keys = this.parent.keys().filter((key) => key.startsWith(prefix));\n        keys.forEach((key) => this.parent.delete(key));\n      }\n      size() {\n        const prefix = `${this.namespaceName}:`;\n        return this.parent.keys().filter((key) => key.startsWith(prefix)).length;\n      }\n      keys() {\n        const prefix = `${this.namespaceName}:`;\n        return this.parent.keys().filter((key) => key.startsWith(prefix)).map((key) => key.slice(prefix.length));\n      }\n      values() {\n        return this.keys().map((key) => this.get(key)).filter((value) => value !== void 0);\n      }\n      entries() {\n        const result = [];\n        for (const key of this.keys()) {\n          const v = this.get(key);\n          if (v !== void 0) {\n            result.push([key, v]);\n          }\n        }\n        return result;\n      }\n      getStats() {\n        return this.parent.getStats();\n      }\n      async preload(keys, loader, options) {\n        return this.parent.preload(keys, loader, options);\n      }\n      async warmup(warmupData) {\n        return this.parent.warmup(warmupData);\n      }\n      resetStats() {\n        this.parent.resetStats();\n      }\n      namespace(name) {\n        return this.parent.namespace(`${this.namespaceName}:${name}`);\n      }\n    }\n    function createCacheManager(config) {\n      return new CacheManagerImpl(config);\n    }\n\n    function generateId(prefix = \"id\") {\n      const timestamp = Date.now();\n      const random = Math.random().toString(36).substr(2, 9);\n      return `${prefix}_${timestamp}_${random}`;\n    }\n    function debounce(func, wait) {\n      let timeout;\n      return (...args) => {\n        clearTimeout(timeout);\n        timeout = setTimeout(() => func(...args), wait);\n      };\n    }\n    function throttle(func, wait) {\n      let lastTime = 0;\n      return (...args) => {\n        const now = Date.now();\n        if (now - lastTime >= wait) {\n          lastTime = now;\n          func(...args);\n        }\n      };\n    }\n    function deepClone(obj) {\n      if (obj === null || typeof obj !== \"object\") {\n        return obj;\n      }\n      if (obj instanceof Date) {\n        return new Date(obj.getTime());\n      }\n      if (Array.isArray(obj)) {\n        return obj.map((item) => deepClone(item));\n      }\n      if (typeof obj === \"object\") {\n        const cloned = {};\n        for (const key in obj) {\n          if (obj.hasOwnProperty(key)) {\n            cloned[key] = deepClone(obj[key]);\n          }\n        }\n        return cloned;\n      }\n      return obj;\n    }\n    function isObject(value) {\n      return value !== null && typeof value === \"object\" && !Array.isArray(value);\n    }\n    function getByPath(obj, path, defaultValue) {\n      const keys = path.split(\".\");\n      let result = obj;\n      for (const key of keys) {\n        if (result && typeof result === \"object\" && key in result) {\n          result = result[key];\n        } else {\n          return defaultValue;\n        }\n      }\n      return result;\n    }\n    const getNestedValue = getByPath;\n    function setByPath(obj, path, value) {\n      const keys = path.split(\".\");\n      let current = obj;\n      for (let i = 0; i < keys.length - 1; i++) {\n        const key = keys[i];\n        if (!(key in current) || typeof current[key] !== \"object\") {\n          current[key] = {};\n        }\n        current = current[key];\n      }\n      current[keys[keys.length - 1]] = value;\n      return true;\n    }\n    const setNestedValue = setByPath;\n\n    class TimerManager {\n      constructor() {\n        this.timers = /* @__PURE__ */ new Set();\n        this.intervals = /* @__PURE__ */ new Set();\n        this.animationFrames = /* @__PURE__ */ new Set();\n        this.pendingCleanup = /* @__PURE__ */ new Set();\n      }\n      /**\n       * 设置超时定时器\n       */\n      setTimeout(callback, delay) {\n        const timer = setTimeout(() => {\n          this.timers.delete(timer);\n          try {\n            callback();\n          } catch (error) {\n            console.error(\"Timer callback error:\", error);\n          }\n        }, delay);\n        this.timers.add(timer);\n        return timer;\n      }\n      /**\n       * 设置间隔定时器\n       */\n      setInterval(callback, interval) {\n        const timer = setInterval(callback, interval);\n        this.intervals.add(timer);\n        return timer;\n      }\n      /**\n       * 清除超时定时器\n       */\n      clearTimeout(timer) {\n        clearTimeout(timer);\n        this.timers.delete(timer);\n      }\n      /**\n       * 清除间隔定时器\n       */\n      clearInterval(timer) {\n        clearInterval(timer);\n        this.intervals.delete(timer);\n      }\n      /**\n       * 请求动画帧\n       */\n      requestAnimationFrame(callback) {\n        const id = requestAnimationFrame(() => {\n          this.animationFrames.delete(id);\n          callback();\n        });\n        this.animationFrames.add(id);\n        return id;\n      }\n      /**\n       * 取消动画帧\n       */\n      cancelAnimationFrame(id) {\n        cancelAnimationFrame(id);\n        this.animationFrames.delete(id);\n      }\n      /**\n       * 获取活跃定时器数量\n       */\n      getActiveCount() {\n        return this.timers.size + this.intervals.size + this.animationFrames.size;\n      }\n      /**\n       * 获取定时器统计信息\n       */\n      getStats() {\n        return {\n          timeout: this.timers.size,\n          interval: this.intervals.size,\n          animationFrame: this.animationFrames.size,\n          total: this.getActiveCount()\n        };\n      }\n      /**\n       * 获取活跃定时器信息\n       */\n      getActiveTimers() {\n        return {\n          timeouts: this.timers.size,\n          intervals: this.intervals.size\n        };\n      }\n      /**\n       * 批量清理定时器（性能优化）\n       */\n      performBatchCleanup() {\n        if (this.pendingCleanup.size === 0)\n          return;\n        for (const timer of this.pendingCleanup) {\n          clearTimeout(timer);\n          clearInterval(timer);\n          this.timers.delete(timer);\n          this.intervals.delete(timer);\n        }\n        this.pendingCleanup.clear();\n        if (this.cleanupTimer) {\n          clearTimeout(this.cleanupTimer);\n          this.cleanupTimer = void 0;\n        }\n      }\n      /**\n       * 清除所有定时器和间隔器\n       */\n      clearAll() {\n        this.performBatchCleanup();\n        for (const timer of this.timers) {\n          clearTimeout(timer);\n        }\n        for (const timer of this.intervals) {\n          clearInterval(timer);\n        }\n        for (const id of this.animationFrames) {\n          cancelAnimationFrame(id);\n        }\n        this.timers.clear();\n        this.intervals.clear();\n        this.animationFrames.clear();\n      }\n    }\n    class ListenerManager {\n      constructor() {\n        this.listeners = /* @__PURE__ */ new Map();\n        this.listenerIds = /* @__PURE__ */ new Map();\n        this.nextId = 1;\n      }\n      /**\n       * 添加事件监听器\n       */\n      addEventListener(target, type, listener, options) {\n        target.addEventListener(type, listener, options);\n        if (!this.listeners.has(target)) {\n          this.listeners.set(target, /* @__PURE__ */ new Map());\n        }\n        const targetListeners = this.listeners.get(target);\n        if (!targetListeners.has(type)) {\n          targetListeners.set(type, /* @__PURE__ */ new Set());\n        }\n        targetListeners.get(type).add(listener);\n        const id = `listener_${this.nextId++}`;\n        this.listenerIds.set(id, { target, type, listener, options });\n        return id;\n      }\n      removeEventListener(idOrTarget, type, listener) {\n        if (typeof idOrTarget === \"string\") {\n          const id = idOrTarget;\n          const listenerInfo = this.listenerIds.get(id);\n          if (listenerInfo) {\n            const { target, type: type2, listener: listener2, options } = listenerInfo;\n            if (target && typeof target.removeEventListener === \"function\") {\n              target.removeEventListener(type2, listener2, options);\n            }\n            const targetListeners = this.listeners.get(target);\n            if (targetListeners) {\n              const typeListeners = targetListeners.get(type2);\n              if (typeListeners) {\n                typeListeners.delete(listener2);\n                if (typeListeners.size === 0) {\n                  targetListeners.delete(type2);\n                }\n              }\n              if (targetListeners.size === 0) {\n                this.listeners.delete(target);\n              }\n            }\n            this.listenerIds.delete(id);\n          }\n        } else {\n          const target = idOrTarget;\n          target.removeEventListener(type, listener);\n          const targetListeners = this.listeners.get(target);\n          if (targetListeners) {\n            const typeListeners = targetListeners.get(type);\n            if (typeListeners) {\n              typeListeners.delete(listener);\n              if (typeListeners.size === 0) {\n                targetListeners.delete(type);\n              }\n            }\n            if (targetListeners.size === 0) {\n              this.listeners.delete(target);\n            }\n          }\n          for (const [id, info] of this.listenerIds.entries()) {\n            if (info.target === target && info.type === type && info.listener === listener) {\n              this.listenerIds.delete(id);\n              break;\n            }\n          }\n        }\n      }\n      /**\n       * 移除所有监听器\n       */\n      removeAll() {\n        for (const [target, targetListeners] of this.listeners.entries()) {\n          for (const [type, typeListeners] of targetListeners.entries()) {\n            for (const listener of typeListeners) {\n              target.removeEventListener(type, listener);\n            }\n          }\n        }\n        this.listeners.clear();\n        this.listenerIds.clear();\n      }\n      /**\n       * 按目标移除监听器\n       */\n      removeByTarget(target) {\n        const targetListeners = this.listeners.get(target);\n        if (targetListeners) {\n          for (const [type, typeListeners] of targetListeners.entries()) {\n            for (const listener of typeListeners) {\n              target.removeEventListener(type, listener);\n            }\n          }\n          this.listeners.delete(target);\n        }\n        for (const [id, info] of this.listenerIds.entries()) {\n          if (info.target === target) {\n            this.listenerIds.delete(id);\n          }\n        }\n      }\n      /**\n       * 获取活跃监听器数量\n       */\n      getActiveCount() {\n        let count = 0;\n        for (const targetListeners of this.listeners.values()) {\n          for (const typeListeners of targetListeners.values()) {\n            count += typeListeners.size;\n          }\n        }\n        return count;\n      }\n      /**\n       * 获取统计信息\n       */\n      getStats() {\n        const eventTypes = /* @__PURE__ */ new Set();\n        let totalListeners = 0;\n        for (const targetListeners of this.listeners.values()) {\n          for (const [type, typeListeners] of targetListeners.entries()) {\n            eventTypes.add(type);\n            totalListeners += typeListeners.size;\n          }\n        }\n        return {\n          totalListeners,\n          uniqueTargets: this.listeners.size,\n          eventTypes: Array.from(eventTypes)\n        };\n      }\n    }\n    class ResourceManager {\n      constructor() {\n        this.resources = /* @__PURE__ */ new Map();\n        this.timerManager = new TimerManager();\n        this.listenerManager = new ListenerManager();\n        this.isDestroyed = false;\n        this.nextId = 1;\n      }\n      /**\n       * 注册清理资源\n       */\n      register(resource, cleanup, group) {\n        if (this.isDestroyed) {\n          console.warn(\"ResourceManager is already destroyed\");\n          return \"\";\n        }\n        const id = `resource_${this.nextId++}`;\n        this.resources.set(id, { resource, cleanup, group });\n        return id;\n      }\n      /**\n       * 释放特定资源\n       */\n      release(id) {\n        const resourceInfo = this.resources.get(id);\n        if (resourceInfo) {\n          try {\n            resourceInfo.cleanup(resourceInfo.resource);\n          } catch (error) {\n            console.error(\"Error during resource cleanup:\", error);\n          }\n          this.resources.delete(id);\n        }\n      }\n      /**\n       * 获取资源数量\n       */\n      getResourceCount() {\n        return this.resources.size;\n      }\n      /**\n       * 清理所有资源\n       */\n      cleanup() {\n        for (const [_id, resourceInfo] of this.resources.entries()) {\n          try {\n            resourceInfo.cleanup(resourceInfo.resource);\n          } catch (error) {\n            console.error(\"Error during resource cleanup:\", error);\n          }\n        }\n        this.resources.clear();\n      }\n      /**\n       * 按分组清理资源\n       */\n      cleanupGroup(group) {\n        for (const [id, resourceInfo] of this.resources.entries()) {\n          if (resourceInfo.group === group) {\n            try {\n              resourceInfo.cleanup(resourceInfo.resource);\n            } catch (error) {\n              console.error(\"Error during resource cleanup:\", error);\n            }\n            this.resources.delete(id);\n          }\n        }\n      }\n      /**\n       * 获取统计信息\n       */\n      getStats() {\n        const groups = {};\n        let totalResources = 0;\n        for (const resourceInfo of this.resources.values()) {\n          totalResources++;\n          const group = resourceInfo.group || \"default\";\n          groups[group] = (groups[group] || 0) + 1;\n        }\n        return {\n          totalResources,\n          groups\n        };\n      }\n    }\n    class MemoryLeakDetector {\n      constructor() {\n        this.snapshots = [];\n        this.maxSnapshots = 100;\n        this.objectCounts = /* @__PURE__ */ new Map();\n        this.memoryUsageHistory = [];\n        this.isMonitoringActive = false;\n      }\n      /**\n       * 检查是否正在监控\n       */\n      isMonitoring() {\n        return this.isMonitoringActive;\n      }\n      /**\n       * 开始监控内存使用\n       */\n      startMonitoring(intervalMs = 3e4) {\n        if (this.monitoringInterval) {\n          console.warn(\"Memory monitoring is already active\");\n          return;\n        }\n        this.isMonitoringActive = true;\n        this.monitoringInterval = setInterval(() => {\n          this.takeSnapshot();\n        }, intervalMs);\n        this.takeSnapshot();\n      }\n      /**\n       * 停止监控\n       */\n      stopMonitoring() {\n        if (this.monitoringInterval) {\n          clearInterval(this.monitoringInterval);\n          this.monitoringInterval = void 0;\n          this.isMonitoringActive = false;\n        }\n      }\n      /**\n       * 跟踪对象创建\n       */\n      trackObjectCreation(type, _size) {\n        this.objectCounts.set(type, (this.objectCounts.get(type) || 0) + 1);\n      }\n      /**\n       * 跟踪对象销毁\n       */\n      trackObjectDestruction(type) {\n        const count = this.objectCounts.get(type) || 0;\n        if (count > 0) {\n          this.objectCounts.set(type, count - 1);\n        }\n      }\n      /**\n       * 跟踪内存使用\n       */\n      trackMemoryUsage(bytes) {\n        this.memoryUsageHistory.push(bytes);\n        if (this.memoryUsageHistory.length > this.maxSnapshots) {\n          this.memoryUsageHistory.shift();\n        }\n      }\n      /**\n       * 获取对象数量\n       */\n      getObjectCount(type) {\n        return this.objectCounts.get(type) || 0;\n      }\n      /**\n       * 检测潜在的内存泄漏\n       */\n      detectPotentialLeaks() {\n        const leaks = [];\n        const threshold = 100;\n        for (const [type, count] of this.objectCounts.entries()) {\n          if (count > threshold) {\n            let suspicionLevel = \"medium\";\n            if (count >= 150)\n              suspicionLevel = \"high\";\n            leaks.push({ type, count, threshold, suspicionLevel });\n          }\n        }\n        return leaks;\n      }\n      /**\n       * 生成内存使用报告\n       */\n      generateReport() {\n        let totalObjects = 0;\n        const objectTypes = [];\n        for (const [type, count] of this.objectCounts.entries()) {\n          totalObjects += count;\n          objectTypes.push(type);\n        }\n        const estimatedMemoryUsage = this.memoryUsageHistory.length > 0 ? this.memoryUsageHistory[this.memoryUsageHistory.length - 1] : 1024;\n        return {\n          totalObjects,\n          objectTypes,\n          estimatedMemoryUsage,\n          potentialLeaks: this.detectPotentialLeaks()\n        };\n      }\n      /**\n       * 拍摄内存快照\n       */\n      takeSnapshot() {\n        const hasProcessMemory = (() => {\n          try {\n            const processKey = \"process\";\n            const memoryUsage = globalThis?.[processKey]?.memoryUsage;\n            return typeof memoryUsage === \"function\";\n          } catch {\n            return false;\n          }\n        })();\n        if (!hasProcessMemory) {\n          if (\"memory\" in performance) {\n            const memory = performance.memory;\n            this.snapshots.push({\n              timestamp: Date.now(),\n              heapUsed: memory.usedJSHeapSize,\n              heapTotal: memory.totalJSHeapSize,\n              external: 0\n            });\n          }\n        } else {\n          const processKey = \"process\";\n          const memoryUsage = globalThis?.[processKey]?.memoryUsage;\n          const memUsage = typeof memoryUsage === \"function\" ? memoryUsage() : null;\n          if (memUsage) {\n            this.snapshots.push({\n              timestamp: Date.now(),\n              heapUsed: memUsage.heapUsed,\n              heapTotal: memUsage.heapTotal,\n              external: memUsage.external\n            });\n          }\n        }\n        if (this.snapshots.length > this.maxSnapshots) {\n          this.snapshots.shift();\n        }\n      }\n      /**\n       * 检测内存泄漏\n       */\n      detectLeaks() {\n        if (this.snapshots.length < 3) {\n          return {\n            hasPotentialLeak: false,\n            trend: \"stable\",\n            growth: 0,\n            recommendations: [\"Need more data points for accurate analysis\"]\n          };\n        }\n        const recent = this.snapshots.slice(-10);\n        const oldest = recent[0];\n        const newest = recent[recent.length - 1];\n        const timeDiff = newest.timestamp - oldest.timestamp;\n        const heapDiff = newest.heapUsed - oldest.heapUsed;\n        const growthRate = heapDiff / (1024 * 1024) / (timeDiff / (1e3 * 60));\n        let trend = \"stable\";\n        if (growthRate > 0.1) {\n          trend = \"increasing\";\n        } else if (growthRate < -0.1) {\n          trend = \"decreasing\";\n        }\n        const hasPotentialLeak = trend === \"increasing\" && growthRate > 1;\n        const recommendations = [];\n        if (hasPotentialLeak) {\n          recommendations.push(\"Memory usage is increasing rapidly\");\n          recommendations.push(\"Check for unclosed intervals/timeouts\");\n          recommendations.push(\"Review event listener cleanup\");\n          recommendations.push(\"Consider implementing object pooling\");\n        }\n        if (newest.heapUsed / newest.heapTotal > 0.8) {\n          recommendations.push(\"Heap usage is high (>80%)\");\n        }\n        return {\n          hasPotentialLeak,\n          trend,\n          growth: Math.round(growthRate * 100) / 100,\n          recommendations\n        };\n      }\n      /**\n       * 获取内存使用历史\n       */\n      getMemoryHistory() {\n        return this.snapshots.map((snapshot) => ({\n          timestamp: snapshot.timestamp,\n          heapUsed: snapshot.heapUsed,\n          heapTotal: snapshot.heapTotal,\n          usage: Math.round(snapshot.heapUsed / snapshot.heapTotal * 100)\n        }));\n      }\n      /**\n       * 清理监控数据\n       */\n      clear() {\n        this.snapshots = [];\n      }\n      /**\n       * 销毁检测器\n       */\n      destroy() {\n        this.stopMonitoring();\n        this.clear();\n      }\n    }\n    class ReferenceTracker {\n      constructor() {\n        this.refs = /* @__PURE__ */ new WeakMap();\n        this.objects = /* @__PURE__ */ new Set();\n        this.trackedRefs = /* @__PURE__ */ new Map();\n        this.nextId = 1;\n      }\n      /**\n       * 添加对象引用\n       */\n      addReference(obj) {\n        const count = this.refs.get(obj) || 0;\n        this.refs.set(obj, count + 1);\n        this.objects.add(obj);\n      }\n      /**\n       * 跟踪引用 (测试期望的方法名)\n       */\n      trackReference(obj, type) {\n        this.addReference(obj);\n        const id = `ref_${this.nextId++}`;\n        this.trackedRefs.set(id, { obj, type });\n        return id;\n      }\n      /**\n       * 移除对象引用\n       */\n      removeReference(obj) {\n        const count = this.refs.get(obj) || 0;\n        if (count > 1) {\n          this.refs.set(obj, count - 1);\n        } else {\n          this.refs.delete(obj);\n          this.objects.delete(obj);\n        }\n      }\n      /**\n       * 释放引用（通过ID）\n       */\n      releaseReference(id) {\n        const refInfo = this.trackedRefs.get(id);\n        if (refInfo) {\n          this.removeReference(refInfo.obj);\n          this.trackedRefs.delete(id);\n        }\n      }\n      /**\n       * 检查是否被跟踪\n       */\n      isTracked(id) {\n        return this.trackedRefs.has(id);\n      }\n      /**\n       * 获取引用数量\n       */\n      getReferenceCount() {\n        return this.trackedRefs.size;\n      }\n      /**\n       * 获取引用计数\n       */\n      getRefCount(obj) {\n        return this.refs.get(obj) || 0;\n      }\n      /**\n       * 查找悬垂引用\n       */\n      findDanglingReferences() {\n        const danglingRefs = [];\n        for (const [id, refInfo] of this.trackedRefs.entries()) {\n          if (!this.refs.has(refInfo.obj)) {\n            danglingRefs.push(id);\n          }\n        }\n        return danglingRefs;\n      }\n      /**\n       * 查找潜在的循环引用\n       */\n      findPotentialLeaks() {\n        const potentialLeaks = [];\n        for (const obj of this.objects) {\n          const count = this.refs.get(obj) || 0;\n          if (count > 5) {\n            potentialLeaks.push(obj);\n          }\n        }\n        return potentialLeaks;\n      }\n      /**\n       * 获取统计信息\n       */\n      getStats() {\n        const typeStats = {};\n        let totalReferences = 0;\n        for (const refInfo of this.trackedRefs.values()) {\n          totalReferences++;\n          const type = refInfo.type || \"unknown\";\n          typeStats[type] = (typeStats[type] || 0) + 1;\n        }\n        return {\n          totalReferences,\n          typeStats\n        };\n      }\n      /**\n       * 清理跟踪数据\n       */\n      clear() {\n        this.refs = /* @__PURE__ */ new WeakMap();\n        this.objects.clear();\n        this.trackedRefs.clear();\n      }\n    }\n    class GlobalMemoryManager {\n      constructor() {\n        this.resourceManager = new ResourceManager();\n        this.leakDetector = new MemoryLeakDetector();\n        this.referenceTracker = new ReferenceTracker();\n        this.timerManager = new TimerManager();\n        this.listenerManager = new ListenerManager();\n      }\n      static getInstance() {\n        if (!this.instance) {\n          this.instance = new GlobalMemoryManager();\n        }\n        return this.instance;\n      }\n      /**\n       * 检查是否正在监控\n       */\n      isMonitoring() {\n        return this.leakDetector.isMonitoring();\n      }\n      /**\n       * 开始监控\n       */\n      startMonitoring() {\n        this.leakDetector.startMonitoring();\n      }\n      /**\n       * 停止监控\n       */\n      stopMonitoring() {\n        this.leakDetector.stopMonitoring();\n      }\n      /**\n       * 注册资源\n       */\n      registerResource(resource, cleanup, group) {\n        return this.resourceManager.register(resource, cleanup, group);\n      }\n      /**\n       * 注册资源清理\n       */\n      registerCleanup(cleanup) {\n        this.resourceManager.register({}, () => cleanup());\n      }\n      /**\n       * 创建受管理的定时器\n       */\n      setTimeout(callback, delay) {\n        return this.timerManager.setTimeout(callback, delay);\n      }\n      /**\n       * 创建受管理的间隔器\n       */\n      setInterval(callback, interval) {\n        return this.timerManager.setInterval(callback, interval);\n      }\n      /**\n       * 清除间隔器\n       */\n      clearInterval(timer) {\n        clearInterval(timer);\n      }\n      /**\n       * 添加受管理的事件监听器\n       */\n      addEventListener(target, type, listener, options) {\n        this.listenerManager.addEventListener(target, type, listener, options);\n      }\n      /**\n       * 获取内存健康报告\n       */\n      getHealthReport() {\n        return {\n          memory: this.leakDetector.detectLeaks(),\n          resources: this.resourceManager.getStats(),\n          potentialLeaks: this.referenceTracker.findPotentialLeaks().length\n        };\n      }\n      /**\n       * 强制垃圾回收（如果可用）\n       */\n      forceGC() {\n        if (typeof globalThis.global !== \"undefined\" && globalThis.global.gc) {\n          globalThis.global.gc();\n        } else if (typeof window !== \"undefined\" && window.gc) {\n          window.gc();\n        } else {\n          console.warn(\"Garbage collection is not available\");\n        }\n      }\n      /**\n       * 清理所有资源\n       */\n      cleanup() {\n        this.resourceManager.cleanup();\n        this.timerManager.clearAll();\n        this.listenerManager.removeAll();\n      }\n      /**\n       * 获取整体统计信息\n       */\n      getOverallStats() {\n        return {\n          timers: this.timerManager.getStats(),\n          listeners: this.listenerManager.getStats(),\n          resources: this.resourceManager.getStats(),\n          references: this.referenceTracker.getStats()\n        };\n      }\n      /**\n       * 销毁所有管理的资源\n       */\n      destroy() {\n        this.resourceManager.cleanup();\n        this.leakDetector.destroy();\n        this.referenceTracker.clear();\n        this.timerManager.clearAll();\n        this.listenerManager.removeAll();\n      }\n    }\n    GlobalMemoryManager.getInstance();\n\n    var LogLevel;\n    (function(LogLevel2) {\n      LogLevel2[LogLevel2[\"TRACE\"] = 0] = \"TRACE\";\n      LogLevel2[LogLevel2[\"DEBUG\"] = 1] = \"DEBUG\";\n      LogLevel2[LogLevel2[\"INFO\"] = 2] = \"INFO\";\n      LogLevel2[LogLevel2[\"WARN\"] = 3] = \"WARN\";\n      LogLevel2[LogLevel2[\"ERROR\"] = 4] = \"ERROR\";\n      LogLevel2[LogLevel2[\"FATAL\"] = 5] = \"FATAL\";\n    })(LogLevel || (LogLevel = {}));\n    const LogLevelNames = {\n      [LogLevel.TRACE]: \"TRACE\",\n      [LogLevel.DEBUG]: \"DEBUG\",\n      [LogLevel.INFO]: \"INFO\",\n      [LogLevel.WARN]: \"WARN\",\n      [LogLevel.ERROR]: \"ERROR\",\n      [LogLevel.FATAL]: \"FATAL\"\n    };\n    class ConsoleLogHandler {\n      constructor(minLevel = LogLevel.INFO) {\n        this.minLevel = minLevel;\n        this.colors = {\n          [LogLevel.TRACE]: \"\\x1B[90m\",\n          // 灰色\n          [LogLevel.DEBUG]: \"\\x1B[36m\",\n          // 青色\n          [LogLevel.INFO]: \"\\x1B[32m\",\n          // 绿色\n          [LogLevel.WARN]: \"\\x1B[33m\",\n          // 黄色\n          [LogLevel.ERROR]: \"\\x1B[31m\",\n          // 红色\n          [LogLevel.FATAL]: \"\\x1B[35m\"\n          // 紫色\n        };\n        this.resetColor = \"\\x1B[0m\";\n      }\n      shouldHandle(level) {\n        return level >= this.minLevel;\n      }\n      getName() {\n        return \"ConsoleLogHandler\";\n      }\n      handle(entry) {\n        if (!this.shouldHandle(entry.level))\n          return;\n        const color = this.colors[entry.level];\n        const levelName = LogLevelNames[entry.level];\n        const timestamp = new Date(entry.timestamp).toISOString();\n        const prefix = `${color}[${timestamp}] ${levelName}${this.resetColor}`;\n        const context = entry.context ? ` [${this.formatContext(entry.context)}]` : \"\";\n        const message = `${prefix}${context} ${entry.message}`;\n        const consoleMethods = {\n          [LogLevel.TRACE]: \"trace\",\n          [LogLevel.DEBUG]: \"debug\",\n          [LogLevel.INFO]: \"info\",\n          [LogLevel.WARN]: \"warn\",\n          [LogLevel.ERROR]: \"error\",\n          [LogLevel.FATAL]: \"error\"\n        };\n        const consoleMethod = consoleMethods[entry.level];\n        const consoleFunction = console[consoleMethod];\n        if (entry.data !== void 0) {\n          consoleFunction(message, entry.data);\n        } else {\n          consoleFunction(message);\n        }\n        if (entry.level >= LogLevel.ERROR && entry.stack) {\n          console.error(\"Stack trace:\", entry.stack);\n        }\n      }\n      formatContext(context) {\n        const parts = [];\n        if (context.module)\n          parts.push(`${context.module}`);\n        if (context.function)\n          parts.push(`${context.function}()`);\n        if (context.userId)\n          parts.push(`user:${context.userId}`);\n        if (context.requestId)\n          parts.push(`req:${context.requestId.substring(0, 8)}`);\n        return parts.join(\"|\");\n      }\n    }\n    class MemoryLogHandler {\n      constructor(maxSize = 1e3, minLevel = LogLevel.TRACE) {\n        this.minLevel = minLevel;\n        this.logs = [];\n        this.maxSize = maxSize;\n      }\n      shouldHandle(level) {\n        return level >= this.minLevel;\n      }\n      getName() {\n        return \"MemoryLogHandler\";\n      }\n      handle(entry) {\n        if (!this.shouldHandle(entry.level))\n          return;\n        this.logs.push(entry);\n        if (this.logs.length > this.maxSize) {\n          this.logs.splice(0, this.logs.length - this.maxSize);\n        }\n      }\n      getLogs(filter) {\n        let filteredLogs = this.logs;\n        if (filter) {\n          if (filter.level !== void 0) {\n            filteredLogs = filteredLogs.filter((log) => log.level >= filter.level);\n          }\n          if (filter.module) {\n            filteredLogs = filteredLogs.filter((log) => log.context?.module === filter.module);\n          }\n          if (filter.since) {\n            filteredLogs = filteredLogs.filter((log) => log.timestamp >= filter.since);\n          }\n          if (filter.limit) {\n            filteredLogs = filteredLogs.slice(-filter.limit);\n          }\n        }\n        return filteredLogs;\n      }\n      clear() {\n        this.logs = [];\n      }\n      export() {\n        return JSON.stringify(this.logs, null, 2);\n      }\n    }\n    class ErrorTracker {\n      constructor() {\n        this.errorReports = /* @__PURE__ */ new Map();\n        this.maxReports = 1e3;\n        this.listeners = [];\n        if (typeof window !== \"undefined\") {\n          window.addEventListener(\"error\", (event) => {\n            this.captureError(event.error, {\n              module: \"global\",\n              metadata: {\n                filename: event.filename,\n                lineno: event.lineno,\n                colno: event.colno\n              }\n            });\n          });\n          window.addEventListener(\"unhandledrejection\", (event) => {\n            this.captureError(event.reason, {\n              module: \"promise\",\n              metadata: { type: \"unhandledrejection\" }\n            });\n          });\n        }\n      }\n      captureError(error, context) {\n        const errorInfo = this.extractErrorInfo(error);\n        const fingerprint = this.generateFingerprint(errorInfo, context);\n        let report = this.errorReports.get(fingerprint);\n        const now = Date.now();\n        if (report) {\n          report.count++;\n          report.lastOccurrence = now;\n          report.context = { ...report.context, ...context };\n        } else {\n          report = {\n            id: this.generateId(),\n            timestamp: now,\n            message: errorInfo.message,\n            stack: errorInfo.stack,\n            context,\n            fingerprint,\n            count: 1,\n            firstOccurrence: now,\n            lastOccurrence: now,\n            userAgent: typeof navigator !== \"undefined\" ? navigator.userAgent : void 0,\n            url: typeof window !== \"undefined\" ? window.location.href : void 0,\n            additionalData: errorInfo.additionalData\n          };\n          this.errorReports.set(fingerprint, report);\n          if (this.errorReports.size > this.maxReports) {\n            const oldestKey = this.errorReports.keys().next().value;\n            if (oldestKey) {\n              this.errorReports.delete(oldestKey);\n            }\n          }\n        }\n        this.notifyListeners(report);\n        return report;\n      }\n      extractErrorInfo(error) {\n        if (error instanceof Error) {\n          return {\n            message: error.message,\n            stack: error.stack,\n            additionalData: {\n              name: error.name,\n              ...error\n              // 获取额外属性\n            }\n          };\n        }\n        if (typeof error === \"string\") {\n          return { message: error };\n        }\n        if (typeof error === \"object\" && error !== null) {\n          return {\n            message: error.message || \"Unknown object error\",\n            additionalData: error\n          };\n        }\n        return {\n          message: String(error),\n          additionalData: { originalValue: error }\n        };\n      }\n      generateFingerprint(errorInfo, context) {\n        const parts = [\n          errorInfo.message,\n          context?.module,\n          context?.function\n        ].filter(Boolean);\n        return this.simpleHash(parts.join(\"|\"));\n      }\n      simpleHash(str) {\n        let hash = 0;\n        for (let i = 0; i < str.length; i++) {\n          const char = str.charCodeAt(i);\n          hash = (hash << 5) - hash + char;\n          hash = hash & hash;\n        }\n        return Math.abs(hash).toString(16);\n      }\n      generateId() {\n        return `err_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;\n      }\n      notifyListeners(report) {\n        this.listeners.forEach((listener) => {\n          try {\n            listener(report);\n          } catch (error) {\n            console.error(\"Error in error tracker listener:\", error);\n          }\n        });\n      }\n      onError(listener) {\n        this.listeners.push(listener);\n        return () => {\n          const index = this.listeners.indexOf(listener);\n          if (index > -1) {\n            this.listeners.splice(index, 1);\n          }\n        };\n      }\n      getReports(options) {\n        let reports = Array.from(this.errorReports.values());\n        if (options?.since) {\n          reports = reports.filter((r) => r.lastOccurrence >= options.since);\n        }\n        if (options?.minCount) {\n          reports = reports.filter((r) => r.count >= options.minCount);\n        }\n        reports.sort((a, b) => b.lastOccurrence - a.lastOccurrence);\n        if (options?.limit) {\n          reports = reports.slice(0, options.limit);\n        }\n        return reports;\n      }\n      clearReports() {\n        this.errorReports.clear();\n      }\n      exportReports() {\n        return JSON.stringify(Array.from(this.errorReports.values()), null, 2);\n      }\n    }\n    class EnhancedLogger {\n      constructor() {\n        this.handlers = [];\n        this.context = {};\n        this.errorTracker = new ErrorTracker();\n        this.addHandler(new ConsoleLogHandler());\n      }\n      addHandler(handler) {\n        this.handlers.push(handler);\n        return this;\n      }\n      removeHandler(handlerName) {\n        this.handlers = this.handlers.filter((h) => h.getName() !== handlerName);\n        return this;\n      }\n      setContext(context) {\n        this.context = { ...this.context, ...context };\n        return this;\n      }\n      createChild(context) {\n        const child = new EnhancedLogger();\n        child.handlers = [...this.handlers];\n        child.context = { ...this.context, ...context };\n        child.errorTracker = this.errorTracker;\n        return child;\n      }\n      log(level, message, data, additionalContext) {\n        const entry = {\n          id: this.generateLogId(),\n          timestamp: Date.now(),\n          level,\n          message,\n          data,\n          context: { ...this.context, ...additionalContext },\n          stack: level >= LogLevel.ERROR ? this.captureStackTrace() : void 0\n        };\n        if (level >= LogLevel.ERROR) {\n          entry.fingerprint = this.generateErrorFingerprint(message, entry.context);\n        }\n        this.handlers.forEach((handler) => {\n          try {\n            handler.handle(entry);\n          } catch (error) {\n            console.error(`Error in log handler ${handler.getName()}:`, error);\n          }\n        });\n        if (level >= LogLevel.ERROR) {\n          this.errorTracker.captureError(new Error(message), entry.context);\n        }\n      }\n      trace(message, data, context) {\n        this.log(LogLevel.TRACE, message, data, context);\n      }\n      debug(message, data, context) {\n        this.log(LogLevel.DEBUG, message, data, context);\n      }\n      info(message, data, context) {\n        this.log(LogLevel.INFO, message, data, context);\n      }\n      warn(message, data, context) {\n        this.log(LogLevel.WARN, message, data, context);\n      }\n      error(message, error, context) {\n        let errorData = error;\n        let stackTrace = this.captureStackTrace();\n        if (error instanceof Error) {\n          errorData = {\n            name: error.name,\n            message: error.message,\n            stack: error.stack\n          };\n          stackTrace = error.stack || this.captureStackTrace();\n        }\n        const entry = {\n          id: this.generateLogId(),\n          timestamp: Date.now(),\n          level: LogLevel.ERROR,\n          message,\n          data: errorData,\n          context: { ...this.context, ...context },\n          stack: stackTrace,\n          fingerprint: this.generateErrorFingerprint(message, { ...this.context, ...context })\n        };\n        this.handlers.forEach((handler) => {\n          try {\n            handler.handle(entry);\n          } catch (handlerError) {\n            console.error(`Error in log handler ${handler.getName()}:`, handlerError);\n          }\n        });\n        this.errorTracker.captureError(error || new Error(message), entry.context);\n      }\n      fatal(message, error, context) {\n        this.log(LogLevel.FATAL, message, error, context);\n        this.errorTracker.captureError(error || new Error(message), { ...this.context, ...context });\n      }\n      // 性能日志\n      time(label, context) {\n        const startTime = Date.now();\n        this.debug(`Timer started: ${label}`, void 0, context);\n        return () => {\n          const duration = Date.now() - startTime;\n          this.info(`Timer ended: ${label}`, { duration }, context);\n        };\n      }\n      // 异步操作包装\n      async withLogging(operation, fn, context) {\n        const timer = this.time(`async:${operation}`, context);\n        try {\n          this.debug(`Starting async operation: ${operation}`, void 0, context);\n          const result = await fn();\n          this.debug(`Completed async operation: ${operation}`, void 0, context);\n          return result;\n        } catch (error) {\n          this.error(`Failed async operation: ${operation}`, error, context);\n          throw error;\n        } finally {\n          timer();\n        }\n      }\n      // 获取错误追踪器\n      getErrorTracker() {\n        return this.errorTracker;\n      }\n      // 获取内存处理器的日志\n      getMemoryLogs() {\n        const memoryHandler = this.handlers.find((h) => h instanceof MemoryLogHandler);\n        return memoryHandler ? memoryHandler.getLogs() : [];\n      }\n      generateLogId() {\n        return `log_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;\n      }\n      captureStackTrace() {\n        const stack = new Error(\"Stack trace\").stack;\n        if (!stack)\n          return \"\";\n        const lines = stack.split(\"\\n\");\n        const relevantLines = lines.slice(3);\n        return relevantLines.join(\"\\n\");\n      }\n      generateErrorFingerprint(message, context) {\n        const parts = [\n          message,\n          context?.module,\n          context?.function\n        ].filter(Boolean);\n        return this.simpleHash(parts.join(\"|\"));\n      }\n      simpleHash(str) {\n        let hash = 0;\n        for (let i = 0; i < str.length; i++) {\n          const char = str.charCodeAt(i);\n          hash = (hash << 5) - hash + char;\n          hash = hash & hash;\n        }\n        return Math.abs(hash).toString(16);\n      }\n      destroy() {\n        this.handlers.forEach((handler) => {\n          if (handler.destroy) {\n            handler.destroy();\n          }\n        });\n        this.handlers = [];\n      }\n    }\n    new EnhancedLogger();\n\n    class ConfigManagerImpl {\n      constructor(initialConfig = {}, logger) {\n        this.config = {};\n        this.watchers = /* @__PURE__ */ new Map();\n        this.snapshots = [];\n        this.environment = \"development\";\n        this.maxSnapshots = 10;\n        this.config = { ...initialConfig };\n        this.logger = logger;\n        this.environment = this.detectEnvironment();\n        this.createSnapshot();\n        this.logger?.info(\"ConfigManager initialized\", {\n          environment: this.environment,\n          keys: Object.keys(this.config).length\n        });\n      }\n      // 基础操作\n      get(path, defaultValue) {\n        const value = getNestedValue(this.config, path, defaultValue);\n        return value;\n      }\n      set(path, value) {\n        const oldValue = this.get(path);\n        if (this.schema) {\n          const validation = this.validatePath(path, value);\n          if (!validation.valid) {\n            throw new Error(`Configuration validation failed for \"${path}\": ${validation.errors.join(\", \")}`);\n          }\n        }\n        setNestedValue(this.config, path, value);\n        this.triggerWatchers(path, value, oldValue);\n        this.logger?.debug(\"Configuration updated\", { path, value, oldValue });\n      }\n      has(path) {\n        return getNestedValue(this.config, path) !== void 0;\n      }\n      remove(path) {\n        const oldValue = this.get(path);\n        this.deleteNestedValue(this.config, path);\n        this.triggerWatchers(path, void 0, oldValue);\n        this.logger?.debug(\"Configuration removed\", { path, oldValue });\n      }\n      clear() {\n        const oldConfig = { ...this.config };\n        this.config = {};\n        for (const path of Object.keys(oldConfig)) {\n          this.triggerWatchers(path, void 0, oldConfig[path]);\n        }\n        this.logger?.info(\"Configuration cleared\");\n      }\n      // 配置合并\n      merge(newConfig) {\n        const oldConfig = { ...this.config };\n        this.deepMerge(this.config, newConfig);\n        this.triggerMergeWatchers(oldConfig, this.config);\n        this.logger?.info(\"Configuration merged\", {\n          newKeys: Object.keys(newConfig).length\n        });\n      }\n      reset(path) {\n        if (path) {\n          if (this.schema) {\n            const defaultValue = this.getDefaultValue(path);\n            if (defaultValue !== void 0) {\n              this.set(path, defaultValue);\n            } else {\n              this.remove(path);\n            }\n          } else {\n            this.remove(path);\n          }\n        } else {\n          this.clear();\n          if (this.schema) {\n            this.config = this.getDefaultConfig();\n          }\n        }\n        this.logger?.info(\"Configuration reset\", { path });\n      }\n      // 环境管理\n      setEnvironment(env) {\n        const oldEnv = this.environment;\n        this.environment = env;\n        this.logger?.info(\"Environment changed\", { from: oldEnv, to: env });\n      }\n      getEnvironment() {\n        return this.environment;\n      }\n      // 配置验证\n      validate(schema) {\n        const targetSchema = schema || this.schema;\n        if (!targetSchema) {\n          return { valid: true, errors: [], warnings: [] };\n        }\n        return this.validateConfig(this.config, targetSchema);\n      }\n      setSchema(schema) {\n        this.schema = schema;\n        const validation = this.validate();\n        if (!validation.valid) {\n          this.logger?.warn(\"Current configuration is invalid after schema update\", {\n            errors: validation.errors,\n            warnings: validation.warnings\n          });\n        }\n        this.logger?.info(\"Configuration schema updated\");\n      }\n      getSchema() {\n        return this.schema;\n      }\n      // 配置监听\n      watch(path, callback) {\n        if (!this.watchers.has(path)) {\n          this.watchers.set(path, []);\n        }\n        this.watchers.get(path).push(callback);\n        return () => {\n          this.unwatch(path, callback);\n        };\n      }\n      unwatch(path, callback) {\n        const callbacks = this.watchers.get(path);\n        if (!callbacks)\n          return;\n        if (callback) {\n          const index = callbacks.indexOf(callback);\n          if (index > -1) {\n            callbacks.splice(index, 1);\n          }\n          if (callbacks.length === 0) {\n            this.watchers.delete(path);\n          }\n        } else {\n          this.watchers.delete(path);\n        }\n      }\n      // 持久化\n      async save() {\n        try {\n          const data = JSON.stringify({\n            config: this.config,\n            environment: this.environment,\n            timestamp: Date.now()\n          });\n          if (typeof localStorage !== \"undefined\") {\n            localStorage.setItem(\"engine-config\", data);\n          }\n          this.logger?.debug(\"Configuration saved to storage\");\n        } catch (error) {\n          this.logger?.error(\"Failed to save configuration\", error);\n          throw error;\n        }\n      }\n      async load() {\n        try {\n          if (typeof localStorage === \"undefined\") {\n            return;\n          }\n          const data = localStorage.getItem(\"engine-config\");\n          if (!data) {\n            return;\n          }\n          const parsed = JSON.parse(data);\n          this.config = parsed.config || {};\n          this.environment = parsed.environment || this.environment;\n          this.logger?.debug(\"Configuration loaded from storage\");\n        } catch (error) {\n          this.logger?.error(\"Failed to load configuration\", error);\n          throw error;\n        }\n      }\n      enableAutoSave(interval = 3e4) {\n        this.disableAutoSave();\n        this.autoSaveInterval = setInterval(() => {\n          this.save().catch((error) => {\n            this.logger?.error(\"Auto-save failed\", error);\n          });\n        }, interval);\n        this.logger?.info(\"Auto-save enabled\", { interval });\n      }\n      disableAutoSave() {\n        if (this.autoSaveInterval) {\n          clearInterval(this.autoSaveInterval);\n          this.autoSaveInterval = void 0;\n          this.logger?.info(\"Auto-save disabled\");\n        }\n      }\n      // 配置快照\n      createSnapshot() {\n        const snapshot = {\n          timestamp: Date.now(),\n          config: JSON.parse(JSON.stringify(this.config)),\n          environment: this.environment,\n          version: \"1.0.0\"\n          // 可以从package.json获取\n        };\n        this.snapshots.unshift(snapshot);\n        if (this.snapshots.length > this.maxSnapshots) {\n          this.snapshots = this.snapshots.slice(0, this.maxSnapshots);\n        }\n        this.logger?.debug(\"Configuration snapshot created\");\n        return snapshot;\n      }\n      restoreSnapshot(snapshot) {\n        const oldConfig = { ...this.config };\n        this.config = JSON.parse(JSON.stringify(snapshot.config));\n        this.environment = snapshot.environment;\n        this.triggerMergeWatchers(oldConfig, this.config);\n        this.logger?.info(\"Configuration restored from snapshot\", {\n          timestamp: snapshot.timestamp\n        });\n      }\n      getSnapshots() {\n        return [...this.snapshots];\n      }\n      // 配置统计\n      getStats() {\n        const totalWatchers = Array.from(this.watchers.values()).reduce((sum, array) => sum + array.length, 0);\n        const memoryUsage = JSON.stringify(this.config).length;\n        const lastSnapshot = this.snapshots[0];\n        return {\n          totalKeys: this.getAllKeys().length,\n          watchers: totalWatchers,\n          snapshots: this.snapshots.length,\n          lastModified: lastSnapshot?.timestamp || 0,\n          memoryUsage: `${(memoryUsage / 1024).toFixed(2)} KB`\n        };\n      }\n      // 配置导入导出\n      export(format = \"json\") {\n        const data = {\n          config: this.config,\n          environment: this.environment,\n          timestamp: Date.now()\n        };\n        if (format === \"json\") {\n          return JSON.stringify(data, null, 2);\n        } else {\n          return this.toYAML(data);\n        }\n      }\n      import(data, format = \"json\") {\n        try {\n          let parsed;\n          if (format === \"json\") {\n            parsed = JSON.parse(data);\n          } else {\n            parsed = this.fromYAML(data);\n          }\n          if (parsed.config) {\n            this.merge(parsed.config);\n          }\n          if (parsed.environment && typeof parsed.environment === \"string\") {\n            this.setEnvironment(parsed.environment);\n          }\n          this.logger?.info(\"Configuration imported\", { format });\n        } catch (error) {\n          this.logger?.error(\"Failed to import configuration\", error);\n          throw error;\n        }\n      }\n      // 命名空间\n      namespace(name) {\n        return new NamespacedConfigManager(this, name);\n      }\n      // 私有方法\n      detectEnvironment() {\n        try {\n          const nodeProcess = require(\"node:process\");\n          if (typeof nodeProcess !== \"undefined\" && nodeProcess.env) {\n            const nodeEnv = nodeProcess.env.NODE_ENV;\n            if (nodeEnv === \"production\") {\n              return \"production\";\n            }\n            if (nodeEnv === \"test\") {\n              return \"test\";\n            }\n          }\n          if (typeof globalThis !== \"undefined\" && globalThis.__vitest__ !== void 0) {\n            return \"test\";\n          }\n          return \"development\";\n        } catch {\n          return \"development\";\n        }\n      }\n      triggerWatchers(path, newValue, oldValue) {\n        const callbacks = this.watchers.get(path);\n        if (callbacks) {\n          callbacks.forEach((callback) => {\n            try {\n              callback(newValue, oldValue, path);\n            } catch (error) {\n              this.logger?.error(\"Error in config watcher callback\", {\n                path,\n                error\n              });\n            }\n          });\n        }\n        const pathParts = path.split(\".\");\n        for (let i = pathParts.length - 1; i > 0; i--) {\n          const parentPath = pathParts.slice(0, i).join(\".\");\n          const parentCallbacks = this.watchers.get(parentPath);\n          if (parentCallbacks) {\n            const parentNewValue = this.get(parentPath);\n            const parentOldValue = this.get(parentPath);\n            parentCallbacks.forEach((callback) => {\n              try {\n                callback(parentNewValue, parentOldValue, parentPath);\n              } catch (error) {\n                this.logger?.error(\"Error in parent config watcher callback\", {\n                  path: parentPath,\n                  error\n                });\n              }\n            });\n          }\n        }\n      }\n      triggerMergeWatchers(oldConfig, newConfig) {\n        const allKeys = /* @__PURE__ */ new Set([\n          ...this.getAllKeysFromObject(oldConfig),\n          ...this.getAllKeysFromObject(newConfig)\n        ]);\n        for (const key of allKeys) {\n          const oldValue = getNestedValue(oldConfig, key);\n          const newValue = getNestedValue(newConfig, key);\n          if (JSON.stringify(oldValue) !== JSON.stringify(newValue)) {\n            this.triggerWatchers(key, newValue, oldValue);\n          }\n        }\n      }\n      deleteNestedValue(obj, path) {\n        const keys = path.split(\".\");\n        let current = obj;\n        for (let i = 0; i < keys.length - 1; i++) {\n          const key = keys[i];\n          if (!(key in current) || !isObject(current[key])) {\n            return;\n          }\n          current = current[key];\n        }\n        delete current[keys[keys.length - 1]];\n      }\n      deepMerge(target, source) {\n        for (const key in source) {\n          if (source[key] && isObject(source[key])) {\n            if (!target[key] || !isObject(target[key])) {\n              target[key] = {};\n            }\n            this.deepMerge(target[key], source[key]);\n          } else {\n            target[key] = source[key];\n          }\n        }\n      }\n      validateConfig(config, schema, basePath = \"\") {\n        const errors = [];\n        const warnings = [];\n        for (const [key, schemaItem] of Object.entries(schema)) {\n          const fullPath = basePath ? `${basePath}.${key}` : key;\n          const value = getNestedValue(config, fullPath);\n          if (schemaItem.required && value === void 0) {\n            errors.push(`Required field \"${fullPath}\" is missing`);\n            continue;\n          }\n          if (value === void 0) {\n            continue;\n          }\n          if (!this.validateType(value, schemaItem.type)) {\n            errors.push(`Field \"${fullPath}\" has invalid type. Expected ${schemaItem.type}, got ${typeof value}`);\n            continue;\n          }\n          if (schemaItem.validator && !schemaItem.validator(value)) {\n            errors.push(`Field \"${fullPath}\" failed custom validation`);\n            continue;\n          }\n          if (schemaItem.type === \"object\" && schemaItem.children && isObject(value)) {\n            const childResult = this.validateConfig(config, schemaItem.children, fullPath);\n            errors.push(...childResult.errors);\n            warnings.push(...childResult.warnings);\n          }\n        }\n        return { valid: errors.length === 0, errors, warnings };\n      }\n      validatePath(path, value) {\n        if (!this.schema) {\n          return { valid: true, errors: [], warnings: [] };\n        }\n        const pathParts = path.split(\".\");\n        let currentSchema = this.schema;\n        for (const part of pathParts) {\n          if (!currentSchema[part]) {\n            return { valid: true, errors: [], warnings: [] };\n          }\n          const schemaItem = currentSchema[part];\n          if (part === pathParts[pathParts.length - 1]) {\n            if (!this.validateType(value, schemaItem.type)) {\n              return {\n                valid: false,\n                errors: [\n                  `Invalid type. Expected ${schemaItem.type}, got ${typeof value}`\n                ],\n                warnings: []\n              };\n            }\n            if (schemaItem.validator && !schemaItem.validator(value)) {\n              return {\n                valid: false,\n                errors: [\"Failed custom validation\"],\n                warnings: []\n              };\n            }\n            return { valid: true, errors: [], warnings: [] };\n          }\n          if (schemaItem.children) {\n            currentSchema = schemaItem.children;\n          } else {\n            return { valid: true, errors: [], warnings: [] };\n          }\n        }\n        return { valid: true, errors: [], warnings: [] };\n      }\n      validateType(value, expectedType) {\n        switch (expectedType) {\n          case \"string\":\n            return typeof value === \"string\";\n          case \"number\":\n            return typeof value === \"number\" && !Number.isNaN(value);\n          case \"boolean\":\n            return typeof value === \"boolean\";\n          case \"object\":\n            return isObject(value);\n          case \"array\":\n            return Array.isArray(value);\n          default:\n            return true;\n        }\n      }\n      getDefaultValue(path) {\n        if (!this.schema)\n          return void 0;\n        const pathParts = path.split(\".\");\n        let currentSchema = this.schema;\n        for (const part of pathParts) {\n          if (!currentSchema[part]) {\n            return void 0;\n          }\n          const schemaItem = currentSchema[part];\n          if (part === pathParts[pathParts.length - 1]) {\n            return schemaItem.default;\n          }\n          if (schemaItem.children) {\n            currentSchema = schemaItem.children;\n          } else {\n            return void 0;\n          }\n        }\n        return void 0;\n      }\n      getDefaultConfig() {\n        if (!this.schema)\n          return {};\n        const config = {};\n        this.buildDefaultConfig(config, this.schema);\n        return config;\n      }\n      buildDefaultConfig(config, schema, basePath = \"\") {\n        for (const [key, schemaItem] of Object.entries(schema)) {\n          const fullPath = basePath ? `${basePath}.${key}` : key;\n          if (schemaItem.default !== void 0) {\n            setNestedValue(config, fullPath, schemaItem.default);\n          }\n          if (schemaItem.children) {\n            this.buildDefaultConfig(config, schemaItem.children, fullPath);\n          }\n        }\n      }\n      getAllKeys() {\n        return this.getAllKeysFromObject(this.config);\n      }\n      getAllKeysFromObject(obj, prefix = \"\") {\n        const keys = [];\n        for (const key in obj) {\n          const fullKey = prefix ? `${prefix}.${key}` : key;\n          keys.push(fullKey);\n          if (isObject(obj[key])) {\n            keys.push(...this.getAllKeysFromObject(obj[key], fullKey));\n          }\n        }\n        return keys;\n      }\n      toYAML(obj, indent = 0) {\n        const spaces = \"  \".repeat(indent);\n        let result = \"\";\n        for (const [key, value] of Object.entries(obj)) {\n          if (isObject(value)) {\n            result += `${spaces}${key}:\n${this.toYAML(value, indent + 1)}`;\n          } else if (Array.isArray(value)) {\n            result += `${spaces}${key}:\n`;\n            value.forEach((item) => {\n              result += `${spaces}  - ${item}\n`;\n            });\n          } else {\n            result += `${spaces}${key}: ${value}\n`;\n          }\n        }\n        return result;\n      }\n      fromYAML(yamlString) {\n        const lines = yamlString.split(\"\\n\").filter((line) => line.trim());\n        const result = {};\n        lines.forEach((line) => {\n          const colonIndex = line.indexOf(\":\");\n          if (colonIndex === -1)\n            return;\n          const beforeColon = line.slice(0, colonIndex);\n          const afterColon = line.slice(colonIndex + 1);\n          const key = beforeColon.trim();\n          const value = afterColon.trim();\n          if (key && value !== void 0) {\n            try {\n              result[key] = JSON.parse(value);\n            } catch {\n              result[key] = value;\n            }\n          }\n        });\n        return result;\n      }\n    }\n    class NamespacedConfigManager {\n      constructor(parent, namespaceName) {\n        this.parent = parent;\n        this.namespaceName = namespaceName;\n      }\n      getKey(key) {\n        return `${this.namespaceName}.${key}`;\n      }\n      // 基础操作\n      get(key, defaultValue) {\n        return this.parent.get(this.getKey(key), defaultValue);\n      }\n      set(key, value) {\n        this.parent.set(this.getKey(key), value);\n      }\n      has(key) {\n        return this.parent.has(this.getKey(key));\n      }\n      remove(key) {\n        this.parent.remove(this.getKey(key));\n      }\n      clear() {\n        this.parent.remove(this.namespaceName);\n      }\n      // 配置合并\n      merge(config) {\n        const namespacedConfig = {};\n        for (const [key, value] of Object.entries(config)) {\n          namespacedConfig[this.getKey(key)] = value;\n        }\n        this.parent.merge(namespacedConfig);\n      }\n      reset(path) {\n        if (path) {\n          this.parent.reset(this.getKey(path));\n        } else {\n          this.clear();\n        }\n      }\n      // 环境管理\n      setEnvironment(env) {\n        this.parent.setEnvironment(env);\n      }\n      getEnvironment() {\n        return this.parent.getEnvironment();\n      }\n      // 配置验证\n      validate(schema) {\n        return this.parent.validate(schema);\n      }\n      setSchema(schema) {\n        this.parent.setSchema(schema);\n      }\n      getSchema() {\n        return this.parent.getSchema();\n      }\n      // 配置监听\n      watch(key, callback) {\n        return this.parent.watch(this.getKey(key), callback);\n      }\n      unwatch(key, callback) {\n        this.parent.unwatch(this.getKey(key), callback);\n      }\n      // 持久化\n      async save() {\n        return this.parent.save();\n      }\n      async load() {\n        return this.parent.load();\n      }\n      enableAutoSave(interval) {\n        this.parent.enableAutoSave(interval);\n      }\n      disableAutoSave() {\n        this.parent.disableAutoSave();\n      }\n      // 配置快照\n      createSnapshot() {\n        return this.parent.createSnapshot();\n      }\n      restoreSnapshot(snapshot) {\n        this.parent.restoreSnapshot(snapshot);\n      }\n      getSnapshots() {\n        return this.parent.getSnapshots();\n      }\n      // 配置统计\n      getStats() {\n        return this.parent.getStats();\n      }\n      // 配置导入导出\n      export(format) {\n        return this.parent.export(format);\n      }\n      import(data, format) {\n        this.parent.import(data, format);\n      }\n      // 命名空间\n      namespace(name) {\n        return this.parent.namespace(`${this.namespaceName}.${name}`);\n      }\n    }\n    function createConfigManager(initialConfig, logger) {\n      return new ConfigManagerImpl(initialConfig, logger);\n    }\n    const defaultConfigSchema = {\n      app: {\n        type: \"object\",\n        required: true,\n        default: {\n          name: \"Vue Engine App\",\n          version: \"1.0.0\"\n        },\n        children: {\n          name: {\n            type: \"string\",\n            required: true,\n            default: \"Vue Engine App\",\n            description: \"\\u5E94\\u7528\\u540D\\u79F0\"\n          },\n          version: {\n            type: \"string\",\n            required: true,\n            default: \"1.0.0\",\n            description: \"\\u5E94\\u7528\\u7248\\u672C\"\n          },\n          description: {\n            type: \"string\",\n            description: \"\\u5E94\\u7528\\u63CF\\u8FF0\"\n          },\n          author: {\n            type: \"string\",\n            description: \"\\u5E94\\u7528\\u4F5C\\u8005\"\n          },\n          homepage: {\n            type: \"string\",\n            description: \"\\u5E94\\u7528\\u4E3B\\u9875\"\n          }\n        }\n      },\n      environment: {\n        type: \"string\",\n        required: true,\n        default: \"development\",\n        validator: (value) => typeof value === \"string\" && [\"development\", \"production\", \"test\"].includes(value),\n        description: \"\\u8FD0\\u884C\\u73AF\\u5883\"\n      },\n      debug: {\n        type: \"boolean\",\n        required: true,\n        default: true,\n        description: \"\\u662F\\u5426\\u542F\\u7528\\u8C03\\u8BD5\\u6A21\\u5F0F\"\n      },\n      features: {\n        type: \"object\",\n        required: true,\n        default: {\n          enableHotReload: true,\n          enableDevTools: true,\n          enablePerformanceMonitoring: true,\n          enableErrorReporting: true,\n          enableSecurityProtection: true,\n          enableCaching: true,\n          enableNotifications: true\n        },\n        children: {\n          enableHotReload: {\n            type: \"boolean\",\n            default: true,\n            description: \"\\u662F\\u5426\\u542F\\u7528\\u70ED\\u91CD\\u8F7D\"\n          },\n          enableDevTools: {\n            type: \"boolean\",\n            default: true,\n            description: \"\\u662F\\u5426\\u542F\\u7528\\u5F00\\u53D1\\u5DE5\\u5177\"\n          },\n          enablePerformanceMonitoring: {\n            type: \"boolean\",\n            default: true,\n            description: \"\\u662F\\u5426\\u542F\\u7528\\u6027\\u80FD\\u76D1\\u63A7\"\n          },\n          enableErrorReporting: {\n            type: \"boolean\",\n            default: true,\n            description: \"\\u662F\\u5426\\u542F\\u7528\\u9519\\u8BEF\\u62A5\\u544A\"\n          },\n          enableSecurityProtection: {\n            type: \"boolean\",\n            default: true,\n            description: \"\\u662F\\u5426\\u542F\\u7528\\u5B89\\u5168\\u9632\\u62A4\"\n          },\n          enableCaching: {\n            type: \"boolean\",\n            default: true,\n            description: \"\\u662F\\u5426\\u542F\\u7528\\u7F13\\u5B58\"\n          },\n          enableNotifications: {\n            type: \"boolean\",\n            default: true,\n            description: \"\\u662F\\u5426\\u542F\\u7528\\u901A\\u77E5\"\n          }\n        }\n      }\n    };\n\n    class EnvironmentManagerImpl {\n      constructor(logger) {\n        this.changeListeners = [];\n        this.featureListeners = /* @__PURE__ */ new Map();\n        this.logger = logger;\n        this.environmentInfo = this.detectEnvironment();\n        this.adaptation = this.createDefaultAdaptation();\n        this.setupEnvironmentListeners();\n        this.logger?.info(\"Environment manager initialized\", {\n          environment: this.environmentInfo.environment,\n          platform: this.environmentInfo.platform,\n          browser: this.environmentInfo.browser.name,\n          device: this.environmentInfo.device.type\n        });\n      }\n      detect() {\n        return { ...this.environmentInfo };\n      }\n      getEnvironment() {\n        return this.environmentInfo.environment;\n      }\n      getPlatform() {\n        return this.environmentInfo.platform;\n      }\n      getBrowser() {\n        return {\n          name: this.environmentInfo.browser.name,\n          version: this.environmentInfo.browser.version\n        };\n      }\n      getDevice() {\n        return {\n          type: this.environmentInfo.device.type,\n          isMobile: this.environmentInfo.device.isMobile\n        };\n      }\n      hasFeature(feature) {\n        return this.environmentInfo.features[feature] || false;\n      }\n      getFeatures() {\n        return { ...this.environmentInfo.features };\n      }\n      checkCompatibility(requirements) {\n        if (requirements.browser) {\n          const browserReq = requirements.browser?.[this.environmentInfo.browser.name];\n          if (browserReq && !this.isVersionCompatible(this.environmentInfo.browser.version, browserReq)) {\n            return false;\n          }\n        }\n        if (requirements.features && Array.isArray(requirements.features)) {\n          for (const feature of requirements.features) {\n            if (!this.hasFeature(feature)) {\n              return false;\n            }\n          }\n        }\n        return true;\n      }\n      getAdaptation() {\n        return { ...this.adaptation };\n      }\n      setAdaptation(adaptation) {\n        this.adaptation = {\n          ...this.adaptation,\n          ...adaptation,\n          fallbacks: { ...this.adaptation.fallbacks, ...adaptation.fallbacks },\n          optimizations: {\n            ...this.adaptation.optimizations,\n            ...adaptation.optimizations\n          },\n          compatibility: {\n            ...this.adaptation.compatibility,\n            ...adaptation.compatibility\n          }\n        };\n        this.logger?.debug(\"Environment adaptation updated\", adaptation);\n      }\n      adaptForEnvironment(env) {\n        const adaptation = {\n          fallbacks: {\n            storage: env.features.hasLocalStorage ? \"memory\" : \"cookie\",\n            animation: env.device.isMobile ? \"css\" : \"js\",\n            networking: env.features.hasServiceWorkers ? \"fetch\" : \"xhr\"\n          },\n          optimizations: {\n            enableLazyLoading: env.device.isMobile,\n            enableCodeSplitting: env.environment === \"production\",\n            enableImageOptimization: env.device.isMobile,\n            enableCaching: env.environment === \"production\",\n            maxConcurrentRequests: env.device.isMobile ? 4 : 8\n          },\n          compatibility: {\n            enablePolyfills: env.browser.name === \"ie\",\n            supportedBrowsers: [\"chrome\", \"firefox\", \"safari\", \"edge\"],\n            minimumVersions: {\n              chrome: \"80\",\n              firefox: \"75\",\n              safari: \"13\",\n              edge: \"80\"\n            }\n          }\n        };\n        return adaptation;\n      }\n      getPerformanceInfo() {\n        return { ...this.environmentInfo.performance };\n      }\n      monitorPerformance(callback) {\n        const monitor = () => {\n          const perfInfo = this.detectPerformanceInfo();\n          callback(perfInfo);\n        };\n        setInterval(monitor, 5e3);\n        monitor();\n      }\n      onEnvironmentChange(callback) {\n        this.changeListeners.push(callback);\n        return () => {\n          const index = this.changeListeners.indexOf(callback);\n          if (index > -1) {\n            this.changeListeners.splice(index, 1);\n          }\n        };\n      }\n      onFeatureChange(feature, callback) {\n        if (!this.featureListeners.has(feature)) {\n          this.featureListeners.set(feature, []);\n        }\n        this.featureListeners.get(feature).push(callback);\n        return () => {\n          const listeners = this.featureListeners.get(feature);\n          if (listeners) {\n            const index = listeners.indexOf(callback);\n            if (index > -1) {\n              listeners.splice(index, 1);\n            }\n          }\n        };\n      }\n      // 私有方法\n      detectEnvironment() {\n        return {\n          environment: this.detectEnv(),\n          platform: this.detectPlatform(),\n          browser: this.detectBrowser(),\n          device: this.detectDevice(),\n          features: this.detectFeatures(),\n          performance: this.detectPerformanceInfo(),\n          screen: this.detectScreenInfo(),\n          timezone: this.detectTimezone()\n        };\n      }\n      detectEnv() {\n        try {\n          const nodeProcess = require(\"node:process\");\n          if (typeof nodeProcess !== \"undefined\" && nodeProcess.env) {\n            const nodeEnv = nodeProcess.env.NODE_ENV;\n            if (nodeEnv === \"production\")\n              return \"production\";\n            if (nodeEnv === \"test\")\n              return \"test\";\n          }\n          if (typeof globalThis !== \"undefined\" && globalThis.__vitest__ !== void 0) {\n            return \"test\";\n          }\n          if (typeof window !== \"undefined\" && window.__karma__ !== void 0) {\n            return \"test\";\n          }\n          return \"development\";\n        } catch {\n          return \"development\";\n        }\n      }\n      detectPlatform() {\n        if (typeof window !== \"undefined\") {\n          const w = window;\n          const processKey = \"process\";\n          if (w.require && w[processKey]?.type) {\n            return \"electron\";\n          }\n          if (typeof globalThis.importScripts === \"function\") {\n            return \"webworker\";\n          }\n          return \"browser\";\n        }\n        try {\n          const nodeProcess = require(\"node:process\");\n          if (typeof nodeProcess !== \"undefined\" && nodeProcess.versions?.node) {\n            return \"node\";\n          }\n          return \"unknown\";\n        } catch {\n          return \"unknown\";\n        }\n      }\n      detectBrowser() {\n        if (typeof navigator === \"undefined\") {\n          return { name: \"unknown\", version: \"\", userAgent: \"\" };\n        }\n        const userAgent = navigator.userAgent;\n        let name = \"unknown\";\n        let version = \"\";\n        if (userAgent.includes(\"Chrome\") && !userAgent.includes(\"Edg\")) {\n          name = \"chrome\";\n          const match = userAgent.match(/Chrome\\/(\\d+)/);\n          version = match ? match[1] : \"\";\n        } else if (userAgent.includes(\"Edg\")) {\n          name = \"edge\";\n          const match = userAgent.match(/Edg\\/(\\d+)/);\n          version = match ? match[1] : \"\";\n        } else if (userAgent.includes(\"Firefox\")) {\n          name = \"firefox\";\n          const match = userAgent.match(/Firefox\\/(\\d+)/);\n          version = match ? match[1] : \"\";\n        } else if (userAgent.includes(\"Safari\") && !userAgent.includes(\"Chrome\")) {\n          name = \"safari\";\n          const match = userAgent.match(/Version\\/(\\d+)/);\n          version = match ? match[1] : \"\";\n        } else if (userAgent.includes(\"MSIE\") || userAgent.includes(\"Trident\")) {\n          name = \"ie\";\n          const match = userAgent.match(/(?:MSIE |rv:)(\\d+)/);\n          version = match ? match[1] : \"\";\n        } else if (userAgent.includes(\"Opera\") || userAgent.includes(\"OPR\")) {\n          name = \"opera\";\n          const match = userAgent.match(/(?:Opera|OPR)\\/(\\d+)/);\n          version = match ? match[1] : \"\";\n        }\n        return { name, version, userAgent };\n      }\n      detectDevice() {\n        if (typeof navigator === \"undefined\") {\n          return {\n            type: \"unknown\",\n            isMobile: false,\n            isTablet: false,\n            isDesktop: false,\n            isTouchDevice: false\n          };\n        }\n        const userAgent = navigator.userAgent;\n        const isMobile = /Android|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(userAgent);\n        const isTablet = /iPad|Android(?=.*Tablet)|Tablet/i.test(userAgent);\n        const isTouchDevice = \"ontouchstart\" in window || navigator.maxTouchPoints > 0;\n        let type = \"desktop\";\n        if (isTablet) {\n          type = \"tablet\";\n        } else if (isMobile) {\n          type = \"mobile\";\n        }\n        return {\n          type,\n          isMobile,\n          isTablet,\n          isDesktop: type === \"desktop\",\n          isTouchDevice\n        };\n      }\n      detectFeatures() {\n        const hasWindow = typeof window !== \"undefined\";\n        const hasNavigator = typeof navigator !== \"undefined\";\n        return {\n          // Storage APIs\n          hasLocalStorage: hasWindow && \"localStorage\" in window,\n          hasSessionStorage: hasWindow && \"sessionStorage\" in window,\n          hasIndexedDB: hasWindow && \"indexedDB\" in window,\n          // Worker APIs\n          hasWebWorkers: hasWindow && \"Worker\" in window,\n          hasServiceWorkers: hasNavigator && \"serviceWorker\" in navigator,\n          // Graphics APIs\n          hasWebGL: hasWindow && this.checkWebGL(),\n          hasWebGL2: hasWindow && this.checkWebGL2(),\n          hasWebAssembly: typeof WebAssembly !== \"undefined\",\n          // Network APIs\n          hasOnlineDetection: hasNavigator && \"onLine\" in navigator,\n          hasNetworkInformation: hasNavigator && \"connection\" in navigator,\n          // Performance APIs\n          hasPerformanceAPI: hasWindow && \"performance\" in window,\n          hasIntersectionObserver: hasWindow && \"IntersectionObserver\" in window,\n          hasMutationObserver: hasWindow && \"MutationObserver\" in window,\n          hasResizeObserver: hasWindow && \"ResizeObserver\" in window,\n          // Media APIs\n          hasMediaDevices: hasNavigator && \"mediaDevices\" in navigator,\n          hasGetUserMedia: hasNavigator && \"getUserMedia\" in navigator,\n          // Other APIs\n          hasClipboardAPI: hasNavigator && \"clipboard\" in navigator,\n          hasNotificationAPI: hasWindow && \"Notification\" in window,\n          hasGeolocationAPI: hasNavigator && \"geolocation\" in navigator\n        };\n      }\n      detectPerformanceInfo() {\n        const info = {};\n        if (typeof performance !== \"undefined\" && \"memory\" in performance) {\n          const memory = performance.memory;\n          info.memory = {\n            used: memory.usedJSHeapSize,\n            total: memory.totalJSHeapSize,\n            limit: memory.jsHeapSizeLimit\n          };\n        }\n        if (typeof navigator !== \"undefined\" && \"connection\" in navigator) {\n          const connection = navigator.connection;\n          info.connection = {\n            effectiveType: connection.effectiveType || \"unknown\",\n            downlink: connection.downlink || 0,\n            rtt: connection.rtt || 0,\n            saveData: connection.saveData || false\n          };\n        }\n        return info;\n      }\n      detectScreenInfo() {\n        if (typeof screen === \"undefined\") {\n          return {\n            width: 0,\n            height: 0,\n            availWidth: 0,\n            availHeight: 0,\n            colorDepth: 0,\n            pixelRatio: 1\n          };\n        }\n        return {\n          width: screen.width,\n          height: screen.height,\n          availWidth: screen.availWidth,\n          availHeight: screen.availHeight,\n          colorDepth: screen.colorDepth,\n          pixelRatio: typeof window !== \"undefined\" ? window.devicePixelRatio : 1,\n          orientation: typeof screen.orientation !== \"undefined\" ? screen.orientation.type : void 0\n        };\n      }\n      detectTimezone() {\n        const now = /* @__PURE__ */ new Date();\n        const january = new Date(now.getFullYear(), 0, 1);\n        const july = new Date(now.getFullYear(), 6, 1);\n        const offset = -now.getTimezoneOffset();\n        const dst = offset !== -january.getTimezoneOffset() || offset !== -july.getTimezoneOffset();\n        return {\n          name: Intl.DateTimeFormat().resolvedOptions().timeZone,\n          offset,\n          dst\n        };\n      }\n      checkWebGL() {\n        try {\n          if (typeof document === \"undefined\")\n            return false;\n          const canvas = document.createElement(\"canvas\");\n          return !!(canvas.getContext(\"webgl\") || canvas.getContext(\"experimental-webgl\"));\n        } catch {\n          return false;\n        }\n      }\n      checkWebGL2() {\n        try {\n          if (typeof document === \"undefined\")\n            return false;\n          const canvas = document.createElement(\"canvas\");\n          return !!canvas.getContext(\"webgl2\");\n        } catch {\n          return false;\n        }\n      }\n      createDefaultAdaptation() {\n        return {\n          fallbacks: {\n            storage: \"memory\",\n            animation: \"css\",\n            networking: \"fetch\"\n          },\n          optimizations: {\n            enableLazyLoading: false,\n            enableCodeSplitting: false,\n            enableImageOptimization: false,\n            enableCaching: true,\n            maxConcurrentRequests: 6\n          },\n          compatibility: {\n            enablePolyfills: false,\n            supportedBrowsers: [\"chrome\", \"firefox\", \"safari\", \"edge\"],\n            minimumVersions: {\n              chrome: \"80\",\n              firefox: \"75\",\n              safari: \"13\",\n              edge: \"80\"\n            }\n          }\n        };\n      }\n      setupEnvironmentListeners() {\n        if (typeof window === \"undefined\")\n          return;\n        window.addEventListener(\"online\", () => this.handleEnvironmentChange());\n        window.addEventListener(\"offline\", () => this.handleEnvironmentChange());\n        if (screen.orientation) {\n          screen.orientation.addEventListener(\"change\", () => this.handleEnvironmentChange());\n        }\n        window.addEventListener(\"resize\", () => this.handleEnvironmentChange());\n      }\n      handleEnvironmentChange() {\n        const newInfo = this.detectEnvironment();\n        const hasChanged = JSON.stringify(newInfo) !== JSON.stringify(this.environmentInfo);\n        if (hasChanged) {\n          this.environmentInfo = newInfo;\n          this.changeListeners.forEach((callback) => {\n            try {\n              callback(newInfo);\n            } catch (error) {\n              this.logger?.error(\"Error in environment change callback\", error);\n            }\n          });\n        }\n      }\n      isVersionCompatible(current, required) {\n        const currentParts = current.split(\".\").map(Number);\n        const requiredParts = required.split(\".\").map(Number);\n        for (let i = 0; i < Math.max(currentParts.length, requiredParts.length); i++) {\n          const currentPart = currentParts[i] || 0;\n          const requiredPart = requiredParts[i] || 0;\n          if (currentPart > requiredPart)\n            return true;\n          if (currentPart < requiredPart)\n            return false;\n        }\n        return true;\n      }\n    }\n    function createEnvironmentManager(logger) {\n      return new EnvironmentManagerImpl(logger);\n    }\n\n    var ErrorCategory;\n    (function(ErrorCategory2) {\n      ErrorCategory2[\"NETWORK\"] = \"network\";\n      ErrorCategory2[\"COMPONENT\"] = \"component\";\n      ErrorCategory2[\"PLUGIN\"] = \"plugin\";\n      ErrorCategory2[\"STATE\"] = \"state\";\n      ErrorCategory2[\"SECURITY\"] = \"security\";\n      ErrorCategory2[\"PERFORMANCE\"] = \"performance\";\n      ErrorCategory2[\"UNKNOWN\"] = \"unknown\";\n    })(ErrorCategory || (ErrorCategory = {}));\n    class ErrorManagerImpl {\n      constructor(logger) {\n        this.logger = logger;\n        this.errorHandlers = /* @__PURE__ */ new Set();\n        this.errors = [];\n        this.maxErrors = 100;\n        this.errorCounts = /* @__PURE__ */ new Map();\n        this.recoveryStrategies = /* @__PURE__ */ new Map();\n        this.lastErrorTime = 0;\n        this.errorBurst = 0;\n        this.setupDefaultRecoveryStrategies();\n      }\n      onError(handler) {\n        this.errorHandlers.add(handler);\n      }\n      offError(handler) {\n        this.errorHandlers.delete(handler);\n      }\n      captureError(error, component, info) {\n        const errorInfo = {\n          message: error.message,\n          stack: error.stack,\n          component,\n          info,\n          timestamp: Date.now(),\n          level: \"error\"\n        };\n        this.detectErrorBurst();\n        const category = this.categorizeError(errorInfo);\n        this.updateErrorStats(errorInfo, category);\n        this.addError(errorInfo);\n        this.attemptRecovery(errorInfo);\n        this.notifyHandlers(errorInfo);\n      }\n      addError(errorInfo) {\n        this.errors.unshift(errorInfo);\n        if (this.errors.length > this.maxErrors) {\n          this.errors = this.errors.slice(0, this.maxErrors);\n        }\n      }\n      notifyHandlers(errorInfo) {\n        for (const handler of this.errorHandlers) {\n          try {\n            handler(errorInfo);\n          } catch (handlerError) {\n            console.error(\"Error in error handler:\", handlerError);\n          }\n        }\n      }\n      getErrors() {\n        return [...this.errors];\n      }\n      hasErrors() {\n        return this.errors.length > 0;\n      }\n      clearErrors() {\n        this.errors = [];\n      }\n      // 设置最大错误数量\n      setMaxErrors(max) {\n        this.maxErrors = max;\n        if (this.errors.length > max) {\n          this.errors = this.errors.slice(0, max);\n        }\n      }\n      // 获取最大错误数量\n      getMaxErrors() {\n        return this.maxErrors;\n      }\n      // 按级别获取错误\n      getErrorsByLevel(level) {\n        return this.errors.filter((error) => error.level === level);\n      }\n      // 按时间范围获取错误\n      getErrorsByTimeRange(startTime, endTime) {\n        return this.errors.filter((error) => error.timestamp >= startTime && error.timestamp <= endTime);\n      }\n      // 获取最近的错误\n      getRecentErrors(count) {\n        return this.errors.slice(0, count);\n      }\n      // 搜索错误\n      searchErrors(query) {\n        const lowerQuery = query.toLowerCase();\n        return this.errors.filter((error) => error.message.toLowerCase().includes(lowerQuery) || error.stack && error.stack.toLowerCase().includes(lowerQuery) || error.info && error.info.toLowerCase().includes(lowerQuery));\n      }\n      // 获取错误统计\n      getErrorStats() {\n        const now = Date.now();\n        const hour = 60 * 60 * 1e3;\n        const day = 24 * hour;\n        const byLevel = {\n          error: 0,\n          warn: 0,\n          info: 0\n        };\n        let recent24h = 0;\n        let recentHour = 0;\n        for (const error of this.errors) {\n          byLevel[error.level]++;\n          if (now - error.timestamp <= day) {\n            recent24h++;\n          }\n          if (now - error.timestamp <= hour) {\n            recentHour++;\n          }\n        }\n        return {\n          total: this.errors.length,\n          byLevel,\n          recent24h,\n          recentHour\n        };\n      }\n      // 导出错误日志\n      exportErrors(format = \"json\") {\n        if (format === \"json\") {\n          return JSON.stringify(this.errors, null, 2);\n        } else {\n          const headers = [\"timestamp\", \"level\", \"message\", \"stack\", \"info\"];\n          const rows = this.errors.map((error) => [\n            new Date(error.timestamp).toISOString(),\n            error.level,\n            `\"${error.message.replace(/\"/g, '\"\"')}\"`,\n            `\"${(error.stack || \"\").replace(/\"/g, '\"\"')}\"`,\n            `\"${(error.info || \"\").replace(/\"/g, '\"\"')}\"`\n          ]);\n          return [headers.join(\",\"), ...rows.map((row) => row.join(\",\"))].join(\"\\n\");\n        }\n      }\n      // 创建错误报告\n      createErrorReport() {\n        const summary = this.getErrorStats();\n        const recentErrors = this.getRecentErrors(10);\n        const errorCounts = /* @__PURE__ */ new Map();\n        for (const error of this.errors) {\n          const count = errorCounts.get(error.message) || 0;\n          errorCounts.set(error.message, count + 1);\n        }\n        const topErrors = Array.from(errorCounts.entries()).sort((a, b) => b[1] - a[1]).slice(0, 5).map(([message, count]) => ({ message, count }));\n        return {\n          summary,\n          recentErrors,\n          topErrors\n        };\n      }\n      // 设置默认恢复策略\n      setupDefaultRecoveryStrategies() {\n        this.recoveryStrategies.set(\"network\", {\n          canRecover: (error) => error.message.includes(\"network\") || error.message.includes(\"fetch\"),\n          recover: async (error) => {\n            this.logger?.info(\"Attempting network error recovery\", error);\n            return new Promise((resolve) => setTimeout(() => resolve(true), 1e3));\n          },\n          priority: 1\n        });\n        this.recoveryStrategies.set(\"component\", {\n          canRecover: (error) => !!error.component,\n          recover: async (error) => {\n            this.logger?.info(\"Attempting component error recovery\", error);\n            return true;\n          },\n          priority: 2\n        });\n      }\n      // 检测错误爆发\n      detectErrorBurst() {\n        const now = Date.now();\n        const timeDiff = now - this.lastErrorTime;\n        if (timeDiff < 1e3) {\n          this.errorBurst++;\n          if (this.errorBurst > 10) {\n            this.logger?.warn(\"Error burst detected\", { count: this.errorBurst });\n          }\n        } else {\n          this.errorBurst = 1;\n        }\n        this.lastErrorTime = now;\n      }\n      // 分类错误\n      categorizeError(error) {\n        const message = error.message.toLowerCase();\n        if (message.includes(\"network\") || message.includes(\"fetch\") || message.includes(\"xhr\")) {\n          return ErrorCategory.NETWORK;\n        }\n        if (error.component) {\n          return ErrorCategory.COMPONENT;\n        }\n        if (message.includes(\"plugin\")) {\n          return ErrorCategory.PLUGIN;\n        }\n        if (message.includes(\"state\") || message.includes(\"store\")) {\n          return ErrorCategory.STATE;\n        }\n        if (message.includes(\"security\") || message.includes(\"xss\") || message.includes(\"csrf\")) {\n          return ErrorCategory.SECURITY;\n        }\n        if (message.includes(\"performance\") || message.includes(\"memory\") || message.includes(\"timeout\")) {\n          return ErrorCategory.PERFORMANCE;\n        }\n        return ErrorCategory.UNKNOWN;\n      }\n      // 更新错误统计\n      updateErrorStats(error, category) {\n        const key = `${category}:${error.message}`;\n        const count = this.errorCounts.get(key) || 0;\n        this.errorCounts.set(key, count + 1);\n        if (count > 5) {\n          this.logger?.warn(\"Frequent error detected\", {\n            category,\n            message: error.message,\n            count: count + 1\n          });\n        }\n      }\n      // 尝试自动恢复\n      async attemptRecovery(error) {\n        const strategies = Array.from(this.recoveryStrategies.values()).filter((strategy) => strategy.canRecover(error)).sort((a, b) => a.priority - b.priority);\n        for (const strategy of strategies) {\n          try {\n            const recovered = await strategy.recover(error);\n            if (recovered) {\n              this.logger?.info(\"Error recovery successful\", error);\n              return true;\n            }\n          } catch (recoveryError) {\n            this.logger?.error(\"Error recovery failed\", recoveryError);\n          }\n        }\n        return false;\n      }\n      // 获取错误分类统计\n      getCategoryStats() {\n        const stats = {};\n        for (const category of Object.values(ErrorCategory)) {\n          stats[category] = 0;\n        }\n        for (const [key, count] of this.errorCounts) {\n          const category = key.split(\":\")[0];\n          if (category in stats) {\n            stats[category] += count;\n          }\n        }\n        return stats;\n      }\n    }\n    function createErrorManager(logger) {\n      return new ErrorManagerImpl(logger);\n    }\n\n    class EventObjectPool {\n      constructor() {\n        this.pool = [];\n        this.maxSize = 100;\n      }\n      get() {\n        return this.pool.pop() || { handler: () => {\n        }, once: false, priority: 0 };\n      }\n      release(obj) {\n        if (this.pool.length < this.maxSize) {\n          obj.handler = () => {\n          };\n          obj.once = false;\n          obj.priority = 0;\n          this.pool.push(obj);\n        }\n      }\n      clear() {\n        this.pool.length = 0;\n      }\n    }\n    class EventManagerImpl {\n      constructor(logger) {\n        this.logger = logger;\n        this.events = /* @__PURE__ */ new Map();\n        this.maxListeners = 50;\n        this.sortedListenersCache = /* @__PURE__ */ new Map();\n        this.eventStats = /* @__PURE__ */ new Map();\n        this.eventPool = new EventObjectPool();\n        this.weakSortedCache = /* @__PURE__ */ new WeakMap();\n        this.maxEventStats = 1e3;\n        this.cleanupInterval = 6e4;\n        this.setupCleanupTimer();\n      }\n      setupCleanupTimer() {\n        setInterval(() => {\n          this.cleanupStats();\n          this.checkMemoryUsage();\n        }, this.cleanupInterval);\n      }\n      on(event, handler, priority = 0) {\n        this.addEventListener(String(event), handler, false, priority);\n      }\n      off(event, handler) {\n        const key = String(event);\n        if (!this.events.has(key)) {\n          return;\n        }\n        const listeners = this.events.get(key);\n        if (!handler) {\n          this.events.delete(key);\n          this.sortedListenersCache.delete(key);\n          return;\n        }\n        const index = listeners.findIndex((listener) => listener.handler === handler);\n        if (index > -1) {\n          listeners.splice(index, 1);\n          if (listeners.length === 0) {\n            this.events.delete(key);\n            this.sortedListenersCache.delete(key);\n          } else {\n            this.sortedListenersCache.delete(key);\n          }\n        }\n      }\n      emit(event, ...args) {\n        const key = String(event);\n        this.updateEventStats(key);\n        const listeners = this.events.get(key);\n        if (!listeners || listeners.length === 0) {\n          return;\n        }\n        let listenersToExecute = this.weakSortedCache.get(listeners);\n        if (!listenersToExecute) {\n          listenersToExecute = [...listeners].sort((a, b) => b.priority - a.priority);\n          this.weakSortedCache.set(listeners, listenersToExecute);\n        }\n        const removeIndexes = new Uint8Array(listenersToExecute.length);\n        let hasOnceListeners = false;\n        for (let i = 0; i < listenersToExecute.length; i++) {\n          const listener = listenersToExecute[i];\n          try {\n            listener.handler(args[0]);\n          } catch (error) {\n            if (this.logger) {\n              this.logger.error(`Error in event handler for \"${key}\":`, error);\n            } else {\n              console.error(`Error in event handler for \"${key}\":`, error);\n            }\n          }\n          if (listener.once) {\n            removeIndexes[i] = 1;\n            hasOnceListeners = true;\n          }\n        }\n        if (hasOnceListeners) {\n          this.batchRemoveIndexedListeners(key, listeners, removeIndexes);\n        }\n      }\n      once(event, handler, priority = 0) {\n        this.addEventListener(String(event), handler, true, priority);\n      }\n      addEventListener(event, handler, once, priority) {\n        if (!this.events.has(event)) {\n          this.events.set(event, []);\n        }\n        const listeners = this.events.get(event);\n        if (listeners.length >= this.maxListeners) {\n          console.warn(`MaxListenersExceededWarning: Possible EventManager memory leak detected. ${listeners.length + 1} \"${event}\" listeners added. Use setMaxListeners() to increase limit.`);\n        }\n        const listener = this.eventPool.get();\n        listener.handler = handler;\n        listener.once = once;\n        listener.priority = priority;\n        listeners.push(listener);\n        this.sortedListenersCache.delete(event);\n      }\n      // 获取事件的监听器数量\n      listenerCount(event) {\n        const listeners = this.events.get(event);\n        return listeners ? listeners.length : 0;\n      }\n      // 获取所有事件名称\n      eventNames() {\n        return Array.from(this.events.keys());\n      }\n      // 获取指定事件的所有监听器\n      listeners(event) {\n        const listeners = this.events.get(event);\n        return listeners ? listeners.map((l) => l.handler) : [];\n      }\n      // 设置最大监听器数量\n      setMaxListeners(n) {\n        this.maxListeners = n;\n      }\n      // 获取最大监听器数量\n      getMaxListeners() {\n        return this.maxListeners;\n      }\n      // 移除所有监听器\n      removeAllListeners(event) {\n        if (event) {\n          this.events.delete(event);\n          this.sortedListenersCache.delete(event);\n        } else {\n          this.events.clear();\n          this.sortedListenersCache.clear();\n        }\n      }\n      // 在指定事件前添加监听器\n      prependListener(event, handler, priority = 1e3) {\n        this.addEventListener(event, handler, false, priority);\n      }\n      /**\n       * 性能优化：更新事件统计\n       */\n      updateEventStats(event) {\n        const stats = this.eventStats.get(event);\n        const now = Date.now();\n        if (stats) {\n          stats.count++;\n          stats.lastEmit = now;\n        } else {\n          this.eventStats.set(event, { count: 1, lastEmit: now });\n        }\n      }\n      /**\n       * 新方法：按索引批量移除监听器\n       */\n      batchRemoveIndexedListeners(event, listeners, removeIndexes) {\n        for (let i = removeIndexes.length - 1; i >= 0; i--) {\n          if (removeIndexes[i] === 1) {\n            this.eventPool.release(listeners[i]);\n            listeners.splice(i, 1);\n          }\n        }\n        if (listeners.length === 0) {\n          this.events.delete(event);\n          this.sortedListenersCache.delete(event);\n        } else {\n          this.sortedListenersCache.delete(event);\n          this.weakSortedCache.delete(listeners);\n        }\n      }\n      /**\n       * 性能优化：批量移除监听器\n       */\n      batchRemoveListeners(event, listenersToRemove) {\n        const listeners = this.events.get(event);\n        if (!listeners)\n          return;\n        const removeSet = new Set(listenersToRemove.map((l) => l.handler));\n        const filteredListeners = listeners.filter((l) => {\n          if (removeSet.has(l.handler)) {\n            this.eventPool.release(l);\n            return false;\n          }\n          return true;\n        });\n        if (filteredListeners.length === 0) {\n          this.events.delete(event);\n          this.sortedListenersCache.delete(event);\n        } else {\n          this.events.set(event, filteredListeners);\n          this.sortedListenersCache.delete(event);\n          this.weakSortedCache.delete(listeners);\n        }\n      }\n      /**\n       * 性能优化：清理过期的统计数据 - 改进版\n       */\n      cleanupStats() {\n        const now = Date.now();\n        const maxAge = 3e5;\n        if (this.eventStats.size > this.maxEventStats) {\n          const sortedEvents = Array.from(this.eventStats.entries()).sort((a, b) => b[1].lastEmit - a[1].lastEmit).slice(0, this.maxEventStats - 100);\n          this.eventStats.clear();\n          for (const [event, stats] of sortedEvents) {\n            this.eventStats.set(event, stats);\n          }\n        } else {\n          for (const [event, stats] of this.eventStats.entries()) {\n            if (now - stats.lastEmit > maxAge) {\n              this.eventStats.delete(event);\n            }\n          }\n        }\n      }\n      /**\n       * 检查内存使用\n       */\n      checkMemoryUsage() {\n        const stats = this.getStats();\n        if (stats.totalListeners > 1e3) {\n          this.logger?.warn(\"High number of event listeners detected\", {\n            totalListeners: stats.totalListeners,\n            events: Object.entries(stats.events).filter(([_, count]) => count > 20).map(([event, count]) => `${event}: ${count}`)\n          });\n        }\n      }\n      /**\n       * 获取事件统计信息\n       */\n      getEventStats() {\n        return new Map(this.eventStats);\n      }\n      /**\n       * 清理所有资源 - 增强版\n       */\n      cleanup() {\n        this.events.clear();\n        this.sortedListenersCache.clear();\n        this.eventStats.clear();\n      }\n      /**\n       * 销毁方法 - 确保完全清理\n       */\n      destroy() {\n        this.events.clear();\n        this.sortedListenersCache.clear();\n        this.eventStats.clear();\n        this.eventPool.clear();\n      }\n      prependOnceListener(event, handler, priority = 1e3) {\n        this.addEventListener(event, handler, true, priority);\n      }\n      namespace(ns) {\n        return new EventNamespace(this, ns);\n      }\n      /**\n       * 新增：批量事件操作\n       * 一次性添加多个事件监听器\n       */\n      addListeners(listeners) {\n        for (const { event, handler, options } of listeners) {\n          this.addEventListener(event, handler, !!options?.once, options?.priority ?? 0);\n        }\n      }\n      /**\n       * 新增：事件管道\n       * 支持事件的链式处理\n       */\n      pipe(sourceEvent, targetEvent, transform) {\n        this.on(sourceEvent, (data) => {\n          const transformedData = transform ? transform(data) : data;\n          this.emit(targetEvent, transformedData);\n        });\n      }\n      /**\n       * 新增：条件事件监听\n       * 只有满足条件时才触发监听器\n       */\n      onWhen(event, condition, handler, options) {\n        this.addEventListener(event, (data) => {\n          if (condition(data)) {\n            handler(data);\n          }\n        }, !!options?.once, options?.priority ?? 0);\n      }\n      /**\n       * 新增：事件防抖\n       * 在指定时间内只触发一次事件\n       */\n      debounce(event, delay = 300) {\n        return new EventDebouncer(this, event, delay);\n      }\n      /**\n       * 新增：事件节流\n       * 在指定时间间隔内最多触发一次事件\n       */\n      throttle(event, interval = 300) {\n        return new EventThrottler(this, event, interval);\n      }\n      getStats() {\n        const stats = {};\n        let totalListeners = 0;\n        for (const [event, listeners] of this.events.entries()) {\n          stats[event] = listeners.length;\n          totalListeners += listeners.length;\n        }\n        return {\n          totalEvents: this.events.size,\n          totalListeners,\n          events: stats\n        };\n      }\n    }\n    const ENGINE_EVENTS = {\n      CREATED: \"engine:created\",\n      INSTALLED: \"engine:installed\",\n      MOUNTED: \"engine:mounted\",\n      UNMOUNTED: \"engine:unmounted\",\n      DESTROYED: \"engine:destroy\",\n      ERROR: \"engine:error\",\n      PLUGIN_REGISTERED: \"plugin:registered\",\n      PLUGIN_UNREGISTERED: \"plugin:unregistered\",\n      PLUGIN_ERROR: \"plugin:error\",\n      MIDDLEWARE_ADDED: \"middleware:added\",\n      MIDDLEWARE_REMOVED: \"middleware:removed\",\n      MIDDLEWARE_ERROR: \"middleware:error\",\n      STATE_CHANGED: \"state:changed\",\n      STATE_CLEARED: \"state:cleared\",\n      CONFIG_CHANGED: \"config:changed\",\n      ROUTE_CHANGED: \"route:changed\",\n      ROUTE_ERROR: \"route:error\",\n      THEME_CHANGED: \"theme:changed\",\n      LOCALE_CHANGED: \"locale:changed\"\n    };\n    class EventNamespace {\n      constructor(eventManager, namespace) {\n        this.eventManager = eventManager;\n        this.namespace = namespace;\n      }\n      getNamespacedEvent(event) {\n        return `${this.namespace}:${event}`;\n      }\n      on(event, handler, priority) {\n        this.eventManager.on(this.getNamespacedEvent(event), handler, priority ?? 0);\n      }\n      once(event, handler, priority) {\n        this.eventManager.once(this.getNamespacedEvent(event), handler, priority ?? 0);\n      }\n      emit(event, data) {\n        this.eventManager.emit(this.getNamespacedEvent(event), data);\n      }\n      off(event, handler) {\n        this.eventManager.off(this.getNamespacedEvent(event), handler);\n      }\n      clear() {\n        const namespacedPrefix = `${this.namespace}:`;\n        const eventsToRemove = [];\n        for (const event of this.eventManager.eventNames()) {\n          if (event.startsWith(namespacedPrefix)) {\n            eventsToRemove.push(event);\n          }\n        }\n        for (const event of eventsToRemove) {\n          this.eventManager.removeAllListeners(event);\n        }\n      }\n    }\n    class EventDebouncer {\n      constructor(eventManager, event, delay) {\n        this.eventManager = eventManager;\n        this.event = event;\n        this.delay = delay;\n      }\n      emit(data) {\n        this.lastArgs = data;\n        if (this.timeoutId) {\n          clearTimeout(this.timeoutId);\n        }\n        this.timeoutId = setTimeout(() => {\n          this.eventManager.emit(this.event, this.lastArgs);\n          this.timeoutId = void 0;\n        }, this.delay);\n      }\n      cancel() {\n        if (this.timeoutId) {\n          clearTimeout(this.timeoutId);\n          this.timeoutId = void 0;\n        }\n      }\n      flush() {\n        if (this.timeoutId) {\n          clearTimeout(this.timeoutId);\n          this.eventManager.emit(this.event, this.lastArgs);\n          this.timeoutId = void 0;\n        }\n      }\n    }\n    class EventThrottler {\n      constructor(eventManager, event, interval) {\n        this.eventManager = eventManager;\n        this.event = event;\n        this.interval = interval;\n        this.lastEmitTime = 0;\n      }\n      emit(data) {\n        const now = Date.now();\n        this.lastArgs = data;\n        if (now - this.lastEmitTime >= this.interval) {\n          this.eventManager.emit(this.event, data);\n          this.lastEmitTime = now;\n        } else if (!this.timeoutId) {\n          const remainingTime = this.interval - (now - this.lastEmitTime);\n          this.timeoutId = setTimeout(() => {\n            this.eventManager.emit(this.event, this.lastArgs);\n            this.lastEmitTime = Date.now();\n            this.timeoutId = void 0;\n          }, remainingTime);\n        }\n      }\n      cancel() {\n        if (this.timeoutId) {\n          clearTimeout(this.timeoutId);\n          this.timeoutId = void 0;\n        }\n      }\n    }\n    function createEventManager(logger) {\n      return new EventManagerImpl(logger);\n    }\n\n    class LifecycleManagerImpl {\n      constructor(logger) {\n        this.hooks = /* @__PURE__ */ new Map();\n        this.phaseHooks = /* @__PURE__ */ new Map();\n        this.history = [];\n        this.errorCallbacks = [];\n        this.hookIdCounter = 0;\n        this.maxHistorySize = 100;\n        this.logger = logger;\n        this.logger?.debug(\"Lifecycle manager initialized\");\n      }\n      // 钩子注册\n      /**\n       * 注册生命周期钩子。\n       * @param phase 生命周期阶段\n       * @param hook 钩子函数\n       * @param priority 优先级，越大越先执行（默认0）\n       * @returns 钩子ID\n       */\n      on(phase, hook, priority = 0) {\n        const id = this.generateHookId();\n        const hookInfo = {\n          id,\n          phase,\n          hook,\n          priority,\n          once: false,\n          registeredAt: Date.now()\n        };\n        this.hooks.set(id, hookInfo);\n        if (!this.phaseHooks.has(phase)) {\n          this.phaseHooks.set(phase, /* @__PURE__ */ new Set());\n        }\n        this.phaseHooks.get(phase).add(id);\n        this.logger?.debug(`Lifecycle hook registered`, {\n          id,\n          phase,\n          priority\n        });\n        return id;\n      }\n      /**\n       * 注册一次性生命周期钩子（执行后自动移除）。\n       */\n      once(phase, hook, priority = 0) {\n        const id = this.generateHookId();\n        const hookInfo = {\n          id,\n          phase,\n          hook,\n          priority,\n          once: true,\n          registeredAt: Date.now()\n        };\n        this.hooks.set(id, hookInfo);\n        if (!this.phaseHooks.has(phase)) {\n          this.phaseHooks.set(phase, /* @__PURE__ */ new Set());\n        }\n        this.phaseHooks.get(phase).add(id);\n        this.logger?.debug(`One-time lifecycle hook registered`, {\n          id,\n          phase,\n          priority\n        });\n        return id;\n      }\n      /**\n       * 移除指定钩子。\n       */\n      off(hookId) {\n        const hookInfo = this.hooks.get(hookId);\n        if (!hookInfo) {\n          return false;\n        }\n        this.hooks.delete(hookId);\n        const phaseHooks = this.phaseHooks.get(hookInfo.phase);\n        if (phaseHooks) {\n          phaseHooks.delete(hookId);\n          if (phaseHooks.size === 0) {\n            this.phaseHooks.delete(hookInfo.phase);\n          }\n        }\n        this.logger?.debug(`Lifecycle hook removed`, {\n          id: hookId,\n          phase: hookInfo.phase\n        });\n        return true;\n      }\n      /**\n       * 批量移除钩子，可按阶段清空。\n       * @returns 被移除的钩子数量\n       */\n      offAll(phase) {\n        let removedCount = 0;\n        if (phase) {\n          const phaseHooks = this.phaseHooks.get(phase);\n          if (phaseHooks) {\n            for (const hookId of phaseHooks) {\n              this.hooks.delete(hookId);\n              removedCount++;\n            }\n            this.phaseHooks.delete(phase);\n          }\n        } else {\n          removedCount = this.hooks.size;\n          this.hooks.clear();\n          this.phaseHooks.clear();\n        }\n        this.logger?.debug(`Lifecycle hooks removed`, {\n          phase,\n          count: removedCount\n        });\n        return removedCount;\n      }\n      // 钩子查询\n      /**\n       * 获取指定阶段的钩子（按优先级降序）。\n       */\n      getHooks(phase) {\n        const phaseHooks = this.phaseHooks.get(phase);\n        if (!phaseHooks) {\n          return [];\n        }\n        const hooks = Array.from(phaseHooks).map((id) => this.hooks.get(id)).filter(Boolean).sort((a, b) => b.priority - a.priority);\n        return hooks;\n      }\n      /**\n       * 获取所有已注册钩子（按优先级降序）。\n       */\n      getAllHooks() {\n        return Array.from(this.hooks.values()).sort((a, b) => b.priority - a.priority);\n      }\n      hasHooks(phase) {\n        const phaseHooks = this.phaseHooks.get(phase);\n        return phaseHooks ? phaseHooks.size > 0 : false;\n      }\n      /**\n       * 获取钩子数量，可选按阶段统计。\n       */\n      getHookCount(phase) {\n        if (phase) {\n          const phaseHooks = this.phaseHooks.get(phase);\n          return phaseHooks ? phaseHooks.size : 0;\n        }\n        return this.hooks.size;\n      }\n      // 生命周期执行\n      /**\n       * 异步执行指定阶段的所有钩子。\n       * @returns 生命周期事件（包含执行结果与耗时）\n       */\n      async execute(phase, engine, data) {\n        const startTime = Date.now();\n        this.currentPhase = phase;\n        const context = {\n          phase,\n          timestamp: startTime,\n          engine,\n          data\n        };\n        const hooks = this.getHooks(phase);\n        let hooksExecuted = 0;\n        let error;\n        this.logger?.debug(`Executing lifecycle phase: ${phase}`, {\n          hookCount: hooks.length\n        });\n        try {\n          for (const hookInfo of hooks) {\n            try {\n              await hookInfo.hook(context);\n              hooksExecuted++;\n              if (hookInfo.once) {\n                this.off(hookInfo.id);\n              }\n            } catch (hookError) {\n              error = hookError;\n              this.logger?.error(`Error in lifecycle hook`, {\n                phase,\n                hookId: hookInfo.id,\n                error: hookError\n              });\n              this.errorCallbacks.forEach((callback) => {\n                try {\n                  callback(error, { ...context, error });\n                } catch (callbackError) {\n                  this.logger?.error(\"Error in lifecycle error callback\", callbackError);\n                }\n              });\n              if (this.isCriticalPhase(phase)) {\n                break;\n              }\n            }\n          }\n        } catch (executionError) {\n          error = executionError;\n          this.logger?.error(`Critical error during lifecycle execution`, {\n            phase,\n            error: executionError\n          });\n        }\n        const endTime = Date.now();\n        const event = {\n          phase,\n          timestamp: startTime,\n          duration: endTime - startTime,\n          success: !error,\n          error,\n          hooksExecuted,\n          data\n        };\n        this.addToHistory(event);\n        this.logger?.debug(`Lifecycle phase completed: ${phase}`, {\n          duration: event.duration,\n          success: event.success,\n          hooksExecuted\n        });\n        return event;\n      }\n      executeSync(phase, engine, data) {\n        const startTime = Date.now();\n        this.currentPhase = phase;\n        const context = {\n          phase,\n          timestamp: startTime,\n          engine,\n          data\n        };\n        const hooks = this.getHooks(phase);\n        let hooksExecuted = 0;\n        let error;\n        this.logger?.debug(`Executing lifecycle phase synchronously: ${phase}`, {\n          hookCount: hooks.length\n        });\n        try {\n          for (const hookInfo of hooks) {\n            try {\n              const result = hookInfo.hook(context);\n              if (result && typeof result.then === \"function\") {\n                this.logger?.warn(`Async hook detected in sync execution`, {\n                  phase,\n                  hookId: hookInfo.id\n                });\n              }\n              hooksExecuted++;\n              if (hookInfo.once) {\n                this.off(hookInfo.id);\n              }\n            } catch (hookError) {\n              error = hookError;\n              this.logger?.error(`Error in lifecycle hook`, {\n                phase,\n                hookId: hookInfo.id,\n                error: hookError\n              });\n              this.errorCallbacks.forEach((callback) => {\n                try {\n                  callback(error, { ...context, error });\n                } catch (callbackError) {\n                  this.logger?.error(\"Error in lifecycle error callback\", callbackError);\n                }\n              });\n              if (this.isCriticalPhase(phase)) {\n                break;\n              }\n            }\n          }\n        } catch (executionError) {\n          error = executionError;\n          this.logger?.error(`Critical error during sync lifecycle execution`, {\n            phase,\n            error: executionError\n          });\n        }\n        const endTime = Date.now();\n        const event = {\n          phase,\n          timestamp: startTime,\n          duration: endTime - startTime,\n          success: !error,\n          error,\n          hooksExecuted,\n          data\n        };\n        this.addToHistory(event);\n        this.logger?.debug(`Sync lifecycle phase completed: ${phase}`, {\n          duration: event.duration,\n          success: event.success,\n          hooksExecuted\n        });\n        return event;\n      }\n      // 生命周期状态\n      getCurrentPhase() {\n        return this.currentPhase;\n      }\n      getLastEvent() {\n        return this.history[this.history.length - 1];\n      }\n      getHistory() {\n        return [...this.history];\n      }\n      isPhaseExecuted(phase) {\n        return this.history.some((event) => event.phase === phase && event.success);\n      }\n      // 错误处理\n      onError(callback) {\n        this.errorCallbacks.push(callback);\n        return () => {\n          const index = this.errorCallbacks.indexOf(callback);\n          if (index > -1) {\n            this.errorCallbacks.splice(index, 1);\n          }\n        };\n      }\n      // 统计信息\n      getStats() {\n        const phaseStats = {};\n        for (const [phase, hooks] of this.phaseHooks) {\n          phaseStats[phase] = hooks.size;\n        }\n        const executionTimes = this.history.filter((event) => event.duration !== void 0).map((event) => event.duration);\n        const averageExecutionTime = executionTimes.length > 0 ? executionTimes.reduce((sum, time) => sum + time, 0) / executionTimes.length : 0;\n        const errorCount = this.history.filter((event) => !event.success).length;\n        return {\n          totalHooks: this.hooks.size,\n          phaseStats,\n          executionHistory: [...this.history],\n          averageExecutionTime,\n          errorCount\n        };\n      }\n      // 清理\n      clear() {\n        this.hooks.clear();\n        this.phaseHooks.clear();\n        this.errorCallbacks = [];\n        this.logger?.debug(\"Lifecycle manager cleared\");\n      }\n      reset() {\n        this.clear();\n        this.history = [];\n        this.currentPhase = void 0;\n        this.hookIdCounter = 0;\n        this.logger?.debug(\"Lifecycle manager reset\");\n      }\n      // 私有方法\n      generateHookId() {\n        return `hook_${++this.hookIdCounter}_${Date.now()}`;\n      }\n      addToHistory(event) {\n        this.history.push(event);\n        if (this.history.length > this.maxHistorySize) {\n          this.history = this.history.slice(-this.maxHistorySize);\n        }\n      }\n      isCriticalPhase(phase) {\n        const criticalPhases = [\"init\", \"mount\", \"destroy\"];\n        return criticalPhases.includes(phase);\n      }\n      // 添加缺失的方法\n      add(hook) {\n        if (hook && hook.phase && hook.handler) {\n          this.on(hook.phase, hook.handler, hook.priority || 0);\n        }\n      }\n      remove(name) {\n        this.off(name);\n      }\n      getOrder(phase) {\n        const hooks = this.getHooks(phase);\n        return hooks.sort((a, b) => (b?.priority || 0) - (a?.priority || 0)).map((h) => h?.id || \"\");\n      }\n      validate() {\n        return {\n          valid: true,\n          errors: [],\n          warnings: []\n        };\n      }\n      optimize() {\n        this.logger?.debug(\"Lifecycle hooks optimized\");\n      }\n    }\n    function createLifecycleManager(logger) {\n      return new LifecycleManagerImpl(logger);\n    }\n\n    class LoggerImpl {\n      constructor(level = \"info\") {\n        this.logs = [];\n        this.level = \"info\";\n        this.maxLogs = 1e3;\n        this.levels = {\n          debug: 0,\n          info: 1,\n          warn: 2,\n          error: 3\n        };\n        this.level = level;\n      }\n      debug(message, data) {\n        this.log(\"debug\", message, data);\n      }\n      info(message, data) {\n        this.log(\"info\", message, data);\n      }\n      warn(message, data) {\n        this.log(\"warn\", message, data);\n      }\n      error(message, data) {\n        this.log(\"error\", message, data);\n      }\n      log(level, message, data) {\n        if (this.levels[level] < this.levels[this.level]) {\n          return;\n        }\n        const entry = {\n          level,\n          message,\n          timestamp: Date.now(),\n          data\n        };\n        this.addLog(entry);\n        this.outputToConsole(entry);\n      }\n      addLog(entry) {\n        this.logs.unshift(entry);\n        if (this.logs.length > this.maxLogs) {\n          this.logs = this.logs.slice(0, this.maxLogs);\n        }\n      }\n      outputToConsole(entry) {\n        const timestamp = new Date(entry.timestamp).toISOString();\n        const prefix = `[${timestamp}] [${entry.level.toUpperCase()}]`;\n        const styles = this.getConsoleStyles(entry.level);\n        if (entry.data) {\n          console.groupCollapsed(`%c${prefix} ${entry.message}`, styles.prefix);\n          console.log(\"%cData:\", styles.data, entry.data);\n          console.groupEnd();\n        } else {\n          console.log(`%c${prefix} ${entry.message}`, styles.prefix);\n        }\n      }\n      getConsoleStyles(level) {\n        const baseStyle = \"font-weight: bold; padding: 2px 4px; border-radius: 2px;\";\n        switch (level) {\n          case \"debug\":\n            return {\n              prefix: `${baseStyle} background: #e3f2fd; color: #1976d2;`,\n              data: \"color: #1976d2;\"\n            };\n          case \"info\":\n            return {\n              prefix: `${baseStyle} background: #e8f5e8; color: #2e7d32;`,\n              data: \"color: #2e7d32;\"\n            };\n          case \"warn\":\n            return {\n              prefix: `${baseStyle} background: #fff3e0; color: #f57c00;`,\n              data: \"color: #f57c00;\"\n            };\n          case \"error\":\n            return {\n              prefix: `${baseStyle} background: #ffebee; color: #d32f2f;`,\n              data: \"color: #d32f2f;\"\n            };\n          default:\n            return {\n              prefix: baseStyle,\n              data: \"\"\n            };\n        }\n      }\n      setLevel(level) {\n        this.level = level;\n      }\n      getLevel() {\n        return this.level;\n      }\n      getLogs() {\n        return [...this.logs];\n      }\n      clearLogs() {\n        this.logs = [];\n      }\n      clear() {\n        this.clearLogs();\n      }\n      // 设置最大日志数量\n      setMaxLogs(max) {\n        this.maxLogs = max;\n        if (this.logs.length > max) {\n          this.logs = this.logs.slice(0, max);\n        }\n      }\n      // 获取最大日志数量\n      getMaxLogs() {\n        return this.maxLogs;\n      }\n      // 按级别获取日志\n      getLogsByLevel(level) {\n        return this.logs.filter((log) => log.level === level);\n      }\n      // 按时间范围获取日志\n      getLogsByTimeRange(startTime, endTime) {\n        return this.logs.filter((log) => log.timestamp >= startTime && log.timestamp <= endTime);\n      }\n      // 搜索日志\n      searchLogs(query) {\n        const lowerQuery = query.toLowerCase();\n        return this.logs.filter((log) => log.message.toLowerCase().includes(lowerQuery) || log.data && JSON.stringify(log.data).toLowerCase().includes(lowerQuery));\n      }\n      // 获取日志统计\n      getLogStats() {\n        const now = Date.now();\n        const hour = 60 * 60 * 1e3;\n        const day = 24 * hour;\n        const byLevel = {\n          debug: 0,\n          info: 0,\n          warn: 0,\n          error: 0\n        };\n        let recent24h = 0;\n        let recentHour = 0;\n        for (const log of this.logs) {\n          byLevel[log.level]++;\n          if (now - log.timestamp <= day) {\n            recent24h++;\n          }\n          if (now - log.timestamp <= hour) {\n            recentHour++;\n          }\n        }\n        return {\n          total: this.logs.length,\n          byLevel,\n          recent24h,\n          recentHour\n        };\n      }\n      // 导出日志\n      exportLogs(format = \"json\") {\n        switch (format) {\n          case \"json\":\n            return JSON.stringify(this.logs, null, 2);\n          case \"csv\": {\n            const headers = [\"timestamp\", \"level\", \"message\", \"data\"];\n            const rows = this.logs.map((log) => [\n              new Date(log.timestamp).toISOString(),\n              log.level,\n              `\"${log.message.replace(/\"/g, '\"\"')}\"`,\n              log.data ? `\"${JSON.stringify(log.data).replace(/\"/g, '\"\"')}\"` : \"\"\n            ]);\n            return [headers.join(\",\"), ...rows.map((row) => row.join(\",\"))].join(\"\\n\");\n          }\n          case \"txt\":\n            return this.logs.map((log) => {\n              const timestamp = new Date(log.timestamp).toISOString();\n              const dataStr = log.data ? ` | Data: ${JSON.stringify(log.data)}` : \"\";\n              return `[${timestamp}] [${log.level.toUpperCase()}] ${log.message}${dataStr}`;\n            }).join(\"\\n\");\n          default:\n            return \"\";\n        }\n      }\n      // 创建子日志器\n      createChild(prefix) {\n        return new ChildLogger(this, prefix);\n      }\n      // 创建命名空间日志器\n      namespace(ns) {\n        return this.createChild(`[${ns}]`);\n      }\n    }\n    class ChildLogger {\n      constructor(parent, prefix) {\n        this.parent = parent;\n        this.prefix = prefix;\n      }\n      debug(message, data) {\n        this.parent.debug(`${this.prefix} ${message}`, data);\n      }\n      info(message, data) {\n        this.parent.info(`${this.prefix} ${message}`, data);\n      }\n      warn(message, data) {\n        this.parent.warn(`${this.prefix} ${message}`, data);\n      }\n      error(message, data) {\n        this.parent.error(`${this.prefix} ${message}`, data);\n      }\n      setLevel(level) {\n        this.parent.setLevel(level);\n      }\n      getLevel() {\n        return this.parent.getLevel();\n      }\n      getLogs() {\n        return this.parent.getLogs();\n      }\n      clearLogs() {\n        this.parent.clearLogs();\n      }\n      clear() {\n        this.parent.clear();\n      }\n      setMaxLogs(max) {\n        this.parent.setMaxLogs(max);\n      }\n      getMaxLogs() {\n        return this.parent.getMaxLogs();\n      }\n    }\n    function createLogger(level = \"info\") {\n      return new LoggerImpl(level);\n    }\n\n    class MiddlewareManagerImpl {\n      constructor(_logger) {\n        this.middleware = [];\n      }\n      use(middleware) {\n        const existingIndex = this.middleware.findIndex((m) => m.name === middleware.name);\n        if (existingIndex > -1) {\n          this.middleware[existingIndex] = middleware;\n        } else {\n          this.middleware.push(middleware);\n        }\n        this.middleware.sort((a, b) => {\n          const priorityA = a.priority ?? 100;\n          const priorityB = b.priority ?? 100;\n          return priorityA - priorityB;\n        });\n      }\n      remove(name) {\n        const index = this.middleware.findIndex((m) => m.name === name);\n        if (index > -1) {\n          this.middleware.splice(index, 1);\n        }\n      }\n      async execute(contextOrName, context) {\n        if (typeof contextOrName === \"string\") {\n          const name = contextOrName;\n          const ctx = context;\n          const middleware = this.middleware.find((m) => m.name === name);\n          if (!middleware) {\n            throw new Error(`Middleware \"${name}\" not found`);\n          }\n          const result = { processed: false };\n          const next = async () => {\n            result.processed = true;\n          };\n          await middleware.handler(ctx, next);\n          return result;\n        } else {\n          const ctx = contextOrName;\n          let index = 0;\n          const next = async () => {\n            if (index >= this.middleware.length) {\n              return;\n            }\n            const middleware = this.middleware[index++];\n            try {\n              await middleware.handler(ctx, next);\n            } catch (error) {\n              ctx.error = error;\n              throw error;\n            }\n          };\n          await next();\n        }\n      }\n      // 获取所有中间件\n      getAll() {\n        return [...this.middleware];\n      }\n      // 获取指定名称的中间件\n      get(name) {\n        return this.middleware.find((m) => m.name === name);\n      }\n      // 检查中间件是否存在\n      has(name) {\n        return this.middleware.some((m) => m.name === name);\n      }\n      // 清空所有中间件\n      clear() {\n        this.middleware = [];\n      }\n      // 获取中间件数量\n      size() {\n        return this.middleware.length;\n      }\n      // 获取中间件执行顺序\n      getExecutionOrder() {\n        return this.middleware.map((m) => m.name);\n      }\n    }\n    function createMiddlewareManager(logger) {\n      return new MiddlewareManagerImpl(logger);\n    }\n\n    class NotificationStyleManager {\n      constructor() {\n        this.themes = {\n          light: {\n            background: \"#ffffff\",\n            text: \"#1f2937\",\n            border: \"#e5e7eb\",\n            shadow: \"0 10px 25px rgba(0, 0, 0, 0.1)\",\n            success: \"#10b981\",\n            error: \"#ef4444\",\n            warning: \"#f59e0b\",\n            info: \"#3b82f6\"\n          },\n          dark: {\n            background: \"#1f2937\",\n            text: \"#f9fafb\",\n            border: \"#374151\",\n            shadow: \"0 10px 25px rgba(0, 0, 0, 0.3)\",\n            success: \"#34d399\",\n            error: \"#f87171\",\n            warning: \"#fbbf24\",\n            info: \"#60a5fa\"\n          },\n          auto: {\n            background: \"var(--notification-bg, #ffffff)\",\n            text: \"var(--notification-text, #1f2937)\",\n            border: \"var(--notification-border, #e5e7eb)\",\n            shadow: \"var(--notification-shadow, 0 10px 25px rgba(0, 0, 0, 0.1))\",\n            success: \"var(--notification-success, #10b981)\",\n            error: \"var(--notification-error, #ef4444)\",\n            warning: \"var(--notification-warning, #f59e0b)\",\n            info: \"var(--notification-info, #3b82f6)\"\n          }\n        };\n        this.currentTheme = \"light\";\n      }\n      /**\n       * 获取容器位置样式\n       */\n      getContainerStyles(position) {\n        const baseStyles = {\n          position: \"fixed\",\n          zIndex: \"9999\",\n          pointerEvents: \"none\",\n          maxWidth: \"400px\",\n          width: \"100%\"\n        };\n        switch (position) {\n          case \"top-left\":\n            return {\n              ...baseStyles,\n              top: \"20px\",\n              left: \"20px\"\n            };\n          case \"top-center\":\n            return {\n              ...baseStyles,\n              top: \"20px\",\n              left: \"50%\",\n              transform: \"translateX(-50%)\"\n            };\n          case \"top-right\":\n            return {\n              ...baseStyles,\n              top: \"20px\",\n              right: \"20px\"\n            };\n          case \"bottom-left\":\n            return {\n              ...baseStyles,\n              bottom: \"20px\",\n              left: \"20px\"\n            };\n          case \"bottom-center\":\n            return {\n              ...baseStyles,\n              bottom: \"20px\",\n              left: \"50%\",\n              transform: \"translateX(-50%)\"\n            };\n          case \"bottom-right\":\n            return {\n              ...baseStyles,\n              bottom: \"20px\",\n              right: \"20px\"\n            };\n          default:\n            return {\n              ...baseStyles,\n              top: \"20px\",\n              right: \"20px\"\n            };\n        }\n      }\n      /**\n       * 获取通知样式\n       */\n      getNotificationStyles(type = \"info\", theme = this.currentTheme) {\n        const colors = this.themes[theme];\n        const typeColor = colors[type];\n        return {\n          container: this.getContainerStyles(\"top-right\"),\n          notification: {\n            background: colors.background,\n            color: colors.text,\n            borderRadius: \"12px\",\n            boxShadow: colors.shadow,\n            marginBottom: \"12px\",\n            padding: \"16px\",\n            pointerEvents: \"auto\",\n            position: \"relative\",\n            borderLeft: `4px solid ${typeColor}`,\n            maxWidth: \"100%\",\n            wordWrap: \"break-word\",\n            fontSize: \"14px\",\n            lineHeight: \"1.5\",\n            fontFamily: '-apple-system, BlinkMacSystemFont, \"Segoe UI\", Roboto, sans-serif',\n            border: `1px solid ${colors.border}`,\n            backdropFilter: \"blur(10px)\",\n            transition: \"all 0.2s ease\"\n          },\n          icon: {\n            flexShrink: \"0\",\n            width: \"20px\",\n            height: \"20px\",\n            color: typeColor,\n            marginRight: \"12px\"\n          },\n          content: {\n            display: \"flex\",\n            alignItems: \"flex-start\",\n            gap: \"12px\",\n            flex: \"1\",\n            minWidth: \"0\"\n          },\n          title: {\n            fontWeight: \"600\",\n            fontSize: \"14px\",\n            color: colors.text,\n            marginBottom: \"4px\",\n            lineHeight: \"1.4\"\n          },\n          message: {\n            fontSize: \"13px\",\n            color: colors.text,\n            opacity: \"0.8\",\n            lineHeight: \"1.4\",\n            wordBreak: \"break-word\"\n          },\n          closeButton: {\n            position: \"absolute\",\n            top: \"8px\",\n            right: \"8px\",\n            background: \"none\",\n            border: \"none\",\n            fontSize: \"18px\",\n            color: colors.text,\n            opacity: \"0.5\",\n            cursor: \"pointer\",\n            padding: \"0\",\n            width: \"20px\",\n            height: \"20px\",\n            display: \"flex\",\n            alignItems: \"center\",\n            justifyContent: \"center\",\n            borderRadius: \"4px\",\n            transition: \"opacity 0.2s ease\"\n          },\n          actions: {\n            display: \"flex\",\n            gap: \"8px\",\n            marginTop: \"12px\",\n            flexWrap: \"wrap\"\n          },\n          progress: {\n            width: \"100%\",\n            height: \"4px\",\n            backgroundColor: colors.border,\n            borderRadius: \"2px\",\n            overflow: \"hidden\",\n            marginTop: \"8px\"\n          }\n        };\n      }\n      /**\n       * 获取操作按钮样式\n       */\n      getActionButtonStyles(style = \"primary\", theme = this.currentTheme) {\n        const colors = this.themes[theme];\n        const baseStyles = {\n          padding: \"6px 12px\",\n          borderRadius: \"6px\",\n          fontSize: \"12px\",\n          fontWeight: \"500\",\n          cursor: \"pointer\",\n          border: \"none\",\n          transition: \"all 0.2s ease\",\n          outline: \"none\"\n        };\n        switch (style) {\n          case \"primary\":\n            return {\n              ...baseStyles,\n              backgroundColor: colors.info,\n              color: \"#ffffff\"\n            };\n          case \"secondary\":\n            return {\n              ...baseStyles,\n              backgroundColor: \"transparent\",\n              color: colors.text,\n              border: `1px solid ${colors.border}`\n            };\n          case \"danger\":\n            return {\n              ...baseStyles,\n              backgroundColor: colors.error,\n              color: \"#ffffff\"\n            };\n          default:\n            return baseStyles;\n        }\n      }\n      /**\n       * 获取进度条样式\n       */\n      getProgressBarStyles(value, color, theme = this.currentTheme) {\n        const colors = this.themes[theme];\n        return {\n          width: `${Math.max(0, Math.min(100, value))}%`,\n          height: \"100%\",\n          backgroundColor: color || colors.info,\n          borderRadius: \"2px\",\n          transition: \"width 0.3s ease\"\n        };\n      }\n      /**\n       * 应用样式到元素\n       */\n      applyStyles(element, styles) {\n        Object.entries(styles).forEach(([property, value]) => {\n          if (value !== void 0) {\n            element.style.setProperty(property, String(value));\n          }\n        });\n      }\n      /**\n       * 设置主题\n       */\n      setTheme(theme) {\n        this.currentTheme = theme;\n      }\n      /**\n       * 获取当前主题\n       */\n      getTheme() {\n        return this.currentTheme;\n      }\n      /**\n       * 注册自定义主题\n       */\n      registerTheme(name, colors) {\n        this.themes[name] = colors;\n      }\n      /**\n       * 获取主题颜色\n       */\n      getThemeColors(theme = this.currentTheme) {\n        return { ...this.themes[theme] };\n      }\n      /**\n       * 检测系统主题偏好\n       */\n      detectSystemTheme() {\n        if (typeof window === \"undefined\") {\n          return \"light\";\n        }\n        return window.matchMedia(\"(prefers-color-scheme: dark)\").matches ? \"dark\" : \"light\";\n      }\n      /**\n       * 监听系统主题变化\n       */\n      watchSystemTheme(callback) {\n        if (typeof window === \"undefined\") {\n          return () => {\n          };\n        }\n        const mediaQuery = window.matchMedia(\"(prefers-color-scheme: dark)\");\n        const handler = (e) => {\n          callback(e.matches ? \"dark\" : \"light\");\n        };\n        mediaQuery.addEventListener(\"change\", handler);\n        return () => {\n          mediaQuery.removeEventListener(\"change\", handler);\n        };\n      }\n    }\n    function createStyleManager() {\n      return new NotificationStyleManager();\n    }\n\n    class NotificationManagerImpl {\n      constructor(logger) {\n        this.notifications = /* @__PURE__ */ new Map();\n        this.containers = /* @__PURE__ */ new Map();\n        this.maxNotifications = 5;\n        this.defaultDuration = 4e3;\n        this.defaultPosition = \"top-right\";\n        this.defaultTheme = \"light\";\n        this.idCounter = 0;\n        this.defaultOptions = {\n          position: \"top-right\",\n          duration: 4e3,\n          theme: \"light\",\n          type: \"info\",\n          closable: true,\n          persistent: false\n        };\n        this.logger = logger;\n        this.styleManager = createStyleManager();\n        this.initializeContainers();\n        this.setupThemeWatcher();\n        this.injectStyles();\n      }\n      /**\n       * 初始化所有位置的容器\n       */\n      initializeContainers() {\n        if (typeof document === \"undefined\") {\n          return;\n        }\n        const positions = [\n          \"top-left\",\n          \"top-center\",\n          \"top-right\",\n          \"bottom-left\",\n          \"bottom-center\",\n          \"bottom-right\"\n        ];\n        positions.forEach((position) => {\n          this.createContainer(position);\n        });\n      }\n      /**\n       * 创建指定位置的容器\n       */\n      createContainer(position) {\n        if (this.containers.has(position)) {\n          return this.containers.get(position);\n        }\n        const container = document.createElement(\"div\");\n        container.id = `engine-notifications-${position}`;\n        container.className = \"engine-notifications-container\";\n        const styles = this.styleManager.getContainerStyles(position);\n        this.styleManager.applyStyles(container, styles);\n        document.body.appendChild(container);\n        this.containers.set(position, container);\n        return container;\n      }\n      /**\n       * 设置主题监听器\n       */\n      setupThemeWatcher() {\n        if (this.defaultTheme === \"auto\") {\n          this.styleManager.watchSystemTheme((systemTheme) => {\n            this.styleManager.setTheme(systemTheme);\n            this.updateAllNotificationStyles();\n          });\n        }\n      }\n      /**\n       * 更新所有通知的样式\n       */\n      updateAllNotificationStyles() {\n        this.notifications.forEach((notification) => {\n          if (notification.element && notification.visible) {\n            this.updateNotificationStyles(notification);\n          }\n        });\n      }\n      show(options) {\n        const id = this.generateId();\n        const notification = {\n          id,\n          createdAt: Date.now(),\n          visible: true,\n          type: options.type || \"info\",\n          duration: options.duration ?? this.defaultDuration,\n          closable: options.closable ?? true,\n          position: options.position || this.defaultPosition,\n          theme: options.theme || this.defaultTheme,\n          ...options\n        };\n        this.enforceMaxNotifications(notification.position);\n        this.notifications.set(id, notification);\n        this.renderNotification(notification);\n        if (notification.duration && notification.duration > 0 && !notification.persistent) {\n          notification.timeoutId = window.setTimeout(() => {\n            this.hide(id);\n          }, notification.duration);\n        }\n        if (notification.onShow) {\n          try {\n            notification.onShow();\n          } catch (error) {\n            this.logger?.error(\"Error in notification onShow callback\", error);\n          }\n        }\n        this.logger?.debug(\"Notification shown\", { id, options });\n        return id;\n      }\n      async hide(id) {\n        const notification = this.notifications.get(id);\n        if (!notification || !notification.visible) {\n          return;\n        }\n        notification.visible = false;\n        if (notification.timeoutId) {\n          clearTimeout(notification.timeoutId);\n          notification.timeoutId = void 0;\n        }\n        if (notification.onClose) {\n          try {\n            notification.onClose();\n          } catch (error) {\n            this.logger?.error(\"Error in notification onClose callback\", error);\n          }\n        }\n        await this.removeNotificationElement(notification);\n        this.notifications.delete(id);\n        this.logger?.debug(\"Notification hidden\", { id });\n      }\n      async hideAll() {\n        const hidePromises = Array.from(this.notifications.keys()).map((id) => this.hide(id));\n        await Promise.all(hidePromises);\n      }\n      getAll() {\n        return Array.from(this.notifications.values()).filter((notification) => !!notification.id && notification.visible !== false).map((notification) => ({\n          id: notification.id,\n          title: notification.title || \"\",\n          message: notification.message,\n          type: notification.type || \"info\",\n          position: notification.position || \"top-right\",\n          duration: notification.duration || 3e3,\n          theme: notification.theme || \"light\",\n          animation: notification.animation || \"fade\",\n          icon: notification.icon,\n          actions: notification.actions || [],\n          group: notification.group,\n          persistent: notification.persistent || false,\n          closable: notification.closable !== false,\n          priority: notification.priority || 0,\n          metadata: notification.metadata,\n          timestamp: notification.createdAt || Date.now(),\n          isVisible: notification.visible !== false,\n          isAnimating: notification.isAnimating || false,\n          showProgress: !!notification.progress,\n          progress: notification.progress,\n          createdAt: notification.createdAt,\n          visible: notification.visible,\n          element: notification.element,\n          timeoutId: notification.timeoutId\n        }));\n      }\n      // 添加缺失的方法以满足测试需求\n      destroy() {\n        this.clear();\n        if (this.cleanupInterval) {\n          clearInterval(this.cleanupInterval);\n        }\n        void this.destroyInternal();\n      }\n      setPosition(position) {\n        this.defaultOptions.position = position;\n      }\n      getPosition() {\n        return this.defaultOptions.position || \"top-right\";\n      }\n      setTheme(theme) {\n        this.defaultOptions.theme = theme;\n        this.setThemeInternal(theme);\n      }\n      getTheme() {\n        return this.getThemeInternal();\n      }\n      setMaxNotifications(max) {\n        this.setMaxNotificationsInternal(max);\n      }\n      getMaxNotifications() {\n        return this.maxNotifications;\n      }\n      setDefaultDuration(duration) {\n        this.defaultOptions.duration = duration;\n      }\n      getDefaultDuration() {\n        return this.defaultOptions.duration || 3e3;\n      }\n      getStats() {\n        return this.getStatsInternal();\n      }\n      generateId() {\n        return `notification-${++this.idCounter}-${Date.now()}`;\n      }\n      enforceMaxNotifications(position) {\n        const visibleNotifications = Array.from(this.notifications.values()).filter((n) => n.visible && n.position === position).sort((a, b) => {\n          if (a.priority !== b.priority) {\n            return (a.priority || 0) - (b.priority || 0);\n          }\n          return a.createdAt - b.createdAt;\n        });\n        while (visibleNotifications.length >= this.maxNotifications) {\n          const toRemove = visibleNotifications.shift();\n          if (toRemove) {\n            this.hide(toRemove.id);\n          }\n        }\n      }\n      async renderNotification(notification) {\n        const container = this.createContainer(notification.position);\n        if (!container) {\n          return;\n        }\n        const element = this.createNotificationElement(notification);\n        notification.element = element;\n        element.classList.add(\"notification-enter\");\n        if (notification.position?.includes(\"left\")) {\n          element.classList.add(\"notification-position-left\");\n        } else if (notification.position?.includes(\"center\")) {\n          element.classList.add(\"notification-position-center\");\n        }\n        if (notification.position?.startsWith(\"bottom\")) {\n          container.insertBefore(element, container.firstChild);\n        } else {\n          container.appendChild(element);\n        }\n        void element.offsetHeight;\n        return new Promise((resolve) => {\n          element.classList.add(\"notification-enter-active\");\n          element.classList.remove(\"notification-enter\");\n          const handleTransitionEnd = () => {\n            element.removeEventListener(\"transitionend\", handleTransitionEnd);\n            element.classList.remove(\"notification-enter-active\");\n            resolve();\n          };\n          element.addEventListener(\"transitionend\", handleTransitionEnd);\n          setTimeout(() => {\n            element.removeEventListener(\"transitionend\", handleTransitionEnd);\n            element.classList.remove(\"notification-enter-active\");\n            resolve();\n          }, 500);\n        });\n      }\n      createNotificationElement(notification) {\n        const element = document.createElement(\"div\");\n        element.id = `notification-${notification.id}`;\n        element.className = \"engine-notification\";\n        const styles = this.styleManager.getNotificationStyles(notification.type, notification.theme);\n        this.styleManager.applyStyles(element, styles.notification);\n        if (notification.style) {\n          this.styleManager.applyStyles(element, notification.style);\n        }\n        if (notification.className) {\n          element.className += ` ${notification.className}`;\n        }\n        if (notification.maxWidth) {\n          element.style.maxWidth = `${notification.maxWidth}px`;\n        }\n        if (notification.zIndex) {\n          element.style.zIndex = notification.zIndex.toString();\n        }\n        const content = document.createElement(\"div\");\n        const contentStyles = this.styleManager.getNotificationStyles(notification.type, notification.theme);\n        this.styleManager.applyStyles(content, contentStyles.content);\n        const iconContainer = this.createIconElement(notification);\n        if (iconContainer) {\n          content.appendChild(iconContainer);\n        }\n        const textContent = document.createElement(\"div\");\n        textContent.style.flex = \"1\";\n        textContent.style.minWidth = \"0\";\n        if (notification.title) {\n          const titleElement = document.createElement(\"div\");\n          titleElement.className = \"engine-notification-title\";\n          if (notification.allowHTML) {\n            titleElement.innerHTML = notification.title;\n          } else {\n            titleElement.textContent = notification.title;\n          }\n          this.styleManager.applyStyles(titleElement, contentStyles.title);\n          textContent.appendChild(titleElement);\n        }\n        const messageElement = document.createElement(\"div\");\n        messageElement.className = \"engine-notification-message\";\n        if (notification.allowHTML) {\n          messageElement.innerHTML = notification.message;\n        } else {\n          messageElement.textContent = notification.message;\n        }\n        this.styleManager.applyStyles(messageElement, contentStyles.message);\n        textContent.appendChild(messageElement);\n        content.appendChild(textContent);\n        if (notification.progress) {\n          const progressContainer = this.createProgressElement(notification.progress, notification.theme);\n          textContent.appendChild(progressContainer);\n        }\n        if (notification.actions && notification.actions.length > 0) {\n          const actionsContainer = this.createActionsElement(notification.actions, notification);\n          textContent.appendChild(actionsContainer);\n        }\n        if (notification.closable) {\n          const closeButton = this.createCloseButton(notification);\n          element.appendChild(closeButton);\n        }\n        if (notification.onClick) {\n          element.style.cursor = \"pointer\";\n          element.addEventListener(\"click\", (e) => {\n            if (e.target.closest(\".engine-notification-close, .engine-notification-actions\")) {\n              return;\n            }\n            try {\n              notification.onClick();\n            } catch (error) {\n              this.logger?.error(\"Error in notification onClick callback\", error);\n            }\n          });\n        }\n        element.appendChild(content);\n        return element;\n      }\n      /**\n       * 创建图标元素\n       */\n      createIconElement(notification) {\n        const iconContainer = document.createElement(\"div\");\n        iconContainer.className = \"engine-notification-icon\";\n        const styles = this.styleManager.getNotificationStyles(notification.type, notification.theme);\n        this.styleManager.applyStyles(iconContainer, styles.icon);\n        if (notification.icon) {\n          if (typeof notification.icon === \"string\") {\n            iconContainer.innerHTML = notification.icon;\n          } else {\n            iconContainer.appendChild(notification.icon);\n          }\n        } else {\n          iconContainer.innerHTML = this.getTypeIcon(notification.type);\n        }\n        iconContainer.style.color = this.getTypeColor(notification.type);\n        return iconContainer;\n      }\n      /**\n       * 创建进度条元素\n       */\n      createProgressElement(progress, theme) {\n        const container = document.createElement(\"div\");\n        container.className = \"engine-notification-progress\";\n        const styles = this.styleManager.getNotificationStyles(\"info\", theme);\n        this.styleManager.applyStyles(container, styles.progress);\n        const bar = document.createElement(\"div\");\n        bar.className = \"engine-notification-progress-bar\";\n        const barStyles = this.styleManager.getProgressBarStyles(progress.value, progress.color, theme);\n        this.styleManager.applyStyles(bar, barStyles);\n        container.appendChild(bar);\n        if (progress.showText) {\n          const text = document.createElement(\"div\");\n          text.className = \"engine-notification-progress-text\";\n          text.textContent = `${Math.round(progress.value)}%`;\n          text.style.fontSize = \"11px\";\n          text.style.marginTop = \"4px\";\n          text.style.textAlign = \"center\";\n          container.appendChild(text);\n        }\n        return container;\n      }\n      /**\n       * 创建操作按钮容器\n       */\n      createActionsElement(actions, notification) {\n        const container = document.createElement(\"div\");\n        container.className = \"engine-notification-actions\";\n        const styles = this.styleManager.getNotificationStyles(notification.type, notification.theme);\n        this.styleManager.applyStyles(container, styles.actions);\n        actions.forEach((action) => {\n          const button = document.createElement(\"button\");\n          button.className = \"engine-notification-action\";\n          button.textContent = action.label;\n          const buttonStyles = this.styleManager.getActionButtonStyles(action.style, notification.theme);\n          this.styleManager.applyStyles(button, buttonStyles);\n          if (action.loading) {\n            button.disabled = true;\n            button.textContent = \"...\";\n          }\n          button.addEventListener(\"click\", async (e) => {\n            e.stopPropagation();\n            try {\n              button.disabled = true;\n              button.textContent = \"...\";\n              await action.action();\n              this.hide(notification.id);\n            } catch (error) {\n              this.logger?.error(\"Error in notification action\", error);\n            } finally {\n              button.disabled = false;\n              button.textContent = action.label;\n            }\n          });\n          container.appendChild(button);\n        });\n        return container;\n      }\n      /**\n       * 创建关闭按钮\n       */\n      createCloseButton(notification) {\n        const button = document.createElement(\"button\");\n        button.className = \"engine-notification-close\";\n        button.innerHTML = \"\\xD7\";\n        button.setAttribute(\"aria-label\", \"Close notification\");\n        const styles = this.styleManager.getNotificationStyles(notification.type, notification.theme);\n        this.styleManager.applyStyles(button, styles.closeButton);\n        button.addEventListener(\"click\", (e) => {\n          e.stopPropagation();\n          this.hide(notification.id);\n        });\n        button.addEventListener(\"mouseenter\", () => {\n          button.style.opacity = \"0.8\";\n        });\n        button.addEventListener(\"mouseleave\", () => {\n          button.style.opacity = \"0.5\";\n        });\n        return button;\n      }\n      /**\n       * 更新通知样式\n       */\n      updateNotificationStyles(notification) {\n        if (!notification.element)\n          return;\n        const styles = this.styleManager.getNotificationStyles(notification.type, notification.theme);\n        this.styleManager.applyStyles(notification.element, styles.notification);\n      }\n      /**\n       * 注入CSS样式\n       */\n      injectStyles() {\n        if (typeof document === \"undefined\")\n          return;\n        const styleId = \"notification-animations\";\n        if (document.getElementById(styleId))\n          return;\n        const style = document.createElement(\"style\");\n        style.id = styleId;\n        style.textContent = `\n      .notification-enter {\n        height: 0 !important;\n        opacity: 0 !important;\n        overflow: hidden !important;\n        margin-bottom: 0 !important;\n        padding-top: 0 !important;\n        padding-bottom: 0 !important;\n        transform: translateX(100%) !important;\n      }\n\n      .notification-enter.notification-position-left {\n        transform: translateX(-100%) !important;\n      }\n\n      .notification-enter.notification-position-center {\n        transform: translateY(-100%) !important;\n      }\n\n      .notification-enter-active {\n        transition: all 0.4s cubic-bezier(0.4, 0, 0.2, 1) !important;\n        height: auto !important;\n        opacity: 1 !important;\n        overflow: visible !important;\n        margin-bottom: 12px !important;\n        padding-top: 16px !important;\n        padding-bottom: 16px !important;\n        transform: translateX(0) translateY(0) !important;\n      }\n\n      .notification-leave {\n        transition: all 0.35s cubic-bezier(0.4, 0, 0.2, 1) !important;\n      }\n\n      .notification-leave-active {\n        height: 0 !important;\n        opacity: 0 !important;\n        overflow: hidden !important;\n        margin-bottom: 0 !important;\n        padding-top: 0 !important;\n        padding-bottom: 0 !important;\n        transform: translateX(100%) !important;\n      }\n\n      .notification-leave-active.notification-position-left {\n        transform: translateX(-100%) !important;\n      }\n\n      .notification-leave-active.notification-position-center {\n        transform: translateY(-100%) !important;\n      }\n    `;\n        document.head.appendChild(style);\n      }\n      /**\n       * 移除通知元素（带动画）\n       */\n      async removeNotificationElement(notification) {\n        if (!notification.element)\n          return;\n        const container = this.containers.get(notification.position);\n        if (!container)\n          return;\n        try {\n          const elementToRemove = notification.element;\n          const allElements = Array.from(container.children);\n          const elementIndex = allElements.indexOf(elementToRemove);\n          if (elementIndex === -1)\n            return;\n          const elementHeight = this.getElementTotalHeight(elementToRemove);\n          const elementsToMove = this.getElementsToMove(allElements, elementIndex, notification.position);\n          if (elementsToMove.length > 0) {\n            this.startOtherElementsAnimation(elementsToMove, elementHeight, notification.position);\n          }\n          elementToRemove.classList.add(\"notification-leave\");\n          if (notification.position?.includes(\"left\")) {\n            elementToRemove.classList.add(\"notification-position-left\");\n          } else if (notification.position?.includes(\"center\")) {\n            elementToRemove.classList.add(\"notification-position-center\");\n          }\n          return new Promise((resolve) => {\n            elementToRemove.classList.add(\"notification-leave-active\");\n            const handleTransitionEnd = () => {\n              elementToRemove.removeEventListener(\"transitionend\", handleTransitionEnd);\n              elementToRemove.remove();\n              notification.element = void 0;\n              resolve();\n            };\n            elementToRemove.addEventListener(\"transitionend\", handleTransitionEnd);\n            setTimeout(() => {\n              elementToRemove.removeEventListener(\"transitionend\", handleTransitionEnd);\n              if (elementToRemove.parentNode) {\n                elementToRemove.remove();\n              }\n              notification.element = void 0;\n              resolve();\n            }, 400);\n          });\n        } catch (error) {\n          this.logger?.error(\"Error in notification exit animation\", error);\n          if (notification.element) {\n            notification.element.remove();\n            notification.element = void 0;\n          }\n        }\n      }\n      /**\n       * 获取元素的总高度（包括margin）\n       */\n      getElementTotalHeight(element) {\n        const computedStyle = window.getComputedStyle(element);\n        const height = element.offsetHeight;\n        const marginTop = Number.parseInt(computedStyle.marginTop) || 0;\n        const marginBottom = Number.parseInt(computedStyle.marginBottom) || 0;\n        return height + marginTop + marginBottom;\n      }\n      /**\n       * 获取需要移动的元素\n       */\n      getElementsToMove(allElements, removedIndex, position) {\n        const isBottomPosition = position.startsWith(\"bottom\");\n        if (isBottomPosition) {\n          return allElements.slice(0, removedIndex);\n        } else {\n          return allElements.slice(removedIndex + 1);\n        }\n      }\n      /**\n       * 立即开始其他元素的移动动画\n       */\n      startOtherElementsAnimation(elements, moveDistance, position) {\n        const isBottomPosition = position.startsWith(\"bottom\");\n        const direction = isBottomPosition ? moveDistance : -moveDistance;\n        elements.forEach((element) => {\n          element.style.transition = \"transform 0.35s cubic-bezier(0.4, 0, 0.2, 1)\";\n          element.style.transform = `translateY(${direction}px)`;\n          const cleanup = () => {\n            element.style.transition = \"\";\n            element.style.transform = \"\";\n            element.removeEventListener(\"transitionend\", cleanup);\n          };\n          element.addEventListener(\"transitionend\", cleanup);\n          setTimeout(cleanup, 400);\n        });\n      }\n      /**\n       * 根据类型返回颜色\n       */\n      getTypeColor(type) {\n        if (!type)\n          type = \"info\";\n        switch (type) {\n          case \"success\":\n            return \"#10b981\";\n          case \"error\":\n            return \"#ef4444\";\n          case \"warning\":\n            return \"#f59e0b\";\n          case \"info\":\n          default:\n            return \"#3b82f6\";\n        }\n      }\n      /**\n       * 根据类型返回SVG图标\n       */\n      getTypeIcon(type) {\n        if (!type)\n          type = \"info\";\n        switch (type) {\n          case \"success\":\n            return `<svg viewBox=\"0 0 20 20\" fill=\"currentColor\">\n          <path fill-rule=\"evenodd\" d=\"M10 18a8 8 0 100-16 8 8 0 000 16zm3.707-9.293a1 1 0 00-1.414-1.414L9 10.586 7.707 9.293a1 1 0 00-1.414 1.414l2 2a1 1 0 001.414 0l4-4z\" clip-rule=\"evenodd\" />\n        </svg>`;\n          case \"error\":\n            return `<svg viewBox=\"0 0 20 20\" fill=\"currentColor\">\n          <path fill-rule=\"evenodd\" d=\"M10 18a8 8 0 100-16 8 8 0 000 16zM8.707 7.293a1 1 0 00-1.414 1.414L8.586 10l-1.293 1.293a1 1 0 101.414 1.414L10 11.414l1.293 1.293a1 1 0 001.414-1.414L11.414 10l1.293-1.293a1 1 0 00-1.414-1.414L10 8.586 8.707 7.293z\" clip-rule=\"evenodd\" />\n        </svg>`;\n          case \"warning\":\n            return `<svg viewBox=\"0 0 20 20\" fill=\"currentColor\">\n          <path fill-rule=\"evenodd\" d=\"M8.257 3.099c.765-1.36 2.722-1.36 3.486 0l5.58 9.92c.75 1.334-.213 2.98-1.742 2.98H4.42c-1.53 0-2.493-1.646-1.743-2.98l5.58-9.92zM11 13a1 1 0 11-2 0 1 1 0 012 0zm-1-8a1 1 0 00-1 1v3a1 1 0 002 0V6a1 1 0 00-1-1z\" clip-rule=\"evenodd\" />\n        </svg>`;\n          case \"info\":\n          default:\n            return `<svg viewBox=\"0 0 20 20\" fill=\"currentColor\">\n          <path fill-rule=\"evenodd\" d=\"M18 10a8 8 0 11-16 0 8 8 0 0116 0zm-7-4a1 1 0 11-2 0 1 1 0 012 0zM9 9a1 1 0 000 2v3a1 1 0 001 1h1a1 1 0 100-2v-3a1 1 0 00-1-1H9z\" clip-rule=\"evenodd\" />\n        </svg>`;\n        }\n      }\n      /**\n       * 设置主题（内部方法）\n       */\n      setThemeInternal(theme) {\n        this.defaultTheme = theme;\n        this.styleManager.setTheme(theme === \"auto\" ? this.styleManager.detectSystemTheme() : theme);\n        this.updateAllNotificationStyles();\n      }\n      /**\n       * 内部获取主题方法\n       */\n      getThemeInternal() {\n        return this.defaultTheme;\n      }\n      /**\n       * 内部方法：设置最大通知数量\n       */\n      setMaxNotificationsInternal(max) {\n        this.maxNotifications = max;\n        const positions = [\n          \"top-left\",\n          \"top-center\",\n          \"top-right\",\n          \"bottom-left\",\n          \"bottom-center\",\n          \"bottom-right\"\n        ];\n        positions.forEach((position) => {\n          this.enforceMaxNotifications(position);\n        });\n      }\n      /**\n       * 内部统计方法\n       */\n      getStatsInternal() {\n        const byType = {\n          success: 0,\n          error: 0,\n          warning: 0,\n          info: 0\n        };\n        const byPosition = {\n          \"top-left\": 0,\n          \"top-center\": 0,\n          \"top-right\": 0,\n          \"bottom-left\": 0,\n          \"bottom-center\": 0,\n          \"bottom-right\": 0\n        };\n        let visible = 0;\n        Array.from(this.notifications.values()).forEach((notification) => {\n          if (notification.visible) {\n            visible++;\n          }\n          const type = notification.type || \"info\";\n          byType[type]++;\n          const position = notification.position || \"top-right\";\n          byPosition[position]++;\n        });\n        return {\n          total: this.notifications.size,\n          visible,\n          byType,\n          byPosition\n        };\n      }\n      /**\n       * 内部销毁方法\n       */\n      async destroyInternal() {\n        await this.hideAll();\n        this.containers.forEach((container) => {\n          container.remove();\n        });\n        this.containers.clear();\n        this.notifications.forEach((notification) => {\n          if (notification.timeoutId) {\n            clearTimeout(notification.timeoutId);\n          }\n        });\n        this.notifications.clear();\n      }\n      // 添加缺失的方法\n      update(id, options) {\n        const notification = this.notifications.get(id);\n        if (notification) {\n          Object.assign(notification, options);\n        }\n      }\n      get(id) {\n        const notification = this.notifications.get(id);\n        if (notification && notification.visible) {\n          return {\n            id: notification.id,\n            title: notification.title || \"\",\n            message: notification.message,\n            type: notification.type || \"info\",\n            position: notification.position || \"top-right\",\n            duration: notification.duration || 3e3,\n            animation: notification.animation || \"fade\",\n            theme: notification.theme || \"light\",\n            icon: notification.icon || \"\",\n            actions: notification.actions || [],\n            closable: notification.closable !== false,\n            persistent: notification.persistent || false,\n            showProgress: !!notification.progress,\n            progress: notification.progress,\n            group: notification.group,\n            priority: notification.priority || 0,\n            metadata: notification.metadata || {},\n            timestamp: notification.createdAt,\n            isVisible: notification.visible,\n            isAnimating: notification.isAnimating || false\n          };\n        }\n        return void 0;\n      }\n      clear() {\n        this.hideAll();\n      }\n      setDefaultOptions(options) {\n        Object.assign(this.defaultOptions, options);\n      }\n      getDefaultOptions() {\n        return { ...this.defaultOptions };\n      }\n    }\n    function createNotificationManager(logger) {\n      return new NotificationManagerImpl(logger);\n    }\n\n    var PerformanceEventType;\n    (function(PerformanceEventType2) {\n      PerformanceEventType2[\"NAVIGATION\"] = \"navigation\";\n      PerformanceEventType2[\"RESOURCE_LOAD\"] = \"resource_load\";\n      PerformanceEventType2[\"USER_INTERACTION\"] = \"user_interaction\";\n      PerformanceEventType2[\"COMPONENT_RENDER\"] = \"component_render\";\n      PerformanceEventType2[\"API_CALL\"] = \"api_call\";\n      PerformanceEventType2[\"NETWORK\"] = \"network\";\n      PerformanceEventType2[\"RENDER\"] = \"render\";\n      PerformanceEventType2[\"CUSTOM\"] = \"custom\";\n    })(PerformanceEventType || (PerformanceEventType = {}));\n    class MemoryMonitor {\n      start(callback, interval = 5e3) {\n        this.callback = callback;\n        this.intervalId = setInterval(() => {\n          const memory = this.getMemoryInfo();\n          if (memory && this.callback) {\n            this.callback(memory);\n          }\n        }, interval);\n      }\n      stop() {\n        if (this.intervalId) {\n          clearInterval(this.intervalId);\n          this.intervalId = void 0;\n        }\n        this.callback = void 0;\n      }\n      getMemoryInfo() {\n        if (typeof globalThis !== \"undefined\" && typeof globalThis.performance !== \"undefined\" && \"memory\" in globalThis.performance) {\n          const memory = globalThis.performance.memory;\n          return {\n            used: memory.usedJSHeapSize,\n            total: memory.totalJSHeapSize,\n            limit: memory.jsHeapSizeLimit\n          };\n        }\n        return void 0;\n      }\n    }\n    class FPSMonitor {\n      constructor() {\n        this.frameCount = 0;\n        this.lastTime = 0;\n        this.fps = 0;\n      }\n      start(callback) {\n        this.callback = callback;\n        this.frameCount = 0;\n        this.lastTime = globalThis.performance?.now() || Date.now();\n        this.measureFPS();\n      }\n      stop() {\n        if (this.animationId) {\n          cancelAnimationFrame(this.animationId);\n          this.animationId = void 0;\n        }\n        this.callback = void 0;\n      }\n      measureFPS() {\n        if (!this.callback)\n          return;\n        this.frameCount++;\n        const currentTime = globalThis.performance?.now() || Date.now();\n        if (currentTime - this.lastTime >= 1e3) {\n          this.fps = Math.round(this.frameCount * 1e3 / (currentTime - this.lastTime));\n          this.frameCount = 0;\n          this.lastTime = currentTime;\n          this.callback(this.fps);\n        }\n        this.animationId = requestAnimationFrame(() => this.measureFPS());\n      }\n      getFPS() {\n        return this.fps;\n      }\n    }\n    class PerformanceManagerImpl {\n      constructor(thresholds = {}, engine) {\n        this.events = /* @__PURE__ */ new Map();\n        this.metrics = [];\n        this.violationCallbacks = [];\n        this.metricsCallbacks = [];\n        this.monitoring = false;\n        this.fpsMonitor = new FPSMonitor();\n        this.memoryMonitor = new MemoryMonitor();\n        this.eventIdCounter = 0;\n        this.engine = engine;\n        this.thresholds = {\n          responseTime: { good: 100, poor: 1e3 },\n          fps: { good: 55, poor: 30 },\n          memory: { warning: 100, critical: 200 },\n          bundleSize: { warning: 500, critical: 1e3 },\n          ...thresholds\n        };\n      }\n      startEvent(type, name, metadata) {\n        const id = `perf_${++this.eventIdCounter}_${Date.now()}`;\n        const event = {\n          id,\n          type,\n          name,\n          startTime: globalThis.performance.now(),\n          metadata\n        };\n        this.events.set(id, event);\n        return id;\n      }\n      endEvent(id, metadata) {\n        const event = this.events.get(id);\n        if (!event) {\n          this.engine?.logger?.warn(`Performance event ${id} not found`);\n          return;\n        }\n        const endTime = globalThis.performance.now();\n        const duration = endTime - event.startTime;\n        event.endTime = endTime;\n        event.duration = duration;\n        if (metadata) {\n          event.metadata = { ...event.metadata, ...metadata };\n        }\n        this.checkThresholdViolations(event);\n        if (this.engine?.events) {\n          this.engine.events.emit(\"performance:event\", event);\n        }\n      }\n      recordEvent(event) {\n        const id = `perf_${++this.eventIdCounter}_${Date.now()}`;\n        const fullEvent = {\n          ...event,\n          id\n        };\n        this.events.set(id, fullEvent);\n        this.checkThresholdViolations(fullEvent);\n        return id;\n      }\n      collectMetrics() {\n        const timestamp = Date.now();\n        const metrics = {\n          timestamp,\n          duration: 0\n          // 将在后续更新\n        };\n        if (typeof globalThis !== \"undefined\" && typeof globalThis.performance !== \"undefined\" && \"memory\" in globalThis.performance) {\n          const memory = globalThis.performance.memory;\n          metrics.memory = {\n            used: memory.usedJSHeapSize,\n            total: memory.totalJSHeapSize,\n            limit: memory.jsHeapSizeLimit\n          };\n        }\n        if (typeof globalThis.performance !== \"undefined\" && globalThis.performance.getEntriesByType) {\n          const networkEntries = globalThis.performance.getEntriesByType(\"navigation\");\n          if (networkEntries.length > 0) {\n            const entry = networkEntries[0];\n            metrics.network = {\n              latency: entry.responseStart - entry.requestStart,\n              bandwidth: entry.transferSize ? entry.transferSize / (entry.responseEnd - entry.responseStart) * 1e3 : 0,\n              requests: 1,\n              totalSize: entry.transferSize || 0,\n              averageTime: entry.loadEventEnd - entry.loadEventStart\n            };\n          }\n        }\n        return metrics;\n      }\n      recordMetrics(metrics) {\n        const fullMetrics = {\n          timestamp: Date.now(),\n          duration: 0,\n          ...metrics\n        };\n        this.metrics.push(fullMetrics);\n        if (this.metrics.length > 1e3) {\n          this.metrics = this.metrics.slice(-500);\n        }\n        this.checkMetricsViolations(fullMetrics);\n        this.metricsCallbacks.forEach((callback) => {\n          try {\n            callback(fullMetrics);\n          } catch (error) {\n            this.engine?.logger?.error(\"Error in metrics callback\", error);\n          }\n        });\n      }\n      startMonitoring() {\n        if (this.monitoring) {\n          return;\n        }\n        this.monitoring = true;\n        if (typeof requestAnimationFrame !== \"undefined\") {\n          this.fpsMonitor.start((fps) => {\n            this.recordMetrics({\n              rendering: {\n                fps,\n                frameTime: 1e3 / fps,\n                droppedFrames: fps < 30 ? 1 : 0,\n                renderTime: 1e3 / fps\n              }\n            });\n          });\n        }\n        this.memoryMonitor.start((memory) => {\n          this.recordMetrics({ memory });\n        });\n        if (typeof PerformanceObserver !== \"undefined\") {\n          try {\n            const observer = new PerformanceObserver((list) => {\n              for (const entry of list.getEntries()) {\n                this.handlePerformanceEntry(entry);\n              }\n            });\n            observer.observe({\n              entryTypes: [\"navigation\", \"resource\", \"measure\", \"mark\"]\n            });\n          } catch (error) {\n            this.engine?.logger?.warn(\"PerformanceObserver not supported\", error);\n          }\n        }\n        this.engine?.logger?.info(\"Performance monitoring started\");\n      }\n      stopMonitoring() {\n        if (!this.monitoring) {\n          return;\n        }\n        this.monitoring = false;\n        this.fpsMonitor.stop();\n        this.memoryMonitor.stop();\n        this.engine?.logger?.info(\"Performance monitoring stopped\");\n      }\n      isMonitoring() {\n        return this.monitoring;\n      }\n      getEvents(filter) {\n        let events = Array.from(this.events.values());\n        if (filter) {\n          events = events.filter((event) => {\n            return Object.entries(filter).every(([key, value]) => {\n              return event[key] === value;\n            });\n          });\n        }\n        return events.sort((a, b) => a.startTime - b.startTime);\n      }\n      getMetrics(timeRange) {\n        let metrics = [...this.metrics];\n        if (timeRange) {\n          metrics = metrics.filter((metric) => metric.timestamp >= timeRange.start && metric.timestamp <= timeRange.end);\n        }\n        return metrics.sort((a, b) => a.timestamp - b.timestamp);\n      }\n      getReport(timeRange) {\n        const events = this.getEvents();\n        const metrics = this.getMetrics(timeRange);\n        const completedEvents = events.filter((e) => e.duration !== void 0);\n        const totalResponseTime = completedEvents.reduce((sum, e) => sum + (e.duration || 0), 0);\n        const averageResponseTime = completedEvents.length > 0 ? totalResponseTime / completedEvents.length : 0;\n        const fpsMetrics = metrics.filter((m) => m.rendering?.fps);\n        const averageFPS = fpsMetrics.length > 0 ? fpsMetrics.reduce((sum, m) => sum + (m.rendering?.fps || 0), 0) / fpsMetrics.length : 0;\n        const latestMemory = metrics.filter((m) => m.memory).pop();\n        const memoryUsage = latestMemory?.memory?.used || 0;\n        const timeStart = timeRange?.start || (events.length > 0 ? Math.min(...events.map((e) => e.startTime)) : Date.now());\n        const timeEnd = timeRange?.end || Date.now();\n        return {\n          summary: {\n            totalEvents: events.length,\n            averageResponseTime,\n            averageFPS,\n            memoryUsage,\n            timeRange: {\n              start: timeStart,\n              end: timeEnd\n            }\n          },\n          events,\n          metrics,\n          violations: this.getViolations(timeRange),\n          recommendations: this.generateRecommendations(events, metrics)\n        };\n      }\n      setThresholds(thresholds) {\n        this.thresholds = { ...this.thresholds, ...thresholds };\n      }\n      getThresholds() {\n        return { ...this.thresholds };\n      }\n      onViolation(callback) {\n        this.violationCallbacks.push(callback);\n      }\n      onMetrics(callback) {\n        this.metricsCallbacks.push(callback);\n        return () => {\n          const index = this.metricsCallbacks.indexOf(callback);\n          if (index > -1) {\n            this.metricsCallbacks.splice(index, 1);\n          }\n        };\n      }\n      clearData(olderThan) {\n        const cutoff = olderThan || Date.now() - 24 * 60 * 60 * 1e3;\n        for (const [id, event] of this.events.entries()) {\n          if (event.startTime < cutoff) {\n            this.events.delete(id);\n          }\n        }\n        this.metrics = this.metrics.filter((metric) => metric.timestamp >= cutoff);\n      }\n      exportData() {\n        return JSON.stringify({\n          events: Array.from(this.events.values()),\n          metrics: this.metrics,\n          thresholds: this.thresholds\n        });\n      }\n      importData(data) {\n        try {\n          const parsed = JSON.parse(data);\n          if (parsed.events) {\n            this.events.clear();\n            parsed.events.forEach((event) => {\n              this.events.set(event.id, event);\n            });\n          }\n          if (parsed.metrics) {\n            this.metrics = parsed.metrics;\n          }\n          if (parsed.thresholds) {\n            this.thresholds = { ...this.thresholds, ...parsed.thresholds };\n          }\n        } catch (error) {\n          this.engine?.logger?.error(\"Failed to import performance data\", error);\n        }\n      }\n      handlePerformanceEntry(entry) {\n        const eventType = this.getEventTypeFromEntry(entry);\n        this.recordEvent({\n          type: eventType,\n          name: entry.name,\n          startTime: entry.startTime,\n          endTime: entry.startTime + entry.duration,\n          duration: entry.duration,\n          metadata: {\n            entryType: entry.entryType,\n            ...this.getEntryMetadata(entry)\n          }\n        });\n      }\n      getEventTypeFromEntry(entry) {\n        switch (entry.entryType) {\n          case \"navigation\":\n            return PerformanceEventType.NAVIGATION;\n          case \"resource\":\n            return PerformanceEventType.RESOURCE_LOAD;\n          case \"measure\":\n          case \"mark\":\n            return PerformanceEventType.CUSTOM;\n          default:\n            return PerformanceEventType.CUSTOM;\n        }\n      }\n      getEntryMetadata(entry) {\n        const metadata = {};\n        const anyEntry = entry;\n        if (typeof anyEntry.transferSize === \"number\") {\n          metadata.transferSize = anyEntry.transferSize;\n        }\n        if (typeof anyEntry.decodedBodySize === \"number\") {\n          metadata.decodedBodySize = anyEntry.decodedBodySize;\n        }\n        return metadata;\n      }\n      checkThresholdViolations(event) {\n        if (!event.duration)\n          return;\n        const { responseTime } = this.thresholds;\n        if (responseTime && event.duration > responseTime.poor) {\n          this.reportViolation({\n            type: \"threshold\",\n            severity: \"high\",\n            message: `Slow operation detected: ${event.name} took ${event.duration.toFixed(2)}ms`,\n            details: { event, threshold: responseTime.poor },\n            timestamp: Date.now()\n          });\n        }\n      }\n      checkMetricsViolations(metrics) {\n        if (metrics.memory && this.thresholds.memory) {\n          const memoryMB = metrics.memory.used / (1024 * 1024);\n          if (memoryMB > this.thresholds.memory.critical) {\n            this.reportViolation({\n              type: \"memory_leak\",\n              severity: \"critical\",\n              message: `Critical memory usage: ${memoryMB.toFixed(2)}MB`,\n              details: {\n                memory: metrics.memory,\n                threshold: this.thresholds.memory.critical\n              },\n              timestamp: Date.now()\n            });\n          } else if (memoryMB > this.thresholds.memory.warning) {\n            this.reportViolation({\n              type: \"memory_leak\",\n              severity: \"medium\",\n              message: `High memory usage: ${memoryMB.toFixed(2)}MB`,\n              details: {\n                memory: metrics.memory,\n                threshold: this.thresholds.memory.warning\n              },\n              timestamp: Date.now()\n            });\n          }\n        }\n        if (metrics.rendering?.fps && this.thresholds.fps) {\n          if (metrics.rendering.fps < this.thresholds.fps.poor) {\n            this.reportViolation({\n              type: \"threshold\",\n              severity: \"medium\",\n              message: `Low FPS detected: ${metrics.rendering.fps}`,\n              details: {\n                fps: metrics.rendering.fps,\n                threshold: this.thresholds.fps.poor\n              },\n              timestamp: Date.now()\n            });\n          }\n        }\n      }\n      reportViolation(violation) {\n        this.violationCallbacks.forEach((callback) => {\n          try {\n            callback(violation);\n          } catch (error) {\n            this.engine?.logger?.error(\"Error in violation callback\", error);\n          }\n        });\n        if (this.engine?.events) {\n          this.engine.events.emit(\"performance:violation\", violation);\n        }\n      }\n      getViolations(_timeRange) {\n        return [];\n      }\n      generateRecommendations(events, metrics) {\n        const recommendations = [];\n        const slowEvents = events.filter((e) => e.duration && e.duration > 1e3);\n        if (slowEvents.length > 0) {\n          recommendations.push(`\\u53D1\\u73B0 ${slowEvents.length} \\u4E2A\\u6162\\u64CD\\u4F5C\\uFF0C\\u5EFA\\u8BAE\\u4F18\\u5316\\u6027\\u80FD`);\n          const slowestEvent = slowEvents.reduce((prev, current) => (prev.duration || 0) > (current.duration || 0) ? prev : current);\n          recommendations.push(`\\u6700\\u6162\\u64CD\\u4F5C: ${slowestEvent.name} (${slowestEvent.duration}ms)`);\n        }\n        const memoryMetrics = metrics.filter((m) => m.memory);\n        if (memoryMetrics.length > 0) {\n          if (memoryMetrics.length > 1) {\n            const firstMemory = memoryMetrics[0].memory?.used || 0;\n            const lastMemory = memoryMetrics[memoryMetrics.length - 1].memory?.used || 0;\n            const memoryGrowth = lastMemory - firstMemory;\n            const memoryGrowthMB = memoryGrowth / (1024 * 1024);\n            if (memoryGrowthMB > 50) {\n              recommendations.push(`\\u68C0\\u6D4B\\u5230\\u5185\\u5B58\\u589E\\u957F ${memoryGrowthMB.toFixed(2)}MB\\uFF0C\\u53EF\\u80FD\\u5B58\\u5728\\u5185\\u5B58\\u6CC4\\u6F0F`);\n            }\n          }\n          const avgMemory = memoryMetrics.reduce((sum, m) => sum + (m.memory?.used || 0), 0) / memoryMetrics.length;\n          const memoryMB = avgMemory / (1024 * 1024);\n          if (memoryMB > 100) {\n            recommendations.push(`\\u5E73\\u5747\\u5185\\u5B58\\u4F7F\\u7528 ${memoryMB.toFixed(2)}MB\\uFF0C\\u5EFA\\u8BAE\\u4F18\\u5316\\u5185\\u5B58\\u4F7F\\u7528`);\n          } else if (memoryMB > 50) {\n            recommendations.push(`\\u5185\\u5B58\\u4F7F\\u7528\\u8F83\\u9AD8 ${memoryMB.toFixed(2)}MB\\uFF0C\\u5EFA\\u8BAE\\u76D1\\u63A7\\u5185\\u5B58\\u4F7F\\u7528\\u60C5\\u51B5`);\n          }\n        }\n        const fpsMetrics = metrics.filter((m) => m.rendering?.fps);\n        if (fpsMetrics.length > 0) {\n          const avgFPS = fpsMetrics.reduce((sum, m) => sum + (m.rendering?.fps || 0), 0) / fpsMetrics.length;\n          const minFPS = Math.min(...fpsMetrics.map((m) => m.rendering?.fps || 60));\n          if (avgFPS < 30) {\n            recommendations.push(`\\u5E73\\u5747FPS ${avgFPS.toFixed(1)}\\uFF0C\\u5EFA\\u8BAE\\u4F18\\u5316\\u6E32\\u67D3\\u6027\\u80FD`);\n          }\n          if (minFPS < 20) {\n            recommendations.push(`\\u6700\\u4F4EFPS ${minFPS}\\uFF0C\\u5B58\\u5728\\u4E25\\u91CD\\u5361\\u987F`);\n          }\n          const droppedFrames = fpsMetrics.reduce((sum, m) => sum + (m.rendering?.droppedFrames || 0), 0);\n          if (droppedFrames > fpsMetrics.length * 0.1) {\n            recommendations.push(`\\u6389\\u5E27\\u7387 ${(droppedFrames / fpsMetrics.length * 100).toFixed(1)}%\\uFF0C\\u5EFA\\u8BAE\\u4F18\\u5316\\u52A8\\u753B`);\n          }\n        }\n        const networkEvents = events.filter((e) => e.type === PerformanceEventType.NETWORK);\n        if (networkEvents.length > 0) {\n          const avgResponseTime = networkEvents.reduce((sum, e) => sum + (e.duration || 0), 0) / networkEvents.length;\n          if (avgResponseTime > 2e3) {\n            recommendations.push(`\\u7F51\\u7EDC\\u8BF7\\u6C42\\u5E73\\u5747\\u54CD\\u5E94\\u65F6\\u95F4 ${avgResponseTime.toFixed(0)}ms\\uFF0C\\u5EFA\\u8BAE\\u4F18\\u5316\\u7F51\\u7EDC\\u6027\\u80FD`);\n          }\n        }\n        const renderEvents = events.filter((e) => e.type === PerformanceEventType.RENDER);\n        if (renderEvents.length > 0) {\n          const slowRenders = renderEvents.filter((e) => (e.duration || 0) > 16);\n          if (slowRenders.length > renderEvents.length * 0.2) {\n            recommendations.push(`${(slowRenders.length / renderEvents.length * 100).toFixed(1)}% \\u7684\\u6E32\\u67D3\\u8D85\\u8FC716ms\\uFF0C\\u5EFA\\u8BAE\\u4F18\\u5316\\u7EC4\\u4EF6`);\n          }\n        }\n        return recommendations;\n      }\n      // 添加缺失的方法\n      updateThresholds(thresholds) {\n        this.setThresholds(thresholds);\n      }\n      generateReport(timeRange) {\n        return this.getReport(timeRange);\n      }\n      mark(name) {\n        if (typeof globalThis.performance !== \"undefined\" && globalThis.performance.mark) {\n          globalThis.performance.mark(name);\n        }\n      }\n      measure(name, startMark, endMark) {\n        if (typeof globalThis.performance !== \"undefined\" && globalThis.performance.measure) {\n          try {\n            globalThis.performance.measure(name, startMark, endMark);\n          } catch (error) {\n            console.warn(`Performance measure failed: ${error}`);\n          }\n        }\n      }\n      getMarks() {\n        if (typeof globalThis.performance !== \"undefined\" && globalThis.performance.getEntriesByType) {\n          return globalThis.performance.getEntriesByType(\"mark\");\n        }\n        return [];\n      }\n      getMeasures() {\n        if (typeof globalThis.performance !== \"undefined\" && globalThis.performance.getEntriesByType) {\n          return globalThis.performance.getEntriesByType(\"measure\");\n        }\n        return [];\n      }\n      clearEvents() {\n        this.events.clear();\n      }\n      clearMetrics() {\n        this.metrics = [];\n      }\n      clearMarks() {\n        if (typeof globalThis.performance !== \"undefined\" && globalThis.performance.clearMarks) {\n          globalThis.performance.clearMarks();\n        }\n      }\n      clearMeasures() {\n        if (typeof globalThis.performance !== \"undefined\" && globalThis.performance.clearMeasures) {\n          globalThis.performance.clearMeasures();\n        }\n      }\n    }\n    function createPerformanceManager(thresholds, engine) {\n      return new PerformanceManagerImpl(thresholds, engine);\n    }\n\n    class PluginManagerImpl {\n      constructor(engine) {\n        this.name = \"PluginManager\";\n        this.version = \"1.0.0\";\n        this.plugins = /* @__PURE__ */ new Map();\n        this.loadOrder = [];\n        this.engine = engine;\n      }\n      /**\n       * 注册并安装插件。\n       *\n       * 会校验依赖、写入注册表、清理缓存并调用插件的 install。\n       * @throws 当插件已注册或依赖缺失时抛出错误\n       */\n      async register(plugin) {\n        if (this.plugins.has(plugin.name)) {\n          throw new Error(`Plugin \"${plugin.name}\" is already registered`);\n        }\n        const { satisfied, missing } = this.checkDependencies(plugin);\n        if (!satisfied) {\n          if (missing.length === 1) {\n            throw new Error(`Plugin \"${plugin.name}\" depends on \"${missing[0]}\" which is not registered`);\n          } else {\n            throw new Error(`Plugin \"${plugin.name}\" depends on missing plugins: ${missing.join(\", \")}`);\n          }\n        }\n        try {\n          this.plugins.set(plugin.name, plugin);\n          this.loadOrder.push(plugin.name);\n          if (this.engine) {\n            const context = this.createPluginContext();\n            await plugin.install(context);\n          }\n          if (this.engine?.logger) {\n            this.engine.logger.info(`Plugin \"${plugin.name}\" registered successfully`, {\n              version: plugin.version,\n              dependencies: plugin.dependencies\n            });\n          }\n          if (this.engine?.events) {\n            this.engine.events.emit(\"plugin:registered\", {\n              name: plugin.name,\n              plugin\n            });\n          }\n        } catch (error) {\n          this.plugins.delete(plugin.name);\n          const index = this.loadOrder.indexOf(plugin.name);\n          if (index > -1) {\n            this.loadOrder.splice(index, 1);\n          }\n          this.logPluginError(plugin.name, error);\n          throw error;\n        }\n      }\n      /**\n       * 卸载并注销插件。\n       *\n       * 会检查是否存在依赖该插件的其他插件，若存在则拒绝卸载。\n       * @throws 当插件未注册或存在依赖者时抛出错误\n       */\n      async unregister(name) {\n        const plugin = this.plugins.get(name);\n        if (!plugin) {\n          throw new Error(`Plugin \"${name}\" is not registered`);\n        }\n        const dependents = this.getDependents(name);\n        if (dependents.length > 0) {\n          throw new Error(`Cannot unregister plugin \"${name}\" because it is required by: ${dependents.join(\", \")}`);\n        }\n        try {\n          if (plugin.uninstall && this.engine) {\n            const context = this.createPluginContext();\n            await plugin.uninstall(context);\n          }\n          this.plugins.delete(name);\n          const index = this.loadOrder.indexOf(name);\n          if (index > -1) {\n            this.loadOrder.splice(index, 1);\n          }\n          if (this.engine?.logger) {\n            this.engine.logger.info(`Plugin \"${name}\" unregistered successfully`);\n          }\n          if (this.engine?.events) {\n            this.engine.events.emit(\"plugin:unregistered\", {\n              name,\n              plugin\n            });\n          }\n        } catch (error) {\n          if (this.engine?.logger) {\n            this.engine.logger.error(`Failed to unregister plugin \"${name}\"`, error);\n          }\n          throw error;\n        }\n      }\n      get(name) {\n        return this.plugins.get(name);\n      }\n      getAll() {\n        return this.loadOrder.map((name) => this.plugins.get(name));\n      }\n      isRegistered(name) {\n        return this.plugins.has(name);\n      }\n      has(name) {\n        return this.plugins.has(name);\n      }\n      /**\n       * 检查插件依赖满足情况（不修改状态）。\n       */\n      checkDependencies(plugin) {\n        const missing = [];\n        const conflicts = [];\n        if (plugin.dependencies) {\n          for (const dep of plugin.dependencies) {\n            if (!this.plugins.has(dep)) {\n              missing.push(dep);\n            }\n          }\n        }\n        return {\n          satisfied: missing.length === 0 && conflicts.length === 0,\n          missing,\n          conflicts\n        };\n      }\n      /**\n       * 获取依赖指定插件的插件列表。\n       */\n      getDependents(pluginName) {\n        const dependents = [];\n        for (const [name, plugin] of this.plugins) {\n          if (plugin.dependencies?.includes(pluginName)) {\n            dependents.push(name);\n          }\n        }\n        return dependents;\n      }\n      // 获取插件加载顺序\n      /**\n       * 获取插件按注册顺序的名称列表。\n       */\n      getLoadOrder() {\n        return [...this.loadOrder];\n      }\n      /**\n       * 获取当前插件依赖图。\n       */\n      getDependencyGraph() {\n        const graph = {};\n        for (const [name, plugin] of this.plugins) {\n          graph[name] = plugin.dependencies ? [...plugin.dependencies] : [];\n        }\n        return graph;\n      }\n      /**\n       * 验证所有已注册插件的依赖是否完整。\n       */\n      validateDependencies() {\n        const errors = [];\n        for (const [name, plugin] of this.plugins) {\n          if (plugin.dependencies) {\n            for (const dep of plugin.dependencies) {\n              if (!this.plugins.has(dep)) {\n                errors.push(`Plugin \"${name}\" depends on missing plugin \"${dep}\"`);\n              }\n            }\n          }\n        }\n        return {\n          valid: errors.length === 0,\n          errors\n        };\n      }\n      // 获取插件统计信息\n      /**\n       * 获取插件统计信息快照。\n       */\n      getStats() {\n        return {\n          total: this.plugins.size,\n          loaded: this.getLoadOrder(),\n          dependencies: this.getDependencyGraph(),\n          installed: this.plugins.size,\n          pending: 0,\n          errors: 0,\n          averageInstallTime: 0,\n          timestamp: Date.now()\n        };\n      }\n      // 获取插件信息\n      /**\n       * 获取单个插件的元信息摘要。\n       */\n      getInfo(name) {\n        const plugin = this.plugins.get(name);\n        if (!plugin)\n          return void 0;\n        return {\n          plugin,\n          status: \"installed\",\n          installTime: void 0,\n          error: void 0,\n          dependencies: plugin.dependencies || [],\n          dependents: this.getDependents(name)\n        };\n      }\n      // 获取所有插件信息\n      /**\n       * 获取所有已注册插件的元信息摘要列表。\n       */\n      getAllInfo() {\n        return Array.from(this.plugins.keys()).map((name) => this.getInfo(name)).filter(Boolean);\n      }\n      // 获取插件状态\n      /**\n       * 获取插件状态（当前实现为简化版）。\n       */\n      getStatus(name) {\n        if (!this.plugins.has(name))\n          return void 0;\n        return \"installed\";\n      }\n      // 解析依赖\n      /**\n       * 解析插件依赖并按合适顺序返回（当前实现简化为原序）。\n       */\n      resolveDependencies(plugins) {\n        return plugins;\n      }\n      // 按关键词查找插件\n      /**\n       * 按关键字搜索插件（基于名称与描述）。\n       */\n      findByKeyword(keyword) {\n        return Array.from(this.plugins.values()).filter((plugin) => plugin.description?.includes(keyword) || plugin.name.includes(keyword));\n      }\n      // 按作者查找插件\n      /**\n       * 按作者筛选插件（依赖插件公开 author 字段）。\n       */\n      findByAuthor(author) {\n        return Array.from(this.plugins.values()).filter((plugin) => {\n          return plugin.author === author;\n        });\n      }\n      // 按依赖查找插件\n      /**\n       * 查找依赖了指定插件名称的插件。\n       */\n      findByDependency(dependency) {\n        return Array.from(this.plugins.values()).filter((plugin) => plugin.dependencies?.includes(dependency));\n      }\n      destroy() {\n        for (const plugin of this.plugins.values()) {\n          if (plugin.uninstall) {\n            try {\n              plugin.uninstall({\n                engine: this.engine,\n                logger: this.engine.logger,\n                config: this.engine.config,\n                events: this.engine.events\n              });\n            } catch (error) {\n              console.error(`Error uninstalling plugin ${plugin.name}:`, error);\n            }\n          }\n        }\n        this.plugins.clear();\n        this.loadOrder = [];\n        this.clearCaches();\n      }\n      // 清理缓存\n      clearCaches() {\n      }\n      // 新增的辅助方法\n      /**\n       * 抽取创建上下文的逻辑\n       */\n      createPluginContext() {\n        return {\n          engine: this.engine,\n          logger: this.engine.logger,\n          config: this.engine.config,\n          events: this.engine.events\n        };\n      }\n      /**\n       * 记录插件错误\n       */\n      logPluginError(pluginName, error) {\n        if (this.engine?.logger) {\n          this.engine.logger.error(`Failed to register plugin \"${pluginName}\"`, error);\n        }\n      }\n    }\n    function createPluginManager(engine) {\n      return new PluginManagerImpl(engine);\n    }\n\n    var SecurityEventType;\n    (function(SecurityEventType2) {\n      SecurityEventType2[\"XSS_DETECTED\"] = \"xss_detected\";\n      SecurityEventType2[\"CSRF_ATTACK\"] = \"csrf_attack\";\n      SecurityEventType2[\"CSP_VIOLATION\"] = \"csp_violation\";\n      SecurityEventType2[\"CLICKJACKING_ATTEMPT\"] = \"clickjacking_attempt\";\n      SecurityEventType2[\"INSECURE_REQUEST\"] = \"insecure_request\";\n    })(SecurityEventType || (SecurityEventType = {}));\n    class XSSProtector {\n      constructor(config = {}) {\n        this.allowedTags = new Set(config.allowedTags || [\n          \"p\",\n          \"br\",\n          \"strong\",\n          \"em\",\n          \"u\",\n          \"i\",\n          \"b\",\n          \"h1\",\n          \"h2\",\n          \"h3\",\n          \"h4\",\n          \"h5\",\n          \"h6\",\n          \"ul\",\n          \"ol\",\n          \"li\",\n          \"blockquote\",\n          \"code\",\n          \"pre\"\n        ]);\n        this.allowedAttributes = /* @__PURE__ */ new Map();\n        const attrs = config.allowedAttributes || {\n          a: [\"href\", \"title\"],\n          img: [\"src\", \"alt\", \"title\", \"width\", \"height\"],\n          blockquote: [\"cite\"]\n        };\n        for (const [tag, attrList] of Object.entries(attrs)) {\n          this.allowedAttributes.set(tag, new Set(attrList));\n        }\n        this.stripIgnoreTag = config.stripIgnoreTag ?? true;\n      }\n      sanitize(html) {\n        const threats = [];\n        let sanitized = html;\n        const scriptRegex = /<script[^>]*>[\\s\\S]*?<\\/script>/gi;\n        const scripts = html.match(scriptRegex);\n        if (scripts) {\n          threats.push(\"Script tags detected\");\n          sanitized = sanitized.replace(scriptRegex, \"\");\n        }\n        const eventRegex = /\\s*on\\w+\\s*=\\s*[\"'][^\"']*[\"']/gi;\n        const events = html.match(eventRegex);\n        if (events) {\n          threats.push(\"Event handlers detected\");\n          sanitized = sanitized.replace(eventRegex, \"\");\n        }\n        const jsProtocolRegex = /javascript\\s*:/gi;\n        if (jsProtocolRegex.test(html)) {\n          threats.push(\"JavaScript protocol detected\");\n          sanitized = sanitized.replace(jsProtocolRegex, \"\");\n        }\n        const dataProtocolRegex = /data\\s*:(?!image\\/)\\w+/giu;\n        if (dataProtocolRegex.test(html)) {\n          threats.push(\"Suspicious data protocol detected\");\n          sanitized = sanitized.replace(dataProtocolRegex, \"\");\n        }\n        sanitized = this.filterTags(sanitized, threats);\n        sanitized = this.filterAttributes(sanitized, threats);\n        return {\n          safe: threats.length === 0,\n          sanitized,\n          threats\n        };\n      }\n      filterTags(html, threats) {\n        const tagRegex = /<\\/?([a-z][a-z0-9]*)[^>]*>/giu;\n        return html.replace(tagRegex, (match, tagName) => {\n          const tag = tagName.toLowerCase();\n          if (!this.allowedTags.has(tag)) {\n            threats.push(`Disallowed tag: ${tag}`);\n            return this.stripIgnoreTag ? \"\" : match.replace(/</g, \"&lt;\").replace(/>/g, \"&gt;\");\n          }\n          return match;\n        });\n      }\n      filterAttributes(html, threats) {\n        const tagRegex = /<([a-z][a-z0-9]*)[^>]*>/giu;\n        return html.replace(tagRegex, (match, tagName) => {\n          const tag = tagName.toLowerCase();\n          const allowedAttrs = this.allowedAttributes.get(tag) || /* @__PURE__ */ new Set();\n          const tagNameEndIndex = match.indexOf(tagName) + tagName.length;\n          const attributesStr = match.substring(tagNameEndIndex, match.length - 1);\n          if (!attributesStr || !attributesStr.trim()) {\n            return `<${tag}>`;\n          }\n          const attrRegex = /\\s+([a-z][a-z0-9-]*)\\s*=\\s*[\"']([^\"']*)[\"']/giu;\n          let filteredAttributes = \"\";\n          let attrExecMatch;\n          while ((attrExecMatch = attrRegex.exec(attributesStr)) !== null) {\n            const [, attrName, attrValue] = attrExecMatch;\n            const attr = attrName.toLowerCase();\n            if (allowedAttrs.has(attr)) {\n              if (this.isValidAttributeValue(attr, attrValue)) {\n                filteredAttributes += ` ${attrName}=\"${attrValue}\"`;\n              } else {\n                threats.push(`Invalid attribute value: ${attr}=\"${attrValue}\"`);\n              }\n            } else {\n              threats.push(`Disallowed attribute: ${attr}`);\n            }\n          }\n          return `<${tagName}${filteredAttributes}>`;\n        });\n      }\n      isValidAttributeValue(_attr, value) {\n        const dangerousPatterns = [\n          /javascript\\s*:/i,\n          /vbscript\\s*:/i,\n          /data\\s*:(?!image\\/)/i,\n          /expression\\s*\\(/i\n        ];\n        return !dangerousPatterns.some((pattern) => pattern.test(value));\n      }\n    }\n    class CSRFProtector {\n      constructor(_config = {}) {\n        this.tokens = /* @__PURE__ */ new Map();\n      }\n      generateToken() {\n        const token = this.generateRandomToken();\n        const now = Date.now();\n        const expires = now + 24 * 60 * 60 * 1e3;\n        const csrfToken = {\n          token,\n          timestamp: now,\n          expires\n        };\n        this.tokens.set(token, csrfToken);\n        this.cleanupExpiredTokens();\n        return csrfToken;\n      }\n      validateToken(token) {\n        const csrfToken = this.tokens.get(token);\n        if (!csrfToken) {\n          return false;\n        }\n        if (Date.now() > csrfToken.expires) {\n          this.tokens.delete(token);\n          return false;\n        }\n        return true;\n      }\n      generateRandomToken() {\n        const array = new Uint8Array(32);\n        if (typeof crypto !== \"undefined\" && crypto.getRandomValues) {\n          crypto.getRandomValues(array);\n        } else {\n          for (let i = 0; i < array.length; i++) {\n            array[i] = Math.floor(Math.random() * 256);\n          }\n        }\n        return Array.from(array, (byte) => byte.toString(16).padStart(2, \"0\")).join(\"\");\n      }\n      cleanupExpiredTokens() {\n        const now = Date.now();\n        for (const [token, csrfToken] of this.tokens.entries()) {\n          if (now > csrfToken.expires) {\n            this.tokens.delete(token);\n          }\n        }\n      }\n    }\n    class SecurityManagerImpl {\n      constructor(config = {}, engine) {\n        this.eventCallbacks = [];\n        this.engine = engine;\n        this.config = {\n          xss: {\n            enabled: true,\n            allowedTags: config.xss?.allowedTags || void 0,\n            // 让 XSSProtector 使用默认值\n            allowedAttributes: config.xss?.allowedAttributes || void 0,\n            // 让 XSSProtector 使用默认值\n            stripIgnoreTag: true,\n            ...config.xss\n          },\n          csrf: {\n            enabled: true,\n            tokenName: \"_csrf_token\",\n            headerName: \"X-CSRF-Token\",\n            cookieName: \"csrf_token\",\n            sameSite: \"strict\",\n            ...config.csrf\n          },\n          csp: {\n            enabled: true,\n            directives: {\n              \"default-src\": [\"'self'\"],\n              \"script-src\": [\"'self'\", \"'unsafe-inline'\"],\n              \"style-src\": [\"'self'\", \"'unsafe-inline'\"],\n              \"img-src\": [\"'self'\", \"data:\", \"https:\"],\n              \"font-src\": [\"'self'\"],\n              \"connect-src\": [\"'self'\"],\n              \"frame-ancestors\": [\"'none'\"]\n            },\n            reportOnly: false,\n            reportUri: \"/csp-report\",\n            ...config.csp\n          },\n          clickjacking: {\n            enabled: true,\n            policy: \"deny\",\n            ...config.clickjacking\n          },\n          https: {\n            enabled: true,\n            hsts: {\n              maxAge: 31536e3,\n              // 1年\n              includeSubDomains: true,\n              preload: false,\n              ...config.https?.hsts\n            },\n            ...config.https\n          }\n        };\n        this.xssProtector = new XSSProtector(this.config.xss);\n        this.csrfProtector = new CSRFProtector(this.config.csrf);\n      }\n      sanitizeHTML(html) {\n        if (!this.config.xss.enabled) {\n          return {\n            safe: true,\n            sanitized: html,\n            threats: []\n          };\n        }\n        const result = this.xssProtector.sanitize(html);\n        if (!result.safe) {\n          this.reportSecurityEvent({\n            type: SecurityEventType.XSS_DETECTED,\n            message: \"XSS attempt detected and blocked\",\n            details: {\n              originalHTML: html,\n              sanitizedHTML: result.sanitized,\n              threats: result.threats\n            },\n            timestamp: Date.now()\n          });\n        }\n        return result;\n      }\n      sanitize(input) {\n        return this.sanitizeHTML(input).sanitized;\n      }\n      validateInput(input, type = \"text\") {\n        switch (type) {\n          case \"html\":\n            return this.sanitizeHTML(input).safe;\n          case \"url\":\n            try {\n              new URL(input);\n              return !input.toLowerCase().startsWith(\"javascript:\");\n            } catch {\n              return false;\n            }\n          case \"text\":\n          default:\n            return !/<[^>]*>/.test(input) && !/javascript\\s*:/i.test(input);\n        }\n      }\n      generateCSRFToken() {\n        if (!this.config.csrf.enabled) {\n          throw new Error(\"CSRF protection is disabled\");\n        }\n        return this.csrfProtector.generateToken();\n      }\n      validateCSRFToken(token) {\n        if (!this.config.csrf.enabled) {\n          return true;\n        }\n        const isValid = this.csrfProtector.validateToken(token);\n        if (!isValid) {\n          this.reportSecurityEvent({\n            type: SecurityEventType.CSRF_ATTACK,\n            message: \"Invalid CSRF token detected\",\n            details: { token },\n            timestamp: Date.now()\n          });\n        }\n        return isValid;\n      }\n      getCSRFToken() {\n        if (!this.config.csrf.enabled) {\n          return null;\n        }\n        if (typeof document !== \"undefined\") {\n          const meta = document.querySelector(`meta[name=\"${this.config.csrf.tokenName}\"]`);\n          if (meta) {\n            return meta.getAttribute(\"content\");\n          }\n        }\n        return null;\n      }\n      generateCSPHeader() {\n        if (!this.config.csp.enabled) {\n          return \"\";\n        }\n        const directives = Object.entries(this.config.csp.directives || {}).map(([key, values]) => `${key} ${values.join(\" \")}`).join(\"; \");\n        const headerName = this.config.csp.reportOnly ? \"Content-Security-Policy-Report-Only\" : \"Content-Security-Policy\";\n        return `${headerName}: ${directives}`;\n      }\n      reportCSPViolation(violation) {\n        this.reportSecurityEvent({\n          type: SecurityEventType.CSP_VIOLATION,\n          message: \"Content Security Policy violation\",\n          details: violation,\n          timestamp: Date.now()\n        });\n      }\n      getSecurityHeaders() {\n        const headers = {};\n        if (this.config.csp.enabled) {\n          const cspHeader = this.generateCSPHeader();\n          if (cspHeader) {\n            const [headerName, headerValue] = cspHeader.split(\": \", 2);\n            headers[headerName] = headerValue;\n          }\n        }\n        if (this.config.clickjacking.enabled) {\n          switch (this.config.clickjacking.policy) {\n            case \"deny\":\n              headers[\"X-Frame-Options\"] = \"DENY\";\n              break;\n            case \"sameorigin\":\n              headers[\"X-Frame-Options\"] = \"SAMEORIGIN\";\n              break;\n            case \"allow-from\":\n              if (this.config.clickjacking.allowFrom) {\n                headers[\"X-Frame-Options\"] = `ALLOW-FROM ${this.config.clickjacking.allowFrom}`;\n              }\n              break;\n          }\n        }\n        if (this.config.https.enabled) {\n          const { hsts } = this.config.https;\n          if (hsts) {\n            let hstsValue = `max-age=${hsts.maxAge}`;\n            if (hsts.includeSubDomains) {\n              hstsValue += \"; includeSubDomains\";\n            }\n            if (hsts.preload) {\n              hstsValue += \"; preload\";\n            }\n            headers[\"Strict-Transport-Security\"] = hstsValue;\n          }\n        }\n        headers[\"X-Content-Type-Options\"] = \"nosniff\";\n        headers[\"X-XSS-Protection\"] = \"1; mode=block\";\n        headers[\"Referrer-Policy\"] = \"strict-origin-when-cross-origin\";\n        return headers;\n      }\n      onSecurityEvent(callback) {\n        this.eventCallbacks.push(callback);\n      }\n      reportSecurityEvent(event) {\n        if (this.engine?.logger) {\n          this.engine.logger.warn(\"Security event detected\", event);\n        }\n        this.eventCallbacks.forEach((callback) => {\n          try {\n            callback(event);\n          } catch (error) {\n            if (this.engine?.logger) {\n              this.engine.logger.error(\"Error in security event callback\", error);\n            }\n          }\n        });\n        if (this.engine?.events) {\n          this.engine.events.emit(\"security:event\", event);\n        }\n      }\n      updateConfig(config) {\n        this.config = {\n          ...this.config,\n          ...config,\n          xss: { ...this.config.xss, ...config.xss },\n          csrf: { ...this.config.csrf, ...config.csrf },\n          csp: { ...this.config.csp, ...config.csp },\n          clickjacking: { ...this.config.clickjacking, ...config.clickjacking },\n          https: { ...this.config.https, ...config.https }\n        };\n        this.xssProtector = new XSSProtector(this.config.xss);\n        this.csrfProtector = new CSRFProtector(this.config.csrf);\n      }\n      getConfig() {\n        return JSON.parse(JSON.stringify(this.config));\n      }\n    }\n    function createSecurityManager(config, engine) {\n      return new SecurityManagerImpl(config, engine);\n    }\n\n    class StateManagerImpl {\n      constructor(logger) {\n        this.logger = logger;\n        this.state = vue.reactive({});\n        this.watchers = /* @__PURE__ */ new Map();\n        this.changeHistory = [];\n        this.maxHistorySize = 100;\n        this.batchUpdates = /* @__PURE__ */ new Set();\n      }\n      get(key) {\n        return this.getNestedValue(this.state, key);\n      }\n      set(key, value) {\n        try {\n          const oldValue = this.getNestedValue(this.state, key);\n          this.recordChange(key, oldValue, value);\n          this.setNestedValue(this.state, key, value);\n          this.triggerWatchers(key, value, oldValue);\n        } catch (error) {\n          this.logger?.error(\"Failed to set state\", { key, value, error });\n          throw error;\n        }\n      }\n      remove(key) {\n        this.deleteNestedValue(this.state, key);\n      }\n      clear() {\n        this.watchers.clear();\n        Object.keys(this.state).forEach((key) => {\n          delete this.state[key];\n        });\n      }\n      watch(key, callback) {\n        if (!this.watchers.has(key)) {\n          this.watchers.set(key, []);\n        }\n        this.watchers.get(key).push(callback);\n        return () => {\n          const callbacks = this.watchers.get(key);\n          if (callbacks) {\n            const index = callbacks.indexOf(callback);\n            if (index > -1) {\n              callbacks.splice(index, 1);\n            }\n            if (callbacks.length === 0) {\n              this.watchers.delete(key);\n            }\n          }\n        };\n      }\n      triggerWatchers(key, newValue, oldValue) {\n        const callbacks = this.watchers.get(key);\n        if (callbacks) {\n          callbacks.forEach((callback) => {\n            try {\n              callback(newValue, oldValue);\n            } catch (error) {\n              this.logger?.error(\"Error in state watcher callback\", { key, error });\n            }\n          });\n        }\n      }\n      // 获取嵌套值\n      getNestedValue(obj, path) {\n        const keys = path.split(\".\");\n        let current = obj;\n        for (const key of keys) {\n          if (current === null || current === void 0 || typeof current !== \"object\") {\n            return void 0;\n          }\n          const rec = current;\n          current = rec[key];\n        }\n        return current;\n      }\n      // 设置嵌套值\n      setNestedValue(obj, path, value) {\n        const keys = path.split(\".\");\n        let current = obj;\n        for (let i = 0; i < keys.length - 1; i++) {\n          const key = keys[i];\n          const next = current[key];\n          if (typeof next !== \"object\" || next === null || Array.isArray(next)) {\n            current[key] = {};\n          }\n          current = current[key];\n        }\n        current[keys[keys.length - 1]] = value;\n      }\n      // 删除嵌套值\n      deleteNestedValue(obj, path) {\n        const keys = path.split(\".\");\n        let current = obj;\n        for (let i = 0; i < keys.length - 1; i++) {\n          if (current === null || current === void 0 || typeof current !== \"object\") {\n            return;\n          }\n          const rec = current;\n          const key = keys[i];\n          const next = rec[key];\n          if (typeof next !== \"object\" || next === null) {\n            return;\n          }\n          current = next;\n        }\n        if (current && typeof current === \"object\") {\n          delete current[keys[keys.length - 1]];\n        }\n      }\n      // 检查键是否存在\n      has(key) {\n        return this.getNestedValue(this.state, key) !== void 0;\n      }\n      // 获取所有键\n      keys() {\n        return this.getAllKeys(this.state);\n      }\n      // 递归获取所有键\n      getAllKeys(obj, prefix = \"\") {\n        const keys = [];\n        for (const key of Object.keys(obj)) {\n          const fullKey = prefix ? `${prefix}.${key}` : key;\n          keys.push(fullKey);\n          const val = obj[key];\n          if (typeof val === \"object\" && val !== null && !Array.isArray(val)) {\n            keys.push(...this.getAllKeys(val, fullKey));\n          }\n        }\n        return keys;\n      }\n      // 获取状态快照\n      getSnapshot() {\n        return JSON.parse(JSON.stringify(this.state));\n      }\n      // 从快照恢复状态\n      restoreFromSnapshot(snapshot) {\n        this.clear();\n        Object.assign(this.state, snapshot);\n      }\n      // 合并状态\n      merge(newState) {\n        this.deepMerge(this.state, newState);\n      }\n      // 深度合并对象\n      deepMerge(target, source) {\n        for (const key of Object.keys(source)) {\n          const sVal = source[key];\n          if (sVal && typeof sVal === \"object\" && !Array.isArray(sVal)) {\n            const tVal = target[key];\n            if (!tVal || typeof tVal !== \"object\" || Array.isArray(tVal)) {\n              target[key] = {};\n            }\n            this.deepMerge(target[key], sVal);\n          } else {\n            target[key] = sVal;\n          }\n        }\n      }\n      // 获取状态统计信息\n      getStats() {\n        const totalWatchers = Array.from(this.watchers.values()).reduce((sum, array) => sum + array.length, 0);\n        const memoryUsage = JSON.stringify(this.state).length;\n        return {\n          totalKeys: this.keys().length,\n          totalWatchers,\n          memoryUsage: `${(memoryUsage / 1024).toFixed(2)} KB`\n        };\n      }\n      // 创建命名空间\n      namespace(ns) {\n        return new StateNamespace(this, ns);\n      }\n      // 记录变更历史\n      recordChange(path, oldValue, newValue) {\n        this.changeHistory.unshift({\n          path,\n          oldValue,\n          newValue,\n          timestamp: Date.now()\n        });\n        if (this.changeHistory.length > this.maxHistorySize) {\n          this.changeHistory = this.changeHistory.slice(0, this.maxHistorySize);\n        }\n      }\n      // 批量更新优化（暂未使用，移除以通过严格类型检查）\n      // private batchUpdate(key: string, updateFn: () => void): void {\n      //   this.batchUpdates.add(key)\n      //\n      //   if (this.batchTimeout) {\n      //     clearTimeout(this.batchTimeout)\n      //   }\n      //\n      //   this.batchTimeout = setTimeout(() => {\n      //     const updates = Array.from(this.batchUpdates)\n      //     this.batchUpdates.clear()\n      //     this.batchTimeout = null\n      //\n      //     // 执行批量更新\n      //     updateFn()\n      //\n      //     this.logger?.debug('Batch state update completed', { keys: updates })\n      //   }, 0) // 下一个事件循环执行\n      // }\n      // 获取变更历史\n      getChangeHistory(limit) {\n        return limit ? this.changeHistory.slice(0, limit) : [...this.changeHistory];\n      }\n      // 清除变更历史\n      clearHistory() {\n        this.changeHistory = [];\n      }\n      // 撤销最后一次变更\n      undo() {\n        const lastChange = this.changeHistory.shift();\n        if (!lastChange) {\n          return false;\n        }\n        try {\n          const originalMaxSize = this.maxHistorySize;\n          this.maxHistorySize = 0;\n          this.setNestedValue(this.state, lastChange.path, lastChange.oldValue);\n          this.maxHistorySize = originalMaxSize;\n          this.logger?.debug(\"State change undone\", lastChange);\n          return true;\n        } catch (error) {\n          this.logger?.error(\"Failed to undo state change\", {\n            change: lastChange,\n            error\n          });\n          return false;\n        }\n      }\n      // 获取性能统计\n      getPerformanceStats() {\n        const now = Date.now();\n        const recentChanges = this.changeHistory.filter(\n          (change) => now - change.timestamp < 6e4\n          // 最近1分钟\n        ).length;\n        const memoryUsage = JSON.stringify(this.state).length + JSON.stringify(this.changeHistory).length;\n        return {\n          totalChanges: this.changeHistory.length,\n          recentChanges,\n          batchedUpdates: this.batchUpdates.size,\n          memoryUsage\n        };\n      }\n    }\n    class StateNamespace {\n      constructor(stateManager, namespaceName) {\n        this.stateManager = stateManager;\n        this.namespaceName = namespaceName;\n      }\n      getKey(key) {\n        return `${this.namespaceName}.${key}`;\n      }\n      get(key) {\n        return this.stateManager.get(this.getKey(key));\n      }\n      set(key, value) {\n        this.stateManager.set(this.getKey(key), value);\n      }\n      remove(key) {\n        this.stateManager.remove(this.getKey(key));\n      }\n      has(key) {\n        return this.stateManager.has(this.getKey(key));\n      }\n      watch(key, callback) {\n        return this.stateManager.watch(this.getKey(key), callback);\n      }\n      clear() {\n        const keys = this.stateManager.keys();\n        const namespacePrefix = `${this.namespaceName}.`;\n        keys.forEach((key) => {\n          if (key.startsWith(namespacePrefix)) {\n            this.stateManager.remove(key);\n          }\n        });\n      }\n      keys() {\n        const allKeys = this.stateManager.keys();\n        const namespacePrefix = `${this.namespaceName}.`;\n        return allKeys.filter((key) => key.startsWith(namespacePrefix)).map((key) => key.substring(namespacePrefix.length));\n      }\n      namespace(name) {\n        return this.stateManager.namespace(`${this.namespaceName}.${name}`);\n      }\n    }\n    function createStateManager(logger) {\n      return new StateManagerImpl(logger);\n    }\n\n    class ManagerRegistry {\n      constructor(logger) {\n        this.managers = /* @__PURE__ */ new Map();\n        this.initOrder = [];\n        this.logger = logger;\n      }\n      // 注册管理器\n      register(name, dependencies = [], lazy = false) {\n        if (this.managers.has(name)) {\n          this.logger?.warn(`Manager \"${name}\" already registered`);\n          return;\n        }\n        const status = {\n          name,\n          initialized: false,\n          dependencies,\n          dependents: [],\n          lazy\n        };\n        this.managers.set(name, status);\n        dependencies.forEach((dep) => {\n          const depStatus = this.managers.get(dep);\n          if (depStatus) {\n            depStatus.dependents.push(name);\n          }\n        });\n        this.logger?.debug(`Manager \"${name}\" registered`, {\n          dependencies,\n          lazy\n        });\n      }\n      // 标记管理器为已初始化\n      markInitialized(name, error) {\n        const status = this.managers.get(name);\n        if (!status) {\n          this.logger?.warn(`Manager \"${name}\" not found in registry`);\n          return;\n        }\n        status.initialized = !error;\n        status.initTime = Date.now();\n        status.error = error;\n        if (!error) {\n          this.initOrder.push(name);\n          this.logger?.debug(`Manager \"${name}\" initialized successfully`);\n        } else {\n          this.logger?.error(`Manager \"${name}\" initialization failed`, error);\n        }\n      }\n      // 检查依赖是否满足\n      checkDependencies(name) {\n        const status = this.managers.get(name);\n        if (!status) {\n          return { satisfied: false, missing: [name] };\n        }\n        const missing = [];\n        for (const dep of status.dependencies) {\n          const depStatus = this.managers.get(dep);\n          if (!depStatus || !depStatus.initialized) {\n            missing.push(dep);\n          }\n        }\n        return {\n          satisfied: missing.length === 0,\n          missing\n        };\n      }\n      // 获取初始化顺序建议\n      getInitializationOrder() {\n        const order = [];\n        const visited = /* @__PURE__ */ new Set();\n        const visiting = /* @__PURE__ */ new Set();\n        const visit = (name) => {\n          if (visited.has(name))\n            return;\n          if (visiting.has(name)) {\n            throw new Error(`Circular dependency detected involving \"${name}\"`);\n          }\n          visiting.add(name);\n          const status = this.managers.get(name);\n          if (status && !status.lazy) {\n            status.dependencies.forEach((dep) => {\n              const depStatus = this.managers.get(dep);\n              if (depStatus && !depStatus.lazy) {\n                visit(dep);\n              }\n            });\n            order.push(name);\n          }\n          visiting.delete(name);\n          visited.add(name);\n        };\n        for (const [name, status] of this.managers) {\n          if (!status.lazy) {\n            visit(name);\n          }\n        }\n        return order;\n      }\n      // 获取管理器状态\n      getStatus(name) {\n        return this.managers.get(name);\n      }\n      // 获取所有管理器状态\n      getAllStatus() {\n        return Array.from(this.managers.values());\n      }\n      // 获取初始化统计\n      getInitializationStats() {\n        const all = this.getAllStatus();\n        const initialized = all.filter((s) => s.initialized);\n        const failed = all.filter((s) => s.error);\n        const lazy = all.filter((s) => s.lazy);\n        const initTimes = initialized.map((s) => s.initTime).filter((t) => t !== void 0);\n        const averageInitTime = initTimes.length > 0 ? initTimes.reduce((sum, time) => sum + time, 0) / initTimes.length : 0;\n        return {\n          total: all.length,\n          initialized: initialized.length,\n          failed: failed.length,\n          lazy: lazy.length,\n          initOrder: [...this.initOrder],\n          averageInitTime\n        };\n      }\n      // 验证依赖图的完整性\n      validateDependencyGraph() {\n        const errors = [];\n        const warnings = [];\n        try {\n          this.getInitializationOrder();\n        } catch (error) {\n          errors.push(error.message);\n        }\n        for (const [name, status] of this.managers) {\n          for (const dep of status.dependencies) {\n            if (!this.managers.has(dep)) {\n              errors.push(`Manager \"${name}\" depends on missing manager \"${dep}\"`);\n            }\n          }\n        }\n        for (const [name, status] of this.managers) {\n          if (status.dependencies.length === 0 && status.dependents.length === 0) {\n            warnings.push(`Manager \"${name}\" has no dependencies or dependents`);\n          }\n        }\n        return {\n          valid: errors.length === 0,\n          errors,\n          warnings\n        };\n      }\n      // 生成依赖图的可视化表示\n      generateDependencyGraph() {\n        let graph = \"digraph ManagerDependencies {\\n\";\n        graph += \"  rankdir=TB;\\n\";\n        graph += \"  node [shape=box];\\n\\n\";\n        for (const [name, status] of this.managers) {\n          const color = status.lazy ? \"lightblue\" : \"lightgreen\";\n          const style = status.initialized ? \"solid\" : \"dashed\";\n          graph += `  \"${name}\" [fillcolor=${color}, style=\"filled, ${style}\"];\n`;\n        }\n        graph += \"\\n\";\n        for (const [name, status] of this.managers) {\n          for (const dep of status.dependencies) {\n            graph += `  \"${dep}\" -> \"${name}\";\n`;\n          }\n        }\n        graph += \"}\\n\";\n        return graph;\n      }\n      // 清理注册表\n      clear() {\n        this.managers.clear();\n        this.initOrder = [];\n        this.logger?.debug(\"Manager registry cleared\");\n      }\n    }\n\n    class EngineImpl {\n      /**\n       * 懒加载缓存管理器访问器\n       *\n       * 使用懒加载模式来优化应用启动性能，只有在实际需要缓存功能时才初始化\n       * 缓存管理器。这种方式可以显著减少应用的初始化时间。\n       *\n       * @returns {CacheManager} 缓存管理器实例\n       *\n       * @example\n       * ```typescript\n       * // 第一次访问时会自动初始化\n       * const cache = engine.cache\n       * cache.set('key', 'value')\n       * ```\n       */\n      get cache() {\n        if (!this._cache) {\n          const startTime = Date.now();\n          this._cache = createCacheManager(this.config.get(\"cache\", {}));\n          const initTime = Date.now() - startTime;\n          this.managerRegistry.markInitialized(\"cache\");\n          this.logger.debug(\"Cache manager initialized lazily\", {\n            initTime: `${initTime}ms`\n          });\n        }\n        return this._cache;\n      }\n      /**\n       * 懒加载性能管理器访问器\n       *\n       * 性能管理器用于监控和优化应用性能，包括：\n       * - 应用加载时间监控\n       * - 组件渲染性能监控\n       * - 内存使用情况监控\n       * - 网络请求性能监控\n       *\n       * @returns {PerformanceManager} 性能管理器实例\n       */\n      get performance() {\n        if (!this._performance) {\n          const startTime = Date.now();\n          this._performance = createPerformanceManager(void 0, this);\n          const initTime = Date.now() - startTime;\n          this.managerRegistry.markInitialized(\"performance\");\n          this.logger.debug(\"Performance manager initialized lazily\", {\n            initTime: `${initTime}ms`\n          });\n        }\n        return this._performance;\n      }\n      /**\n       * 懒加载安全管理器访问器\n       *\n       * 安全管理器提供应用安全防护功能，包括：\n       * - XSS 攻击防护\n       * - CSRF 攻击防护\n       * - 内容安全策略 (CSP)\n       * - 输入验证和清理\n       * - 敏感操作权限检查\n       *\n       * @returns {SecurityManager} 安全管理器实例\n       */\n      get security() {\n        if (!this._security) {\n          const startTime = Date.now();\n          this._security = createSecurityManager(void 0, this);\n          const initTime = Date.now() - startTime;\n          this.managerRegistry.markInitialized(\"security\");\n          this.logger.debug(\"Security manager initialized lazily\", {\n            initTime: `${initTime}ms`\n          });\n        }\n        return this._security;\n      }\n      /**\n       * 构造函数 - 按照依赖顺序初始化所有管理器\n       *\n       * 初始化顺序非常重要：\n       * 1. 配置管理器 - 其他组件需要读取配置\n       * 2. 日志器 - 所有组件都需要记录日志\n       * 3. 管理器注册表 - 管理组件依赖关系\n       * 4. 环境管理器 - 提供运行环境信息\n       * 5. 生命周期管理器 - 管理组件生命周期\n       * 6. 其他核心管理器 - 按依赖关系顺序初始化\n       *\n       * @param config 引擎配置对象\n       */\n      constructor(config = {}) {\n        this._mounted = false;\n        this._isReady = false;\n        this.managerFactories = {\n          events: () => createEventManager(this.logger),\n          state: () => createStateManager(this.logger),\n          errors: () => createErrorManager(),\n          directives: () => createDirectiveManager(),\n          notifications: () => createNotificationManager(this.logger),\n          middleware: () => createMiddlewareManager(this.logger),\n          plugins: () => createPluginManager(this)\n        };\n        this.config = createConfigManager({\n          debug: false,\n          ...config\n        });\n        this.config.setSchema(defaultConfigSchema);\n        this.logger = createLogger(this.config.get(\"debug\", false) ? \"debug\" : \"info\");\n        this.managerRegistry = new ManagerRegistry(this.logger);\n        this.registerManagers();\n        this.environment = createEnvironmentManager(this.logger);\n        this.lifecycle = createLifecycleManager(this.logger);\n        this.initializeManagers();\n        this.setupErrorHandling();\n        this.setupConfigWatchers();\n        this.logger.info(\"Engine initialized\", {\n          environment: this.config.getEnvironment(),\n          features: this.config.get(\"features\", {})\n        });\n        this.lifecycle.execute(\"afterInit\", this).catch((error) => {\n          this.logger.error(\"Error in afterInit lifecycle hooks\", error);\n        });\n      }\n      /**\n       * 设置全局错误处理机制\n       *\n       * 这个方法设置了一个统一的错误处理系统，能够：\n       * 1. 捕获所有未处理的错误\n       * 2. 记录错误日志供调试使用\n       * 3. 发送错误事件供其他模块监听\n       * 4. 在调试模式下显示用户友好的错误通知\n       *\n       * @private\n       */\n      setupErrorHandling() {\n        this.errors.onError((errorInfo) => {\n          this.logger.error(\"Global error captured\", errorInfo);\n          this.events.emit(\"engine:error\", errorInfo);\n          if (this.config.get(\"debug\", false)) {\n            this.notifications.show({\n              type: \"error\",\n              title: \"Error Captured\",\n              message: errorInfo.message,\n              duration: 5e3\n              // 5秒后自动消失\n            });\n          }\n        });\n      }\n      /**\n       * 设置配置变化监听器\n       *\n       * @private\n       */\n      setupConfigWatchers() {\n        this.config.watch(\"debug\", (newValue) => {\n          this.logger.setLevel(newValue ? \"debug\" : \"info\");\n          this.logger.info(\"Debug mode changed\", { debug: newValue });\n        });\n        this.config.watch(\"logger.level\", (newValue) => {\n          const allowed = [\"debug\", \"info\", \"warn\", \"error\"];\n          const level = typeof newValue === \"string\" && allowed.includes(newValue) ? newValue : this.logger.getLevel();\n          this.logger.setLevel(level);\n          this.logger.info(\"Log level changed\", { level });\n        });\n      }\n      // 核心方法\n      async init() {\n        this._isReady = true;\n      }\n      isReady() {\n        return this._isReady;\n      }\n      // 创建Vue应用\n      createApp(rootComponent) {\n        if (this._app) {\n          this.logger.warn(\"Vue app already created\");\n          return this._app;\n        }\n        this._app = vue.createApp(rootComponent);\n        this.install(this._app);\n        this.events.emit(\"app:created\", this._app);\n        this.logger.info(\"Vue app created with engine\");\n        return this._app;\n      }\n      install(app) {\n        if (this._app && this._app !== app) {\n          this.logger.warn(\"Engine already installed to different app\");\n          return;\n        }\n        this._app = app;\n        app.config.globalProperties.$engine = this;\n        app.provide(\"engine\", this);\n        const directiveNames = this.directives.getNames();\n        directiveNames.forEach((name) => {\n          const eng = this.directives.get(name);\n          if (eng) {\n            const vueDir = convertEngineToVueDirective(eng);\n            app.directive(name, vueDir);\n          }\n        });\n        app.config.errorHandler = (error, component, info) => {\n          this.errors.captureError(error, component || void 0, info);\n        };\n        if (this.router && typeof this.router.install === \"function\") {\n          this.router.install(this);\n        }\n        if (this.store && typeof this.store.install === \"function\") {\n          this.store.install(this);\n        }\n        if (this.i18n && typeof this.i18n.install === \"function\") {\n          this.i18n.install(this);\n        }\n        if (this.theme && typeof this.theme.install === \"function\") {\n          this.theme.install(this);\n        }\n        this.logger.info(\"Engine installed to Vue app\");\n        this.events.emit(\"engine:installed\", { app });\n      }\n      async use(plugin) {\n        await this.plugins.register(plugin);\n      }\n      async mount(selector) {\n        if (!this._app) {\n          throw new Error(\"Engine must have a Vue app before mounting. Use createApp() first.\");\n        }\n        if (this._mounted) {\n          this.logger.warn(\"Engine already mounted\");\n          return;\n        }\n        await this.lifecycle.execute(\"beforeMount\", this);\n        this._mountTarget = selector;\n        this._app.mount(selector);\n        this._mounted = true;\n        this.logger.info(\"Engine mounted\", { target: selector });\n        this.events.emit(\"engine:mounted\", { target: selector });\n        await this.lifecycle.execute(\"afterMount\", this);\n      }\n      async unmount() {\n        if (!this._app || !this._mounted) {\n          this.logger.warn(\"Engine not mounted\");\n          return;\n        }\n        await this.lifecycle.execute(\"beforeUnmount\", this);\n        this._app.unmount();\n        this._mounted = false;\n        this.logger.info(\"Engine unmounted\");\n        this.events.emit(\"engine:unmounted\");\n        await this.lifecycle.execute(\"afterUnmount\", this);\n      }\n      // 扩展方法\n      setRouter(router) {\n        this.router = router;\n        if (this._app) {\n          router.install(this);\n        }\n        this.logger.info(\"Router adapter set\");\n      }\n      setStore(store) {\n        this.store = store;\n        if (this._app) {\n          store.install(this);\n        }\n        this.logger.info(\"Store adapter set\");\n      }\n      setI18n(i18n) {\n        this.i18n = i18n;\n        if (this._app) {\n          i18n.install(this);\n        }\n        this.logger.info(\"I18n adapter set\");\n      }\n      setTheme(theme) {\n        this.theme = theme;\n        if (this._app) {\n          theme.install(this);\n        }\n        this.logger.info(\"Theme adapter set\");\n      }\n      // 获取Vue应用实例\n      getApp() {\n        return this._app;\n      }\n      // 检查是否已挂载\n      isMounted() {\n        return this._mounted;\n      }\n      // 获取挂载目标\n      getMountTarget() {\n        return this._mountTarget;\n      }\n      // 销毁引擎\n      async destroy() {\n        await this.lifecycle.execute(\"beforeDestroy\", this);\n        if (this._mounted) {\n          await this.unmount();\n        }\n        this.events.emit(\"engine:destroy\");\n        this.errors.clearErrors();\n        this.logger.clearLogs();\n        this.notifications.hideAll();\n        this.state.clear();\n        if (this._cache) {\n          this._cache.clear();\n        }\n        if (this._performance) ;\n        this.config.disableAutoSave();\n        this.logger.info(\"Engine destroyed\");\n        await this.lifecycle.execute(\"afterDestroy\", this);\n      }\n      // 配置相关方法\n      updateConfig(config) {\n        this.config.merge(config);\n        this.logger.info(\"Engine configuration updated\", {\n          keys: Object.keys(config)\n        });\n      }\n      getConfig(path, defaultValue) {\n        return this.config.get(path, defaultValue);\n      }\n      setConfig(path, value) {\n        this.config.set(path, value);\n        this.logger.debug(\"Engine configuration set\", { path, value });\n      }\n      // 获取管理器初始化统计\n      getManagerStats() {\n        return this.managerRegistry.getInitializationStats();\n      }\n      // 验证管理器依赖图\n      validateManagers() {\n        const { valid, errors } = this.managerRegistry.validateDependencyGraph();\n        return { valid, errors };\n      }\n      // 私有方法：注册管理器\n      registerManagers() {\n        this.managerRegistry.register(\"config\", []);\n        this.managerRegistry.register(\"logger\", [\"config\"]);\n        this.managerRegistry.register(\"environment\", [\"logger\"]);\n        this.managerRegistry.register(\"events\", [\"logger\"]);\n        this.managerRegistry.register(\"state\", [\"logger\"]);\n        this.managerRegistry.register(\"errors\", []);\n        this.managerRegistry.register(\"directives\", []);\n        this.managerRegistry.register(\"notifications\", [\"logger\"]);\n        this.managerRegistry.register(\"middleware\", [\"logger\"]);\n        this.managerRegistry.register(\"plugins\", [\"events\", \"state\", \"middleware\"]);\n        this.managerRegistry.register(\"cache\", [\"config\"], true);\n        this.managerRegistry.register(\"performance\", [\"config\", \"logger\"], true);\n        this.managerRegistry.register(\"security\", [\"config\", \"logger\"], true);\n        this.logger.debug(\"Managers registered in registry\");\n      }\n      // 私有方法：初始化管理器\n      initializeManagers() {\n        try {\n          const validation = this.managerRegistry.validateDependencyGraph();\n          if (!validation.valid) {\n            this.logger.error(\"Manager dependency validation failed\", {\n              errors: validation.errors,\n              warnings: validation.warnings\n            });\n          }\n          const initOrder = this.managerRegistry.getInitializationOrder();\n          this.logger.debug(\"Manager initialization order\", { order: initOrder });\n          this.initializeManagersInOrder(initOrder);\n        } catch (error) {\n          this.logger.error(\"Failed to initialize managers\", error);\n          throw error;\n        }\n      }\n      // 私有方法：按顺序初始化管理器\n      initializeManagersInOrder(order) {\n        for (const managerName of order) {\n          this.initializeSingleManager(managerName);\n        }\n      }\n      // 私有方法：初始化单个管理器\n      initializeSingleManager(managerName) {\n        try {\n          const startTime = Date.now();\n          if ([\"config\", \"logger\", \"environment\"].includes(managerName)) {\n            this.managerRegistry.markInitialized(managerName);\n            this.logger.debug(`Manager \"${managerName}\" already initialized`);\n            return;\n          }\n          const factory = this.managerFactories[managerName];\n          if (!factory) {\n            this.logger.warn(`Unknown manager: ${managerName}`);\n            return;\n          }\n          const manager = factory();\n          this.assignManagerToProperty(managerName, manager);\n          const initTime = Date.now() - startTime;\n          this.managerRegistry.markInitialized(managerName);\n          this.logger.debug(`Manager \"${managerName}\" initialized`, {\n            initTime: `${initTime}ms`\n          });\n        } catch (error) {\n          this.managerRegistry.markInitialized(managerName, error);\n          this.logger.error(`Failed to initialize manager \"${managerName}\"`, error);\n          throw error;\n        }\n      }\n      // 私有方法：将管理器分配到对应的属性\n      assignManagerToProperty(managerName, manager) {\n        switch (managerName) {\n          case \"events\":\n            this.events = manager;\n            break;\n          case \"state\":\n            this.state = manager;\n            break;\n          case \"errors\":\n            this.errors = manager;\n            break;\n          case \"directives\":\n            this.directives = manager;\n            break;\n          case \"notifications\":\n            this.notifications = manager;\n            break;\n          case \"middleware\":\n            this.middleware = manager;\n            break;\n          case \"plugins\":\n            this.plugins = manager;\n            break;\n        }\n      }\n    }\n\n    function createEngine(options = {}) {\n      const {\n        config = {},\n        plugins = [],\n        middleware = [],\n        configSchema,\n        enableAutoSave = false,\n        autoSaveInterval = 3e4,\n        // 30秒自动保存一次\n        rootComponent,\n        mountElement,\n        autoMount = false\n      } = options;\n      const engine = new EngineImpl(config);\n      if (configSchema) {\n        engine.config.setSchema(configSchema);\n      }\n      if (enableAutoSave) {\n        engine.config.enableAutoSave(autoSaveInterval);\n      }\n      engine.directives.registerBatch(commonDirectives);\n      middleware.forEach((m) => {\n        engine.middleware.use(m);\n      });\n      const pluginPromise = Promise.all(plugins.map((plugin) => engine.use(plugin)));\n      if (rootComponent) {\n        engine.createApp(rootComponent);\n        if (autoMount && mountElement) {\n          pluginPromise.then(async () => {\n            try {\n              await engine.mount(mountElement);\n            } catch (error) {\n              engine.logger.error(\"Failed to mount application\", error);\n            }\n          }).catch((error) => {\n            engine.logger.error(\"Plugin installation failed, cannot mount application\", error);\n          });\n        }\n      }\n      return engine;\n    }\n    function createApp(rootComponent, options = {}) {\n      const enhancedOptions = {\n        ...options,\n        rootComponent\n      };\n      return createEngine(enhancedOptions);\n    }\n    function createAndMountApp(rootComponent, mountElement, options = {}) {\n      return createEngine({\n        ...options,\n        rootComponent,\n        mountElement,\n        autoMount: true\n      });\n    }\n\n    var factory = /*#__PURE__*/Object.freeze({\n        __proto__: null,\n        createAndMountApp: createAndMountApp,\n        createApp: createApp,\n        createEngine: createEngine\n    });\n\n    function useEngine() {\n      const injectedEngine = vue.inject(\"engine\");\n      if (injectedEngine) {\n        return injectedEngine;\n      }\n      const instance = vue.getCurrentInstance();\n      if (instance?.appContext.app.config.globalProperties.$engine) {\n        return instance.appContext.app.config.globalProperties.$engine;\n      }\n      if (typeof window !== \"undefined\" && window.__LDESIGN_ENGINE__) {\n        return window.__LDESIGN_ENGINE__;\n      }\n      throw new Error(\"Engine instance not found. Make sure the engine is properly initialized and the Vue app is using the engine plugin.\");\n    }\n\n    const DEFAULT_CONFIG = {\n      debug: false,\n      appName: \"Vue3 Engine App\",\n      version: \"1.0.0\"\n    };\n    const PERFORMANCE_CONSTANTS = {\n      // 批处理配置\n      BATCH_PROCESSOR: {\n        DEFAULT_BATCH_SIZE: 20,\n        DEFAULT_INTERVAL: 5e3,\n        // 5秒\n        MAX_WAIT_TIME: 1e4\n        // 10秒\n      },\n      // 缓存优化\n      CACHE_OPTIMIZATION: {\n        CLEANUP_BATCH_SIZE: 20,\n        CLEANUP_INTERVAL: 5e3,\n        // 5秒\n        STATS_CLEANUP_INTERVAL: 3e5,\n        // 5分钟\n        MAX_SIZE_DEFAULT: 100,\n        DEFAULT_TTL: 3e5\n        // 5分钟\n      },\n      // 事件优化\n      EVENT_OPTIMIZATION: {\n        STATS_CLEANUP_INTERVAL: 3e5,\n        // 5分钟\n        BATCH_REMOVE_THRESHOLD: 10,\n        MAX_LISTENERS_DEFAULT: 100\n      },\n      // 内存管理\n      MEMORY_MANAGEMENT: {\n        OBJECT_POOL_MAX_SIZE: 100,\n        GC_THRESHOLD: 1e3\n        // 触发垃圾回收的阈值\n      },\n      // 性能阈值\n      THRESHOLDS: {\n        // 响应时间阈值（毫秒）\n        RESPONSE_TIME: {\n          EXCELLENT: 50,\n          GOOD: 100,\n          ACCEPTABLE: 500,\n          POOR: 1e3\n        },\n        // FPS阈值\n        FPS: {\n          EXCELLENT: 60,\n          GOOD: 45,\n          ACCEPTABLE: 30,\n          POOR: 15\n        },\n        // 内存使用阈值（MB）\n        MEMORY: {\n          LOW: 50,\n          WARNING: 100,\n          CRITICAL: 200,\n          EMERGENCY: 500\n        },\n        // 缓存命中率阈值\n        CACHE_HIT_RATE: {\n          EXCELLENT: 0.9,\n          GOOD: 0.8,\n          ACCEPTABLE: 0.6,\n          POOR: 0.4\n        }\n      }\n    };\n    const EVENTS = {\n      // 引擎生命周期事件\n      ENGINE_MOUNTED: \"engine:mounted\",\n      ENGINE_UNMOUNTED: \"engine:unmounted\",\n      ENGINE_ERROR: \"engine:error\",\n      ENGINE_READY: \"engine:ready\",\n      ENGINE_DESTROYED: \"engine:destroyed\",\n      // 插件相关事件\n      PLUGIN_REGISTERED: \"plugin:registered\",\n      PLUGIN_UNREGISTERED: \"plugin:unregistered\",\n      PLUGIN_INSTALLED: \"plugin:installed\",\n      PLUGIN_UNINSTALLED: \"plugin:uninstalled\",\n      PLUGIN_ERROR: \"plugin:error\",\n      // 中间件相关事件\n      MIDDLEWARE_ADDED: \"middleware:added\",\n      MIDDLEWARE_REMOVED: \"middleware:removed\",\n      MIDDLEWARE_EXECUTED: \"middleware:executed\",\n      // 状态管理事件\n      STATE_CHANGED: \"state:changed\",\n      STATE_RESET: \"state:reset\",\n      // 错误处理事件\n      ERROR_CAPTURED: \"error:captured\",\n      ERROR_HANDLED: \"error:handled\",\n      // 通知相关事件\n      NOTIFICATION_SHOWN: \"notification:shown\",\n      NOTIFICATION_HIDDEN: \"notification:hidden\",\n      NOTIFICATION_CLICKED: \"notification:clicked\",\n      // 性能监控事件\n      PERFORMANCE_MARK: \"performance:mark\",\n      PERFORMANCE_MEASURE: \"performance:measure\",\n      PERFORMANCE_THRESHOLD_VIOLATION: \"performance:threshold:violation\",\n      // 缓存相关事件\n      CACHE_HIT: \"cache:hit\",\n      CACHE_MISS: \"cache:miss\",\n      CACHE_EVICTED: \"cache:evicted\",\n      // 安全相关事件\n      SECURITY_VIOLATION: \"security:violation\",\n      SECURITY_BLOCKED: \"security:blocked\",\n      // 配置相关事件\n      CONFIG_CHANGED: \"config:changed\",\n      CONFIG_SAVED: \"config:saved\",\n      CONFIG_LOADED: \"config:loaded\",\n      // 生命周期事件\n      LIFECYCLE_BEFORE_INIT: \"lifecycle:before:init\",\n      LIFECYCLE_AFTER_INIT: \"lifecycle:after:init\",\n      LIFECYCLE_BEFORE_START: \"lifecycle:before:start\",\n      LIFECYCLE_AFTER_START: \"lifecycle:after:start\",\n      LIFECYCLE_BEFORE_STOP: \"lifecycle:before:stop\",\n      LIFECYCLE_AFTER_STOP: \"lifecycle:after:stop\",\n      LIFECYCLE_BEFORE_DESTROY: \"lifecycle:before:destroy\",\n      LIFECYCLE_AFTER_DESTROY: \"lifecycle:after:destroy\"\n    };\n    const LOG_LEVELS = [\"debug\", \"info\", \"warn\", \"error\"];\n    const NOTIFICATION_TYPES = [\n      \"success\",\n      \"error\",\n      \"warning\",\n      \"info\"\n    ];\n    const NOTIFICATION_POSITIONS = [\n      \"top-left\",\n      \"top-center\",\n      \"top-right\",\n      \"bottom-left\",\n      \"bottom-center\",\n      \"bottom-right\"\n    ];\n    const NOTIFICATION_ANIMATIONS = [\n      \"slide\",\n      \"fade\",\n      \"bounce\",\n      \"scale\",\n      \"flip\"\n    ];\n    const NOTIFICATION_THEMES = [\"light\", \"dark\", \"auto\"];\n    const CACHE_STRATEGIES = [\"lru\", \"lfu\", \"fifo\", \"ttl\"];\n    const ENVIRONMENTS = [\"development\", \"production\", \"test\"];\n    const FEATURE_FLAGS = {\n      ENABLE_HOT_RELOAD: \"enableHotReload\",\n      ENABLE_DEV_TOOLS: \"enableDevTools\",\n      ENABLE_PERFORMANCE_MONITORING: \"enablePerformanceMonitoring\",\n      ENABLE_ERROR_REPORTING: \"enableErrorReporting\",\n      ENABLE_SECURITY_PROTECTION: \"enableSecurityProtection\",\n      ENABLE_CACHING: \"enableCaching\",\n      ENABLE_NOTIFICATIONS: \"enableNotifications\"\n    };\n    const PERFORMANCE_THRESHOLDS = {\n      RESPONSE_TIME: {\n        GOOD: 100,\n        // 100ms\n        POOR: 1e3\n        // 1s\n      },\n      FPS: {\n        GOOD: 60,\n        // 60fps\n        POOR: 30\n        // 30fps\n      },\n      MEMORY: {\n        WARNING: 50,\n        // 50MB\n        CRITICAL: 100\n        // 100MB\n      }\n    };\n    const SECURITY_CONFIG = {\n      XSS: {\n        ALLOWED_TAGS: [\"b\", \"i\", \"em\", \"strong\", \"a\", \"span\", \"div\", \"p\"],\n        ALLOWED_ATTRIBUTES: {\n          a: [\"href\", \"title\", \"target\"],\n          img: [\"src\", \"alt\", \"title\"]\n        }\n      },\n      CSP: {\n        DIRECTIVES: {\n          \"default-src\": [\"self\"],\n          \"script-src\": [\"self\", \"unsafe-inline\"],\n          \"style-src\": [\"self\", \"unsafe-inline\"],\n          \"img-src\": [\"self\", \"data:\", \"https:\"]\n        }\n      }\n    };\n    const STORAGE_KEYS = {\n      ENGINE_CONFIG: \"engine-config\",\n      ENGINE_LOGS: \"engine-logs\",\n      ENGINE_CACHE: \"engine-cache\",\n      ENGINE_STATE: \"engine-state\",\n      ENGINE_NOTIFICATIONS: \"engine-notifications\"\n    };\n    const ERROR_CODES = {\n      // 配置相关错误\n      CONFIG_INVALID: \"CONFIG_INVALID\",\n      CONFIG_MISSING: \"CONFIG_MISSING\",\n      CONFIG_VALIDATION_FAILED: \"CONFIG_VALIDATION_FAILED\",\n      // 插件相关错误\n      PLUGIN_INSTALL_FAILED: \"PLUGIN_INSTALL_FAILED\",\n      PLUGIN_DEPENDENCY_MISSING: \"PLUGIN_DEPENDENCY_MISSING\",\n      PLUGIN_CONFLICT: \"PLUGIN_CONFLICT\",\n      // 中间件相关错误\n      MIDDLEWARE_EXECUTION_FAILED: \"MIDDLEWARE_EXECUTION_FAILED\",\n      MIDDLEWARE_NOT_FOUND: \"MIDDLEWARE_NOT_FOUND\",\n      // 状态相关错误\n      STATE_INVALID: \"STATE_INVALID\",\n      STATE_ACCESS_DENIED: \"STATE_ACCESS_DENIED\",\n      // 缓存相关错误\n      CACHE_FULL: \"CACHE_FULL\",\n      CACHE_INVALID_KEY: \"CACHE_INVALID_KEY\",\n      // 安全相关错误\n      SECURITY_VIOLATION: \"SECURITY_VIOLATION\",\n      SECURITY_BLOCKED: \"SECURITY_BLOCKED\",\n      // 性能相关错误\n      PERFORMANCE_THRESHOLD_EXCEEDED: \"PERFORMANCE_THRESHOLD_EXCEEDED\",\n      PERFORMANCE_MONITORING_FAILED: \"PERFORMANCE_MONITORING_FAILED\"\n    };\n    const VERSION = {\n      CURRENT: \"0.1.0\",\n      MIN_SUPPORTED: \"0.1.0\",\n      API_VERSION: \"1.0.0\"\n    };\n    const TIME = {\n      SECOND: 1e3,\n      MINUTE: 60 * 1e3,\n      HOUR: 60 * 60 * 1e3,\n      DAY: 24 * 60 * 60 * 1e3,\n      // 默认间隔\n      DEFAULT_AUTO_SAVE_INTERVAL: 3e4,\n      // 30秒\n      DEFAULT_CACHE_CLEANUP_INTERVAL: 6e4,\n      // 1分钟\n      DEFAULT_PERFORMANCE_CHECK_INTERVAL: 5e3,\n      // 5秒\n      DEFAULT_HEALTH_CHECK_INTERVAL: 3e4\n      // 30秒\n    };\n    const LIMITS = {\n      // 缓存限制\n      MAX_CACHE_SIZE: 1e3,\n      MAX_CACHE_ENTRY_SIZE: 1024 * 1024,\n      // 1MB\n      // 日志限制\n      MAX_LOG_ENTRIES: 1e4,\n      MAX_LOG_ENTRY_SIZE: 1024,\n      // 1KB\n      // 通知限制\n      MAX_NOTIFICATIONS: 100,\n      MAX_NOTIFICATION_DURATION: 1e4,\n      // 10秒\n      // 插件限制\n      MAX_PLUGINS: 100,\n      MAX_PLUGIN_DEPENDENCIES: 50,\n      // 中间件限制\n      MAX_MIDDLEWARE: 100,\n      MAX_MIDDLEWARE_PRIORITY: 1e3,\n      // 状态限制\n      MAX_STATE_KEYS: 1e4,\n      MAX_STATE_VALUE_SIZE: 1024 * 1024\n      // 1MB\n    };\n\n    const version = \"0.1.0\";\n    async function install(app, options = {}) {\n      const { createEngine: createEngine2 } = await Promise.resolve().then(function () { return factory; });\n      const engine = createEngine2(options);\n      engine.install(app);\n      return engine;\n    }\n\n    exports.CACHE_STRATEGIES = CACHE_STRATEGIES;\n    exports.DEFAULT_CONFIG = DEFAULT_CONFIG;\n    exports.ENGINE_EVENTS = ENGINE_EVENTS;\n    exports.ENVIRONMENTS = ENVIRONMENTS;\n    exports.ERROR_CODES = ERROR_CODES;\n    exports.EVENTS = EVENTS;\n    exports.EngineImpl = EngineImpl;\n    exports.FEATURE_FLAGS = FEATURE_FLAGS;\n    exports.LIMITS = LIMITS;\n    exports.LOG_LEVELS = LOG_LEVELS;\n    exports.NOTIFICATION_ANIMATIONS = NOTIFICATION_ANIMATIONS;\n    exports.NOTIFICATION_POSITIONS = NOTIFICATION_POSITIONS;\n    exports.NOTIFICATION_THEMES = NOTIFICATION_THEMES;\n    exports.NOTIFICATION_TYPES = NOTIFICATION_TYPES;\n    exports.PERFORMANCE_CONSTANTS = PERFORMANCE_CONSTANTS;\n    exports.PERFORMANCE_THRESHOLDS = PERFORMANCE_THRESHOLDS;\n    exports.SECURITY_CONFIG = SECURITY_CONFIG;\n    exports.STORAGE_KEYS = STORAGE_KEYS;\n    exports.TIME = TIME;\n    exports.VERSION = VERSION;\n    exports.createAndMountApp = createAndMountApp;\n    exports.createApp = createApp;\n    exports.createConfigManager = createConfigManager;\n    exports.createEngine = createEngine;\n    exports.createEventManager = createEventManager;\n    exports.createLogger = createLogger;\n    exports.debounce = debounce;\n    exports.deepClone = deepClone;\n    exports.generateId = generateId;\n    exports.install = install;\n    exports.throttle = throttle;\n    exports.useEngine = useEngine;\n    exports.version = version;\n\n}));\n//# sourceMappingURL=index.js.map\n"
    }
  },
  "recommendations": []
}
