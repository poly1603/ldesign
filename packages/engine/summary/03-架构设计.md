# LDesign Engine - æ¶æ„è®¾è®¡

## ğŸ—ï¸ æ•´ä½“æ¶æ„

### åˆ†å±‚æ¶æ„å›¾

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                    åº”ç”¨å±‚ (Application Layer)                â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚
â”‚  â”‚   Vue App   â”‚ â”‚ React App   â”‚ â”‚ Angular App â”‚ â”‚   ...   â”‚ â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                    é€‚é…å±‚ (Adapter Layer)                    â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚
â”‚  â”‚ Vue Adapter â”‚ â”‚React Adapterâ”‚ â”‚Angular Adaptâ”‚ â”‚   ...   â”‚ â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                    æ’ä»¶å±‚ (Plugin Layer)                     â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚
â”‚  â”‚ UI Plugins  â”‚ â”‚State Pluginsâ”‚ â”‚Route Pluginsâ”‚ â”‚   ...   â”‚ â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                   ç®¡ç†å™¨å±‚ (Manager Layer)                   â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚
â”‚  â”‚   Config    â”‚ â”‚    State    â”‚ â”‚   Events    â”‚ â”‚   ...   â”‚ â”‚
â”‚  â”‚  Manager    â”‚ â”‚  Manager    â”‚ â”‚  Manager    â”‚ â”‚ Manager â”‚ â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                    æ ¸å¿ƒå±‚ (Core Layer)                       â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚
â”‚  â”‚   Engine    â”‚ â”‚  Registry   â”‚ â”‚ Lifecycle   â”‚ â”‚   DI    â”‚ â”‚
â”‚  â”‚    Core     â”‚ â”‚  Manager    â”‚ â”‚  Manager    â”‚ â”‚Containerâ”‚ â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                   åŸºç¡€å±‚ (Foundation Layer)                  â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚
â”‚  â”‚   Utils     â”‚ â”‚   Types     â”‚ â”‚ Constants   â”‚ â”‚ Helpers â”‚ â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### æ ¸å¿ƒç»„ä»¶å…³ç³»å›¾

```mermaid
graph TB
    Engine[Engine Core] --> Registry[Manager Registry]
    Engine --> Lifecycle[Lifecycle Manager]

    Registry --> Config[Config Manager]
    Registry --> State[State Manager]
    Registry --> Events[Event Manager]
    Registry --> Plugins[Plugin Manager]
    Registry --> Middleware[Middleware Manager]
    Registry --> Environment[Environment Manager]
    Registry --> Performance[Performance Manager]
    Registry --> Security[Security Manager]
    Registry --> Notifications[Notification Manager]
    Registry --> Errors[Error Manager]
    Registry --> Cache[Cache Manager]
    Registry --> Directives[Directive Manager]
    Registry --> Logger[Logger Manager]

    Plugins --> PluginA[Plugin A]
    Plugins --> PluginB[Plugin B]
    Plugins --> PluginC[Plugin C]

    Events --> EventBus[Event Bus]
    State --> StateStore[State Store]
    Config --> ConfigStore[Config Store]
```

## ğŸ”§ æ ¸å¿ƒæ¶æ„ç»„ä»¶

### 1. å¼•æ“æ ¸å¿ƒ (Engine Core)

**èŒè´£**: ç»Ÿä¸€ç®¡ç†å’Œåè°ƒæ‰€æœ‰åŠŸèƒ½æ¨¡å—

```typescript
class EngineImpl implements Engine {
  private registry: ManagerRegistry
  private lifecycle: LifecycleManager
  private initialized = false

  constructor(config?: EngineConfig) {
    this.registry = new ManagerRegistry()
    this.lifecycle = new LifecycleManager()
    this.registerCoreManagers()
    this.initializeWithConfig(config)
  }

  private registerCoreManagers() {
    // æ³¨å†Œæ ¸å¿ƒç®¡ç†å™¨
    this.registry.register('config', () => new ConfigManager(), [])
    this.registry.register('logger', () => new LoggerManager(), ['config'])
    this.registry.register('events', () => new EventManager(), ['logger'])
    // ... å…¶ä»–ç®¡ç†å™¨
  }
}
```

**ç‰¹æ€§**:
- ç»Ÿä¸€çš„å…¥å£ç‚¹
- ç”Ÿå‘½å‘¨æœŸç®¡ç†
- ä¾èµ–åè°ƒ
- é…ç½®ç®¡ç†

### 2. ç®¡ç†å™¨æ³¨å†Œè¡¨ (Manager Registry)

**èŒè´£**: ç®¡ç†å™¨çš„æ³¨å†Œã€ä¾èµ–è§£æå’Œåˆå§‹åŒ–

```typescript
class ManagerRegistry {
  private managers = new Map<string, any>()
  private factories = new Map<string, ManagerFactory>()
  private dependencies = new Map<string, string[]>()
  private initialized = new Set<string>()

  register<T>(
    name: string,
    factory: ManagerFactory<T>,
    dependencies: string[] = [],
    options: ManagerOptions = {}
  ) {
    this.factories.set(name, factory)
    this.dependencies.set(name, dependencies)

    if (!options.lazy) {
      this.initialize(name)
    }
  }

  private initialize(name: string): any {
    if (this.initialized.has(name)) {
      return this.managers.get(name)
    }

    // é€’å½’åˆå§‹åŒ–ä¾èµ–
    const deps = this.dependencies.get(name) || []
    const resolvedDeps = deps.map(dep => this.initialize(dep))

    // åˆ›å»ºç®¡ç†å™¨å®ä¾‹
    const factory = this.factories.get(name)
    const manager = factory(...resolvedDeps)

    this.managers.set(name, manager)
    this.initialized.add(name)

    return manager
  }
}
```

**ç‰¹æ€§**:
- ä¾èµ–æ³¨å…¥
- æ‡’åŠ è½½æ”¯æŒ
- å¾ªç¯ä¾èµ–æ£€æµ‹
- åˆå§‹åŒ–é¡ºåºæ§åˆ¶

### 3. ç”Ÿå‘½å‘¨æœŸç®¡ç†å™¨ (Lifecycle Manager)

**èŒè´£**: ç®¡ç†åº”ç”¨çš„å®Œæ•´ç”Ÿå‘½å‘¨æœŸ

```typescript
class LifecycleManager {
  private hooks = new Map<string, LifecycleHook[]>()
  private currentPhase?: string
  private history: LifecycleEvent[] = []

  on(phase: string, hook: LifecycleHook, priority = 0): string {
    if (!this.hooks.has(phase)) {
      this.hooks.set(phase, [])
    }

    const hookInfo = { id: generateId(), hook, priority }
    const hooks = this.hooks.get(phase)!

    // æŒ‰ä¼˜å…ˆçº§æ’å…¥
    const insertIndex = hooks.findIndex(h => h.priority < priority)
    if (insertIndex === -1) {
      hooks.push(hookInfo)
    }
    else {
      hooks.splice(insertIndex, 0, hookInfo)
    }

    return hookInfo.id
  }

  async execute(phase: string, context: any): Promise<void> {
    this.currentPhase = phase
    const hooks = this.hooks.get(phase) || []

    const event: LifecycleEvent = {
      phase,
      timestamp: Date.now(),
      context
    }

    try {
      for (const hookInfo of hooks) {
        await hookInfo.hook(context)
      }
      event.success = true
    }
    catch (error) {
      event.error = error
      event.success = false
      throw error
    }
    finally {
      this.history.push(event)
      this.currentPhase = undefined
    }
  }
}
```

**ç”Ÿå‘½å‘¨æœŸé˜¶æ®µ**:
- `beforeInit` - åˆå§‹åŒ–å‰
- `init` - åˆå§‹åŒ–ä¸­
- `afterInit` - åˆå§‹åŒ–å
- `beforeMount` - æŒ‚è½½å‰
- `mount` - æŒ‚è½½ä¸­
- `afterMount` - æŒ‚è½½å
- `beforeUnmount` - å¸è½½å‰
- `unmount` - å¸è½½ä¸­
- `afterUnmount` - å¸è½½å
- `beforeDestroy` - é”€æ¯å‰
- `destroy` - é”€æ¯ä¸­
- `afterDestroy` - é”€æ¯å

## ğŸ“¦ ç®¡ç†å™¨æ¶æ„

### ç®¡ç†å™¨åŸºç±»è®¾è®¡

```typescript
abstract class BaseManager {
  protected logger: Logger
  protected config: ConfigManager
  protected events: EventManager

  constructor(dependencies: ManagerDependencies) {
    this.logger = dependencies.logger
    this.config = dependencies.config
    this.events = dependencies.events
  }

  abstract initialize(): Promise<void> | void
  abstract destroy(): Promise<void> | void

  protected emit(event: string, data?: any) {
    this.events.emit(`${this.constructor.name}:${event}`, data)
  }

  protected log(level: LogLevel, message: string, data?: any) {
    this.logger[level](`[${this.constructor.name}] ${message}`, data)
  }
}
```

### ç®¡ç†å™¨ä¾èµ–å›¾

```mermaid
graph TD
    Config[Config Manager] --> Logger[Logger Manager]
    Logger --> Environment[Environment Manager]
    Logger --> Events[Event Manager]
    Logger --> State[State Manager]
    Events --> Plugins[Plugin Manager]
    State --> Plugins
    Logger --> Middleware[Middleware Manager]
    Middleware --> Plugins

    Config --> Cache[Cache Manager]
    Config --> Performance[Performance Manager]
    Logger --> Performance
    Config --> Security[Security Manager]
    Logger --> Security

    Logger --> Notifications[Notification Manager]
    Logger --> Errors[Error Manager]
    Logger --> Directives[Directive Manager]
```

## ğŸ”Œ æ’ä»¶æ¶æ„

### æ’ä»¶ç³»ç»Ÿè®¾è®¡

```typescript
interface Plugin {
  name: string
  version: string
  description?: string
  dependencies?: string[]

  install: (context: PluginContext) => void | Promise<void>
  uninstall?: (context: PluginContext) => void | Promise<void>
}

interface PluginContext {
  engine: Engine
  config: ConfigManager
  logger: Logger
  events: EventManager
  state: StateManager
  [key: string]: any
}

class PluginManager extends BaseManager {
  private plugins = new Map<string, Plugin>()
  private installed = new Set<string>()

  async register(plugin: Plugin): Promise<void> {
    // æ£€æŸ¥ä¾èµ–
    await this.checkDependencies(plugin)

    // å®‰è£…æ’ä»¶
    const context = this.createPluginContext()
    await plugin.install(context)

    this.plugins.set(plugin.name, plugin)
    this.installed.add(plugin.name)

    this.emit('plugin:registered', { plugin: plugin.name })
  }

  private createPluginContext(): PluginContext {
    return {
      engine: this.engine,
      config: this.config,
      logger: this.logger,
      events: this.events,
      state: this.state
    }
  }
}
```

### æ’ä»¶ç”Ÿå‘½å‘¨æœŸ

```mermaid
sequenceDiagram
    participant App as Application
    participant PM as Plugin Manager
    participant P as Plugin
    participant E as Engine

    App->>PM: register(plugin)
    PM->>PM: checkDependencies()
    PM->>P: install(context)
    P->>E: extend functionality
    PM->>PM: markAsInstalled()
    PM->>App: registration complete

    Note over App,E: Plugin is now active

    App->>PM: unregister(plugin)
    PM->>P: uninstall(context)
    P->>E: cleanup functionality
    PM->>PM: markAsUninstalled()
    PM->>App: unregistration complete
```

## ğŸŒŠ ä¸­é—´ä»¶æ¶æ„

### ä¸­é—´ä»¶ç³»ç»Ÿè®¾è®¡

```typescript
interface Middleware {
  (context: MiddlewareContext, next: NextFunction): Promise<void> | void
}

interface MiddlewareContext {
  request: any
  response: any
  state: Record<string, any>
  [key: string]: any
}

type NextFunction = () => Promise<void>

class MiddlewareManager extends BaseManager {
  private middlewares: Middleware[] = []

  use(middleware: Middleware): void {
    this.middlewares.push(middleware)
  }

  async execute(context: MiddlewareContext): Promise<void> {
    let index = 0

    const next = async (): Promise<void> => {
      if (index >= this.middlewares.length)
        return

      const middleware = this.middlewares[index++]
      await middleware(context, next)
    }

    await next()
  }
}
```

### ä¸­é—´ä»¶æ‰§è¡Œæµç¨‹

```mermaid
graph TD
    Start[å¼€å§‹] --> MW1[ä¸­é—´ä»¶ 1]
    MW1 --> MW2[ä¸­é—´ä»¶ 2]
    MW2 --> MW3[ä¸­é—´ä»¶ 3]
    MW3 --> Core[æ ¸å¿ƒå¤„ç†]
    Core --> MW3_After[ä¸­é—´ä»¶ 3 åå¤„ç†]
    MW3_After --> MW2_After[ä¸­é—´ä»¶ 2 åå¤„ç†]
    MW2_After --> MW1_After[ä¸­é—´ä»¶ 1 åå¤„ç†]
    MW1_After --> End[ç»“æŸ]
```

## ğŸ”„ äº‹ä»¶æ¶æ„

### äº‹ä»¶ç³»ç»Ÿè®¾è®¡

```typescript
class EventManager extends BaseManager {
  private events = new Map<string, EventListener[]>()
  private namespaces = new Map<string, NamespacedEventManager>()
  private maxListeners = 100

  on(event: string, listener: EventListener, options?: EventOptions): string {
    if (!this.events.has(event)) {
      this.events.set(event, [])
    }

    const listeners = this.events.get(event)!

    // æ£€æŸ¥ç›‘å¬å™¨æ•°é‡é™åˆ¶
    if (listeners.length >= this.maxListeners) {
      this.logger.warn(
        `Maximum listeners (${this.maxListeners}) exceeded for event "${event}"`
      )
    }

    const listenerInfo: EventListenerInfo = {
      id: generateId(),
      listener,
      once: options?.once || false,
      priority: options?.priority || 0
    }

    // æŒ‰ä¼˜å…ˆçº§æ’å…¥
    const insertIndex = listeners.findIndex(l => l.priority < listenerInfo.priority)
    if (insertIndex === -1) {
      listeners.push(listenerInfo)
    }
    else {
      listeners.splice(insertIndex, 0, listenerInfo)
    }

    return listenerInfo.id
  }

  emit(event: string, data?: any): boolean {
    const listeners = this.events.get(event)
    if (!listeners || listeners.length === 0) {
      return false
    }

    const eventData: EventData = {
      type: event,
      data,
      timestamp: Date.now(),
      source: this
    }

    // æ‰§è¡Œç›‘å¬å™¨
    for (const listenerInfo of [...listeners]) {
      try {
        listenerInfo.listener(eventData)

        // ç§»é™¤ä¸€æ¬¡æ€§ç›‘å¬å™¨
        if (listenerInfo.once) {
          this.off(listenerInfo.id)
        }
      }
      catch (error) {
        this.logger.error(`Error in event listener for "${event}":`, error)
      }
    }

    return true
  }

  namespace(name: string): NamespacedEventManager {
    if (!this.namespaces.has(name)) {
      this.namespaces.set(name, new NamespacedEventManager(this, name))
    }
    return this.namespaces.get(name)!
  }
}
```

## ğŸ—„ï¸ çŠ¶æ€æ¶æ„

### çŠ¶æ€ç®¡ç†è®¾è®¡

```typescript
class StateManager extends BaseManager {
  private state: Record<string, any> = {}
  private watchers = new Map<string, StateWatcher[]>()
  private history: StateChange[] = []
  private maxHistorySize = 100

  set(path: string, value: any): void {
    const oldValue = this.get(path)

    // è®¾ç½®å€¼
    this.setNestedValue(this.state, path, value)

    // è®°å½•å˜åŒ–
    const change: StateChange = {
      path,
      oldValue,
      newValue: value,
      timestamp: Date.now()
    }

    this.addToHistory(change)

    // è§¦å‘ç›‘å¬å™¨
    this.notifyWatchers(path, value, oldValue)

    // è§¦å‘äº‹ä»¶
    this.emit('state:changed', change)
  }

  get<T = any>(path: string, defaultValue?: T): T {
    return this.getNestedValue(this.state, path, defaultValue)
  }

  watch(path: string, watcher: StateWatcher): () => void {
    if (!this.watchers.has(path)) {
      this.watchers.set(path, [])
    }

    const watcherInfo: StateWatcherInfo = {
      id: generateId(),
      watcher,
      path
    }

    this.watchers.get(path)!.push(watcherInfo)

    // è¿”å›å–æ¶ˆç›‘å¬çš„å‡½æ•°
    return () => this.unwatch(watcherInfo.id)
  }

  private notifyWatchers(path: string, newValue: any, oldValue: any): void {
    // é€šçŸ¥ç²¾ç¡®è·¯å¾„çš„ç›‘å¬å™¨
    const exactWatchers = this.watchers.get(path) || []
    exactWatchers.forEach((watcher) => {
      try {
        watcher.watcher(newValue, oldValue, path)
      }
      catch (error) {
        this.logger.error(`Error in state watcher for "${path}":`, error)
      }
    })

    // é€šçŸ¥çˆ¶è·¯å¾„çš„ç›‘å¬å™¨
    const pathParts = path.split('.')
    for (let i = pathParts.length - 1; i > 0; i--) {
      const parentPath = pathParts.slice(0, i).join('.')
      const parentWatchers = this.watchers.get(parentPath) || []

      parentWatchers.forEach((watcher) => {
        try {
          const parentNewValue = this.get(parentPath)
          const parentOldValue = this.reconstructOldValue(parentPath, path, oldValue)
          watcher.watcher(parentNewValue, parentOldValue, parentPath)
        }
        catch (error) {
          this.logger.error(`Error in parent state watcher for "${parentPath}":`, error)
        }
      })
    }
  }
}
```

## ğŸ”§ é…ç½®æ¶æ„

### é…ç½®ç³»ç»Ÿè®¾è®¡

```typescript
class ConfigManager extends BaseManager {
  private config: Record<string, any> = {}
  private schema?: ConfigSchema
  private watchers = new Map<string, ConfigWatcher[]>()
  private snapshots: ConfigSnapshot[] = []
  private maxSnapshots = 10

  constructor(initialConfig?: any, schema?: ConfigSchema) {
    super()
    this.schema = schema

    if (initialConfig) {
      this.merge(initialConfig)
    }

    this.createSnapshot('initial')
  }

  set(path: string, value: any): void {
    // éªŒè¯é…ç½®
    if (this.schema) {
      this.validateValue(path, value)
    }

    const oldValue = this.get(path)

    // è®¾ç½®å€¼
    this.setNestedValue(this.config, path, value)

    // åˆ›å»ºå¿«ç…§
    this.createSnapshot(`set:${path}`)

    // é€šçŸ¥ç›‘å¬å™¨
    this.notifyWatchers(path, value, oldValue)

    // è§¦å‘äº‹ä»¶
    this.emit('config:changed', { path, value, oldValue })
  }

  private validateValue(path: string, value: any): void {
    const schemaNode = this.getSchemaNode(path)
    if (!schemaNode)
      return

    if (schemaNode.type && typeof value !== schemaNode.type) {
      throw new ConfigValidationError(
        `Invalid type for "${path}": expected ${schemaNode.type}, got ${typeof value}`
      )
    }

    if (schemaNode.validator && !schemaNode.validator(value)) {
      throw new ConfigValidationError(
        `Validation failed for "${path}": ${value}`
      )
    }
  }

  private createSnapshot(reason: string): void {
    const snapshot: ConfigSnapshot = {
      config: JSON.parse(JSON.stringify(this.config)),
      timestamp: Date.now(),
      reason,
      version: generateVersion()
    }

    this.snapshots.push(snapshot)

    // é™åˆ¶å¿«ç…§æ•°é‡
    if (this.snapshots.length > this.maxSnapshots) {
      this.snapshots.shift()
    }
  }
}
```

LDesign Engine çš„æ¶æ„è®¾è®¡ä½“ç°äº†ç°ä»£è½¯ä»¶å·¥ç¨‹çš„æœ€ä½³å®è·µï¼Œé€šè¿‡åˆ†å±‚è®¾è®¡ã€ä¾èµ–æ³¨å…¥ã€äº‹ä»¶é©±åŠ¨ç­‰æ¨¡å¼ï¼Œæ„å»ºäº†ä¸€ä¸ªé«˜åº¦æ¨¡å—åŒ–ã€å¯æ‰©å±•ã€æ˜“ç»´æŠ¤çš„å‰ç«¯åº”ç”¨å¼•æ“ã€‚è¿™ç§æ¶æ„ä¸ä»…ä¿è¯äº†ç³»ç»Ÿçš„ç¨³å®šæ€§å’Œæ€§èƒ½ï¼Œä¹Ÿä¸ºæœªæ¥çš„åŠŸèƒ½æ‰©å±•å’ŒæŠ€æœ¯æ¼”è¿›æä¾›äº†åšå®çš„åŸºç¡€ã€‚
