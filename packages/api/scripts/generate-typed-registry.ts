#!/usr/bin/env tsx
/**
 * 生成 Typed Registry 的简单脚本
 * 用法：pnpm run generate:registry [configPath]
 */
import { readFileSync, writeFileSync, mkdirSync } from 'node:fs'
import { dirname, resolve } from 'node:path'

interface Config {
  outFile?: string
  baseImport?: string
  resolve?: 'simple' | 'raw'
  registry: Record<string, string>
}

const argvPath = process.argv[2]
const configPath = resolve(process.cwd(), argvPath || 'typed-registry.config.json')
const raw = readFileSync(configPath, 'utf-8')
const cfg: Config = JSON.parse(raw)

const outFile = cfg.outFile || 'src/types/registry.generated.ts'
const baseImport = cfg.baseImport || "../types"
const mode = cfg.resolve || 'simple'

function toTypeExp(t: string): string {
  if (mode === 'raw') return t
  // simple 模式：将 'UserInfo' => import('../types').UserInfo
  // 'MenuItem[]' => Array<import('../types').MenuItem>
  const arrayMatch = t.trim().match(/^(\w+)\[\]$/)
  if (arrayMatch) {
    const base = arrayMatch[1]
    return `Array<import('${baseImport}').${base}>`
  }
  // 基础标识符
  if (/^\w+$/.test(t.trim())) {
    return `import('${baseImport}').${t.trim()}`
  }
  // 其他复杂类型，直接原样输出（用户自行处理）
  return t
}

let lines: string[] = []
lines.push('/**')
lines.push(' * Auto-generated by scripts/generate-typed-registry.ts. Do not edit manually.')
lines.push(' */')
lines.push('')
lines.push('export type ApiMethodRegistry = {')
for (const [k, v] of Object.entries(cfg.registry || {})) {
  lines.push(`  '${k}': ${toTypeExp(v)},`)
}
lines.push('}')
lines.push('')
lines.push("export type ProjectTypedApi = import('./typed').TypedApiEngine<ApiMethodRegistry>")
lines.push('')

const outPath = resolve(process.cwd(), outFile)
mkdirSync(dirname(outPath), { recursive: true })
writeFileSync(outPath, lines.join('\n'))

console.info(`[typed-registry] Generated: ${outPath}`)

