# LDesign Router - æ‰©å±•æ€§è®¾è®¡

## ğŸ”§ æ’ä»¶ç³»ç»Ÿæ¶æ„

LDesign Router é‡‡ç”¨æ’ä»¶åŒ–æ¶æ„ï¼Œæä¾›å¼ºå¤§çš„æ‰©å±•èƒ½åŠ›ï¼Œæ”¯æŒåŠŸèƒ½çš„æ¨¡å—åŒ–å¼€å‘å’ŒæŒ‰éœ€åŠ è½½ã€‚

### 1. æ’ä»¶æ¥å£è®¾è®¡

```typescript
interface Plugin {
  /** æ’ä»¶åç§° */
  name: string
  /** æ’ä»¶ç‰ˆæœ¬ */
  version: string
  /** æ’ä»¶ä¾èµ– */
  dependencies?: string[]
  /** å®‰è£…æ’ä»¶ */
  install(router: Router, options?: any): void
  /** å¸è½½æ’ä»¶ */
  uninstall?(router: Router): void
  /** æ’ä»¶é…ç½® */
  configure?(options: any): void
}
```

### 2. æ’ä»¶ç®¡ç†å™¨

```typescript
class PluginManager {
  private plugins: Map<string, Plugin> = new Map()
  private installedPlugins: Set<string> = new Set()
  private router: Router
  
  constructor(router: Router) {
    this.router = router
  }
  
  register(plugin: Plugin): void {
    if (this.plugins.has(plugin.name)) {
      throw new Error(`Plugin ${plugin.name} already registered`)
    }
    
    // æ£€æŸ¥ä¾èµ–
    this.checkDependencies(plugin)
    
    this.plugins.set(plugin.name, plugin)
  }
  
  install(pluginName: string, options?: any): void {
    const plugin = this.plugins.get(pluginName)
    if (!plugin) {
      throw new Error(`Plugin ${pluginName} not found`)
    }
    
    if (this.installedPlugins.has(pluginName)) {
      console.warn(`Plugin ${pluginName} already installed`)
      return
    }
    
    // å®‰è£…ä¾èµ–
    this.installDependencies(plugin)
    
    // å®‰è£…æ’ä»¶
    plugin.install(this.router, options)
    this.installedPlugins.add(pluginName)
    
    console.log(`Plugin ${pluginName} installed successfully`)
  }
  
  uninstall(pluginName: string): void {
    const plugin = this.plugins.get(pluginName)
    if (!plugin || !this.installedPlugins.has(pluginName)) {
      return
    }
    
    // æ£€æŸ¥æ˜¯å¦æœ‰å…¶ä»–æ’ä»¶ä¾èµ–æ­¤æ’ä»¶
    this.checkReverseDependencies(pluginName)
    
    // å¸è½½æ’ä»¶
    if (plugin.uninstall) {
      plugin.uninstall(this.router)
    }
    
    this.installedPlugins.delete(pluginName)
    console.log(`Plugin ${pluginName} uninstalled successfully`)
  }
  
  private checkDependencies(plugin: Plugin): void {
    if (!plugin.dependencies) return
    
    for (const dep of plugin.dependencies) {
      if (!this.plugins.has(dep)) {
        throw new Error(`Dependency ${dep} not found for plugin ${plugin.name}`)
      }
    }
  }
  
  private installDependencies(plugin: Plugin): void {
    if (!plugin.dependencies) return
    
    for (const dep of plugin.dependencies) {
      if (!this.installedPlugins.has(dep)) {
        this.install(dep)
      }
    }
  }
}
```

## ğŸ¨ æ ¸å¿ƒæ’ä»¶å®ç°

### 1. åŠ¨ç”»æ’ä»¶

```typescript
interface AnimationPluginOptions {
  defaultAnimation?: AnimationType
  duration?: number
  easing?: string
  customAnimations?: Record<string, AnimationConfig>
}

class AnimationPlugin implements Plugin {
  name = 'animation'
  version = '1.0.0'
  
  private manager: AnimationManager
  
  install(router: Router, options: AnimationPluginOptions = {}): void {
    this.manager = new AnimationManager(options)
    
    // æ³¨å†Œå…¨å±€å±æ€§
    router.app.config.globalProperties.$animations = this.manager
    
    // æä¾›æ³¨å…¥
    router.app.provide('animations', this.manager)
    
    // ç›‘å¬è·¯ç”±å˜åŒ–
    router.afterEach((to, from) => {
      this.manager.handleRouteChange(to, from)
    })
  }
  
  uninstall(router: Router): void {
    this.manager.destroy()
  }
}

export function createAnimationPlugin(options?: AnimationPluginOptions): Plugin {
  return new AnimationPlugin()
}
```

### 2. ç¼“å­˜æ’ä»¶

```typescript
interface CachePluginOptions {
  strategy?: 'lru' | 'fifo' | 'ttl'
  maxSize?: number
  ttl?: number
  keyGenerator?: (route: RouteLocationNormalized) => string
  shouldCache?: (route: RouteLocationNormalized) => boolean
}

class CachePlugin implements Plugin {
  name = 'cache'
  version = '1.0.0'
  
  private manager: CacheManager
  
  install(router: Router, options: CachePluginOptions = {}): void {
    this.manager = new CacheManager(options)
    
    // æ‰©å±• RouterView ç»„ä»¶
    this.extendRouterView(router)
    
    // ç›‘å¬è·¯ç”±å˜åŒ–
    router.beforeEach((to, from, next) => {
      this.manager.handleBeforeRouteChange(to, from)
      next()
    })
    
    router.afterEach((to, from) => {
      this.manager.handleAfterRouteChange(to, from)
    })
  }
  
  private extendRouterView(router: Router): void {
    const originalRouterView = router.components.RouterView
    
    router.components.RouterView = {
      ...originalRouterView,
      setup(props, ctx) {
        const cache = inject('cache') as CacheManager
        
        // æ‰©å±•åŸæœ‰é€»è¾‘
        const result = originalRouterView.setup?.(props, ctx) || {}
        
        return {
          ...result,
          cache,
          getCachedComponent: (key: string) => cache.get(key),
          setCachedComponent: (key: string, component: any) => cache.set(key, component)
        }
      }
    }
  }
}
```

### 3. æ€§èƒ½ç›‘æ§æ’ä»¶

```typescript
interface PerformancePluginOptions {
  warningThreshold?: number
  errorThreshold?: number
  trackMemoryUsage?: boolean
  trackComponentLoadTime?: boolean
  onWarning?: (metrics: PerformanceMetrics) => void
  onError?: (metrics: PerformanceMetrics) => void
}

class PerformancePlugin implements Plugin {
  name = 'performance'
  version = '1.0.0'
  
  private monitor: PerformanceMonitor
  
  install(router: Router, options: PerformancePluginOptions = {}): void {
    this.monitor = new PerformanceMonitor(options)
    
    // ç›‘å¬å¯¼èˆªå¼€å§‹
    router.beforeEach((to, from, next) => {
      this.monitor.startNavigation(to, from)
      next()
    })
    
    // ç›‘å¬å¯¼èˆªå®Œæˆ
    router.afterEach((to, from) => {
      this.monitor.endNavigation(to, from)
    })
    
    // ç›‘å¬å¯¼èˆªé”™è¯¯
    router.onError((error, to, from) => {
      this.monitor.recordError(error, to, from)
    })
    
    // æ‰©å±•è·¯ç”±å™¨å®ä¾‹
    router.getPerformanceMetrics = () => this.monitor.getMetrics()
    router.resetPerformanceMetrics = () => this.monitor.reset()
  }
}
```

## ğŸ”Œ è‡ªå®šä¹‰æ’ä»¶å¼€å‘

### 1. æ’ä»¶å¼€å‘æ¨¡æ¿

```typescript
interface MyPluginOptions {
  // æ’ä»¶é…ç½®é€‰é¡¹
}

class MyPlugin implements Plugin {
  name = 'my-plugin'
  version = '1.0.0'
  dependencies = ['core'] // å¯é€‰ä¾èµ–
  
  private options: MyPluginOptions
  
  install(router: Router, options: MyPluginOptions = {}): void {
    this.options = { ...this.getDefaultOptions(), ...options }
    
    // 1. æ‰©å±•è·¯ç”±å™¨å®ä¾‹
    this.extendRouter(router)
    
    // 2. æ³¨å†Œå…¨å±€ç»„ä»¶
    this.registerComponents(router.app)
    
    // 3. æ·»åŠ å…¨å±€å±æ€§
    this.addGlobalProperties(router.app)
    
    // 4. æä¾›ä¾èµ–æ³¨å…¥
    this.provideInjects(router.app)
    
    // 5. ç›‘å¬è·¯ç”±äº‹ä»¶
    this.setupRouteListeners(router)
    
    // 6. åˆå§‹åŒ–æ’ä»¶é€»è¾‘
    this.initialize()
  }
  
  uninstall(router: Router): void {
    // æ¸…ç†èµ„æº
    this.cleanup()
  }
  
  configure(options: MyPluginOptions): void {
    this.options = { ...this.options, ...options }
  }
  
  private getDefaultOptions(): MyPluginOptions {
    return {
      // é»˜è®¤é…ç½®
    }
  }
  
  private extendRouter(router: Router): void {
    // æ‰©å±•è·¯ç”±å™¨æ–¹æ³•
    router.myPluginMethod = () => {
      // æ’ä»¶æ–¹æ³•å®ç°
    }
  }
  
  private registerComponents(app: App): void {
    // æ³¨å†Œå…¨å±€ç»„ä»¶
    app.component('MyPluginComponent', MyPluginComponent)
  }
  
  private addGlobalProperties(app: App): void {
    // æ·»åŠ å…¨å±€å±æ€§
    app.config.globalProperties.$myPlugin = this
  }
  
  private provideInjects(app: App): void {
    // æä¾›ä¾èµ–æ³¨å…¥
    app.provide('myPlugin', this)
  }
  
  private setupRouteListeners(router: Router): void {
    // ç›‘å¬è·¯ç”±äº‹ä»¶
    router.beforeEach((to, from, next) => {
      // è·¯ç”±å‰ç½®å¤„ç†
      next()
    })
    
    router.afterEach((to, from) => {
      // è·¯ç”±åç½®å¤„ç†
    })
  }
  
  private initialize(): void {
    // æ’ä»¶åˆå§‹åŒ–é€»è¾‘
  }
  
  private cleanup(): void {
    // æ¸…ç†èµ„æº
  }
}

// æ’ä»¶å·¥å‚å‡½æ•°
export function createMyPlugin(options?: MyPluginOptions): Plugin {
  return new MyPlugin()
}
```

### 2. æ’ä»¶æœ€ä½³å®è·µ

#### å‘½åè§„èŒƒ
- æ’ä»¶åç§°ä½¿ç”¨ kebab-case
- å·¥å‚å‡½æ•°ä½¿ç”¨ `create` å‰ç¼€
- ç±»åä½¿ç”¨ PascalCase + Plugin åç¼€

#### é”™è¯¯å¤„ç†
```typescript
class SafePlugin implements Plugin {
  install(router: Router, options?: any): void {
    try {
      // æ’ä»¶å®‰è£…é€»è¾‘
      this.doInstall(router, options)
    } catch (error) {
      console.error(`Failed to install plugin ${this.name}:`, error)
      // å¯é€‰ï¼šå›æ»šæ“ä½œ
      this.rollback(router)
      throw error
    }
  }
  
  private doInstall(router: Router, options?: any): void {
    // å®é™…å®‰è£…é€»è¾‘
  }
  
  private rollback(router: Router): void {
    // å›æ»šæ“ä½œ
  }
}
```

#### é…ç½®éªŒè¯
```typescript
class ValidatedPlugin implements Plugin {
  install(router: Router, options?: any): void {
    // éªŒè¯é…ç½®
    const validatedOptions = this.validateOptions(options)
    
    // ä½¿ç”¨éªŒè¯åçš„é…ç½®
    this.doInstall(router, validatedOptions)
  }
  
  private validateOptions(options: any): any {
    const schema = {
      // é…ç½®æ¨¡å¼å®šä¹‰
    }
    
    // ä½¿ç”¨ joiã€yup æˆ–å…¶ä»–éªŒè¯åº“
    return validate(options, schema)
  }
}
```

## ğŸŒ ç”Ÿæ€ç³»ç»Ÿæ‰©å±•

### 1. çŠ¶æ€ç®¡ç†é›†æˆ

```typescript
// Pinia é›†æˆæ’ä»¶
export function createPiniaIntegration(): Plugin {
  return {
    name: 'pinia-integration',
    version: '1.0.0',
    install(router: Router) {
      // é›†æˆ Pinia çŠ¶æ€ç®¡ç†
      router.beforeEach((to, from, next) => {
        // è·¯ç”±å˜åŒ–æ—¶åŒæ­¥çŠ¶æ€
        const store = useRouterStore()
        store.setCurrentRoute(to)
        next()
      })
    }
  }
}

// Vuex é›†æˆæ’ä»¶
export function createVuexIntegration(): Plugin {
  return {
    name: 'vuex-integration',
    version: '1.0.0',
    install(router: Router) {
      // é›†æˆ Vuex çŠ¶æ€ç®¡ç†
    }
  }
}
```

### 2. UI æ¡†æ¶é›†æˆ

```typescript
// Element Plus é›†æˆ
export function createElementPlusIntegration(): Plugin {
  return {
    name: 'element-plus-integration',
    version: '1.0.0',
    install(router: Router) {
      // é›†æˆ Element Plus ç»„ä»¶
      // è‡ªåŠ¨é¢åŒ…å±‘ã€èœå•é«˜äº®ç­‰
    }
  }
}

// Ant Design Vue é›†æˆ
export function createAntdIntegration(): Plugin {
  return {
    name: 'antd-integration',
    version: '1.0.0',
    install(router: Router) {
      // é›†æˆ Ant Design Vue ç»„ä»¶
    }
  }
}
```

### 3. å¼€å‘å·¥å…·é›†æˆ

```typescript
// Vue DevTools é›†æˆ
export function createDevToolsIntegration(): Plugin {
  return {
    name: 'devtools-integration',
    version: '1.0.0',
    install(router: Router) {
      if (process.env.NODE_ENV === 'development') {
        // é›†æˆ Vue DevTools
        this.setupDevTools(router)
      }
    },
    
    setupDevTools(router: Router) {
      // DevTools é›†æˆé€»è¾‘
    }
  }
}
```

## ğŸ“¦ æ’ä»¶åˆ†å‘å’Œç®¡ç†

### 1. æ’ä»¶æ³¨å†Œä¸­å¿ƒ

```typescript
class PluginRegistry {
  private static instance: PluginRegistry
  private plugins: Map<string, PluginInfo> = new Map()
  
  static getInstance(): PluginRegistry {
    if (!this.instance) {
      this.instance = new PluginRegistry()
    }
    return this.instance
  }
  
  register(info: PluginInfo): void {
    this.plugins.set(info.name, info)
  }
  
  search(query: string): PluginInfo[] {
    return Array.from(this.plugins.values())
      .filter(plugin => 
        plugin.name.includes(query) || 
        plugin.description.includes(query) ||
        plugin.tags.some(tag => tag.includes(query))
      )
  }
  
  getPlugin(name: string): PluginInfo | undefined {
    return this.plugins.get(name)
  }
  
  listPlugins(): PluginInfo[] {
    return Array.from(this.plugins.values())
  }
}

interface PluginInfo {
  name: string
  version: string
  description: string
  author: string
  homepage: string
  repository: string
  tags: string[]
  dependencies: string[]
  peerDependencies: string[]
  license: string
  downloadUrl: string
}
```

### 2. åŠ¨æ€æ’ä»¶åŠ è½½

```typescript
class DynamicPluginLoader {
  async loadPlugin(name: string, version?: string): Promise<Plugin> {
    try {
      // 1. ä»æ³¨å†Œä¸­å¿ƒè·å–æ’ä»¶ä¿¡æ¯
      const registry = PluginRegistry.getInstance()
      const pluginInfo = registry.getPlugin(name)
      
      if (!pluginInfo) {
        throw new Error(`Plugin ${name} not found`)
      }
      
      // 2. åŠ¨æ€å¯¼å…¥æ’ä»¶
      const pluginModule = await import(pluginInfo.downloadUrl)
      
      // 3. éªŒè¯æ’ä»¶
      this.validatePlugin(pluginModule.default)
      
      return pluginModule.default
    } catch (error) {
      console.error(`Failed to load plugin ${name}:`, error)
      throw error
    }
  }
  
  private validatePlugin(plugin: any): void {
    if (!plugin.name || !plugin.version || !plugin.install) {
      throw new Error('Invalid plugin format')
    }
  }
}
```

---

> ğŸ”§ **æ‰©å±•ç†å¿µ**: å¼€æ”¾ã€çµæ´»ã€å¼ºå¤§ - è®©æ¯ä¸ªå¼€å‘è€…éƒ½èƒ½è½»æ¾æ‰©å±•è·¯ç”±å™¨åŠŸèƒ½ï¼
