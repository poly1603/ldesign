# LDesign Router - 扩展性设计

## 🔧 插件系统架构

LDesign Router 采用插件化架构，提供强大的扩展能力，支持功能的模块化开发和按需加载。

### 1. 插件接口设计

```typescript
interface Plugin {
  /** 插件名称 */
  name: string
  /** 插件版本 */
  version: string
  /** 插件依赖 */
  dependencies?: string[]
  /** 安装插件 */
  install(router: Router, options?: any): void
  /** 卸载插件 */
  uninstall?(router: Router): void
  /** 插件配置 */
  configure?(options: any): void
}
```

### 2. 插件管理器

```typescript
class PluginManager {
  private plugins: Map<string, Plugin> = new Map()
  private installedPlugins: Set<string> = new Set()
  private router: Router
  
  constructor(router: Router) {
    this.router = router
  }
  
  register(plugin: Plugin): void {
    if (this.plugins.has(plugin.name)) {
      throw new Error(`Plugin ${plugin.name} already registered`)
    }
    
    // 检查依赖
    this.checkDependencies(plugin)
    
    this.plugins.set(plugin.name, plugin)
  }
  
  install(pluginName: string, options?: any): void {
    const plugin = this.plugins.get(pluginName)
    if (!plugin) {
      throw new Error(`Plugin ${pluginName} not found`)
    }
    
    if (this.installedPlugins.has(pluginName)) {
      console.warn(`Plugin ${pluginName} already installed`)
      return
    }
    
    // 安装依赖
    this.installDependencies(plugin)
    
    // 安装插件
    plugin.install(this.router, options)
    this.installedPlugins.add(pluginName)
    
    console.log(`Plugin ${pluginName} installed successfully`)
  }
  
  uninstall(pluginName: string): void {
    const plugin = this.plugins.get(pluginName)
    if (!plugin || !this.installedPlugins.has(pluginName)) {
      return
    }
    
    // 检查是否有其他插件依赖此插件
    this.checkReverseDependencies(pluginName)
    
    // 卸载插件
    if (plugin.uninstall) {
      plugin.uninstall(this.router)
    }
    
    this.installedPlugins.delete(pluginName)
    console.log(`Plugin ${pluginName} uninstalled successfully`)
  }
  
  private checkDependencies(plugin: Plugin): void {
    if (!plugin.dependencies) return
    
    for (const dep of plugin.dependencies) {
      if (!this.plugins.has(dep)) {
        throw new Error(`Dependency ${dep} not found for plugin ${plugin.name}`)
      }
    }
  }
  
  private installDependencies(plugin: Plugin): void {
    if (!plugin.dependencies) return
    
    for (const dep of plugin.dependencies) {
      if (!this.installedPlugins.has(dep)) {
        this.install(dep)
      }
    }
  }
}
```

## 🎨 核心插件实现

### 1. 动画插件

```typescript
interface AnimationPluginOptions {
  defaultAnimation?: AnimationType
  duration?: number
  easing?: string
  customAnimations?: Record<string, AnimationConfig>
}

class AnimationPlugin implements Plugin {
  name = 'animation'
  version = '1.0.0'
  
  private manager: AnimationManager
  
  install(router: Router, options: AnimationPluginOptions = {}): void {
    this.manager = new AnimationManager(options)
    
    // 注册全局属性
    router.app.config.globalProperties.$animations = this.manager
    
    // 提供注入
    router.app.provide('animations', this.manager)
    
    // 监听路由变化
    router.afterEach((to, from) => {
      this.manager.handleRouteChange(to, from)
    })
  }
  
  uninstall(router: Router): void {
    this.manager.destroy()
  }
}

export function createAnimationPlugin(options?: AnimationPluginOptions): Plugin {
  return new AnimationPlugin()
}
```

### 2. 缓存插件

```typescript
interface CachePluginOptions {
  strategy?: 'lru' | 'fifo' | 'ttl'
  maxSize?: number
  ttl?: number
  keyGenerator?: (route: RouteLocationNormalized) => string
  shouldCache?: (route: RouteLocationNormalized) => boolean
}

class CachePlugin implements Plugin {
  name = 'cache'
  version = '1.0.0'
  
  private manager: CacheManager
  
  install(router: Router, options: CachePluginOptions = {}): void {
    this.manager = new CacheManager(options)
    
    // 扩展 RouterView 组件
    this.extendRouterView(router)
    
    // 监听路由变化
    router.beforeEach((to, from, next) => {
      this.manager.handleBeforeRouteChange(to, from)
      next()
    })
    
    router.afterEach((to, from) => {
      this.manager.handleAfterRouteChange(to, from)
    })
  }
  
  private extendRouterView(router: Router): void {
    const originalRouterView = router.components.RouterView
    
    router.components.RouterView = {
      ...originalRouterView,
      setup(props, ctx) {
        const cache = inject('cache') as CacheManager
        
        // 扩展原有逻辑
        const result = originalRouterView.setup?.(props, ctx) || {}
        
        return {
          ...result,
          cache,
          getCachedComponent: (key: string) => cache.get(key),
          setCachedComponent: (key: string, component: any) => cache.set(key, component)
        }
      }
    }
  }
}
```

### 3. 性能监控插件

```typescript
interface PerformancePluginOptions {
  warningThreshold?: number
  errorThreshold?: number
  trackMemoryUsage?: boolean
  trackComponentLoadTime?: boolean
  onWarning?: (metrics: PerformanceMetrics) => void
  onError?: (metrics: PerformanceMetrics) => void
}

class PerformancePlugin implements Plugin {
  name = 'performance'
  version = '1.0.0'
  
  private monitor: PerformanceMonitor
  
  install(router: Router, options: PerformancePluginOptions = {}): void {
    this.monitor = new PerformanceMonitor(options)
    
    // 监听导航开始
    router.beforeEach((to, from, next) => {
      this.monitor.startNavigation(to, from)
      next()
    })
    
    // 监听导航完成
    router.afterEach((to, from) => {
      this.monitor.endNavigation(to, from)
    })
    
    // 监听导航错误
    router.onError((error, to, from) => {
      this.monitor.recordError(error, to, from)
    })
    
    // 扩展路由器实例
    router.getPerformanceMetrics = () => this.monitor.getMetrics()
    router.resetPerformanceMetrics = () => this.monitor.reset()
  }
}
```

## 🔌 自定义插件开发

### 1. 插件开发模板

```typescript
interface MyPluginOptions {
  // 插件配置选项
}

class MyPlugin implements Plugin {
  name = 'my-plugin'
  version = '1.0.0'
  dependencies = ['core'] // 可选依赖
  
  private options: MyPluginOptions
  
  install(router: Router, options: MyPluginOptions = {}): void {
    this.options = { ...this.getDefaultOptions(), ...options }
    
    // 1. 扩展路由器实例
    this.extendRouter(router)
    
    // 2. 注册全局组件
    this.registerComponents(router.app)
    
    // 3. 添加全局属性
    this.addGlobalProperties(router.app)
    
    // 4. 提供依赖注入
    this.provideInjects(router.app)
    
    // 5. 监听路由事件
    this.setupRouteListeners(router)
    
    // 6. 初始化插件逻辑
    this.initialize()
  }
  
  uninstall(router: Router): void {
    // 清理资源
    this.cleanup()
  }
  
  configure(options: MyPluginOptions): void {
    this.options = { ...this.options, ...options }
  }
  
  private getDefaultOptions(): MyPluginOptions {
    return {
      // 默认配置
    }
  }
  
  private extendRouter(router: Router): void {
    // 扩展路由器方法
    router.myPluginMethod = () => {
      // 插件方法实现
    }
  }
  
  private registerComponents(app: App): void {
    // 注册全局组件
    app.component('MyPluginComponent', MyPluginComponent)
  }
  
  private addGlobalProperties(app: App): void {
    // 添加全局属性
    app.config.globalProperties.$myPlugin = this
  }
  
  private provideInjects(app: App): void {
    // 提供依赖注入
    app.provide('myPlugin', this)
  }
  
  private setupRouteListeners(router: Router): void {
    // 监听路由事件
    router.beforeEach((to, from, next) => {
      // 路由前置处理
      next()
    })
    
    router.afterEach((to, from) => {
      // 路由后置处理
    })
  }
  
  private initialize(): void {
    // 插件初始化逻辑
  }
  
  private cleanup(): void {
    // 清理资源
  }
}

// 插件工厂函数
export function createMyPlugin(options?: MyPluginOptions): Plugin {
  return new MyPlugin()
}
```

### 2. 插件最佳实践

#### 命名规范
- 插件名称使用 kebab-case
- 工厂函数使用 `create` 前缀
- 类名使用 PascalCase + Plugin 后缀

#### 错误处理
```typescript
class SafePlugin implements Plugin {
  install(router: Router, options?: any): void {
    try {
      // 插件安装逻辑
      this.doInstall(router, options)
    } catch (error) {
      console.error(`Failed to install plugin ${this.name}:`, error)
      // 可选：回滚操作
      this.rollback(router)
      throw error
    }
  }
  
  private doInstall(router: Router, options?: any): void {
    // 实际安装逻辑
  }
  
  private rollback(router: Router): void {
    // 回滚操作
  }
}
```

#### 配置验证
```typescript
class ValidatedPlugin implements Plugin {
  install(router: Router, options?: any): void {
    // 验证配置
    const validatedOptions = this.validateOptions(options)
    
    // 使用验证后的配置
    this.doInstall(router, validatedOptions)
  }
  
  private validateOptions(options: any): any {
    const schema = {
      // 配置模式定义
    }
    
    // 使用 joi、yup 或其他验证库
    return validate(options, schema)
  }
}
```

## 🌐 生态系统扩展

### 1. 状态管理集成

```typescript
// Pinia 集成插件
export function createPiniaIntegration(): Plugin {
  return {
    name: 'pinia-integration',
    version: '1.0.0',
    install(router: Router) {
      // 集成 Pinia 状态管理
      router.beforeEach((to, from, next) => {
        // 路由变化时同步状态
        const store = useRouterStore()
        store.setCurrentRoute(to)
        next()
      })
    }
  }
}

// Vuex 集成插件
export function createVuexIntegration(): Plugin {
  return {
    name: 'vuex-integration',
    version: '1.0.0',
    install(router: Router) {
      // 集成 Vuex 状态管理
    }
  }
}
```

### 2. UI 框架集成

```typescript
// Element Plus 集成
export function createElementPlusIntegration(): Plugin {
  return {
    name: 'element-plus-integration',
    version: '1.0.0',
    install(router: Router) {
      // 集成 Element Plus 组件
      // 自动面包屑、菜单高亮等
    }
  }
}

// Ant Design Vue 集成
export function createAntdIntegration(): Plugin {
  return {
    name: 'antd-integration',
    version: '1.0.0',
    install(router: Router) {
      // 集成 Ant Design Vue 组件
    }
  }
}
```

### 3. 开发工具集成

```typescript
// Vue DevTools 集成
export function createDevToolsIntegration(): Plugin {
  return {
    name: 'devtools-integration',
    version: '1.0.0',
    install(router: Router) {
      if (process.env.NODE_ENV === 'development') {
        // 集成 Vue DevTools
        this.setupDevTools(router)
      }
    },
    
    setupDevTools(router: Router) {
      // DevTools 集成逻辑
    }
  }
}
```

## 📦 插件分发和管理

### 1. 插件注册中心

```typescript
class PluginRegistry {
  private static instance: PluginRegistry
  private plugins: Map<string, PluginInfo> = new Map()
  
  static getInstance(): PluginRegistry {
    if (!this.instance) {
      this.instance = new PluginRegistry()
    }
    return this.instance
  }
  
  register(info: PluginInfo): void {
    this.plugins.set(info.name, info)
  }
  
  search(query: string): PluginInfo[] {
    return Array.from(this.plugins.values())
      .filter(plugin => 
        plugin.name.includes(query) || 
        plugin.description.includes(query) ||
        plugin.tags.some(tag => tag.includes(query))
      )
  }
  
  getPlugin(name: string): PluginInfo | undefined {
    return this.plugins.get(name)
  }
  
  listPlugins(): PluginInfo[] {
    return Array.from(this.plugins.values())
  }
}

interface PluginInfo {
  name: string
  version: string
  description: string
  author: string
  homepage: string
  repository: string
  tags: string[]
  dependencies: string[]
  peerDependencies: string[]
  license: string
  downloadUrl: string
}
```

### 2. 动态插件加载

```typescript
class DynamicPluginLoader {
  async loadPlugin(name: string, version?: string): Promise<Plugin> {
    try {
      // 1. 从注册中心获取插件信息
      const registry = PluginRegistry.getInstance()
      const pluginInfo = registry.getPlugin(name)
      
      if (!pluginInfo) {
        throw new Error(`Plugin ${name} not found`)
      }
      
      // 2. 动态导入插件
      const pluginModule = await import(pluginInfo.downloadUrl)
      
      // 3. 验证插件
      this.validatePlugin(pluginModule.default)
      
      return pluginModule.default
    } catch (error) {
      console.error(`Failed to load plugin ${name}:`, error)
      throw error
    }
  }
  
  private validatePlugin(plugin: any): void {
    if (!plugin.name || !plugin.version || !plugin.install) {
      throw new Error('Invalid plugin format')
    }
  }
}
```

---

> 🔧 **扩展理念**: 开放、灵活、强大 - 让每个开发者都能轻松扩展路由器功能！
