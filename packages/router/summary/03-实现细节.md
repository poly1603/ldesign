# @ldesign/router 实现细节

## 核心算法实现

### 1. 路由匹配算法

#### 路径匹配器

**位置**: `src/core/matcher.ts`

**核心思路**:

1. 预编译路由规则为正则表达式
2. 使用 Map 结构优化查找性能
3. 支持动态参数和通配符匹配

```typescript
class PathMatcher {
  private pathRegex: RegExp
  private keys: Array<{ name: string; optional: boolean }>

  constructor(path: string) {
    // 将路径模式转换为正则表达式
    // /user/:id -> /^\/user\/([^\/]+?)$/
    this.pathRegex = this.pathToRegexp(path)
  }

  private pathToRegexp(path: string): RegExp {
    const keys: Array<{ name: string; optional: boolean }> = []

    // 处理动态参数 :id
    let regex = path.replace(/:([^\/\?]+)(\?)?/g, (match, key, optional) => {
      keys.push({ name: key, optional: !!optional })
      return optional ? '([^/]+?)?' : '([^/]+?)'
    })

    // 处理通配符 *
    regex = regex.replace(/\*/g, '(.*)')

    this.keys = keys
    return new RegExp(`^${regex}$`)
  }

  match(path: string): RouteMatch | null {
    const match = this.pathRegex.exec(path)
    if (!match) return null

    const params: Record<string, string> = {}
    for (let i = 0; i < this.keys.length; i++) {
      const key = this.keys[i]
      const value = match[i + 1]
      if (value !== undefined || !key.optional) {
        params[key.name] = value
      }
    }

    return { params, path }
  }
}
```

#### 路由解析缓存

```typescript
class ResolveCache {
  private cache = new Map<string, RouteLocationNormalized>()
  private maxSize = 1000

  get(key: string): RouteLocationNormalized | undefined {
    const cached = this.cache.get(key)
    if (cached) {
      // LRU: 移到最后
      this.cache.delete(key)
      this.cache.set(key, cached)
    }
    return cached
  }

  set(key: string, value: RouteLocationNormalized): void {
    if (this.cache.size >= this.maxSize) {
      // 删除最旧的条目
      const firstKey = this.cache.keys().next().value
      this.cache.delete(firstKey)
    }
    this.cache.set(key, value)
  }
}
```

### 2. 导航守卫系统

#### 守卫执行流程

**位置**: `src/guards/route-guards.ts`

**执行顺序**:

1. 全局前置守卫 (beforeEach)
2. 路由独享守卫 (beforeEnter)
3. 组件内守卫 (beforeRouteEnter)
4. 全局解析守卫 (beforeResolve)
5. 导航确认
6. 全局后置钩子 (afterEach)

```typescript
class NavigationGuardRunner {
  async runGuards(
    guards: NavigationGuard[],
    to: RouteLocationNormalized,
    from: RouteLocationNormalized
  ): Promise<NavigationGuardReturn> {
    for (const guard of guards) {
      const result = await this.runSingleGuard(guard, to, from)

      if (result === false) {
        // 取消导航
        return false
      } else if (typeof result === 'string' || typeof result === 'object') {
        // 重定向
        return result
      }
      // 继续执行下一个守卫
    }

    return true
  }

  private async runSingleGuard(
    guard: NavigationGuard,
    to: RouteLocationNormalized,
    from: RouteLocationNormalized
  ): Promise<NavigationGuardReturn> {
    return new Promise(resolve => {
      const next: NavigationGuardNext = (result?: NavigationGuardReturn) => {
        resolve(result === undefined ? true : result)
      }

      const guardReturn = guard(to, from, next)

      // 处理 Promise 返回值
      if (guardReturn && typeof guardReturn.then === 'function') {
        guardReturn.then(next).catch(next)
      } else if (guardReturn !== undefined) {
        next(guardReturn)
      }
    })
  }
}
```

### 3. 历史管理实现

#### HTML5 History 模式

**位置**: `src/core/history.ts`

```typescript
class HTML5History implements RouterHistory {
  private listeners: Array<() => void> = []

  constructor(private base: string = '/') {
    this.setupListeners()
  }

  private setupListeners(): void {
    window.addEventListener('popstate', this.handlePopState)
  }

  private handlePopState = (event: PopStateEvent): void => {
    const location = this.getCurrentLocation()
    this.listeners.forEach(listener => listener(location))
  }

  push(to: string): void {
    const url = this.base + to.replace(/^\//, '')
    window.history.pushState({}, '', url)
    this.triggerListeners()
  }

  replace(to: string): void {
    const url = this.base + to.replace(/^\//, '')
    window.history.replaceState({}, '', url)
    this.triggerListeners()
  }

  go(delta: number): void {
    window.history.go(delta)
  }

  getCurrentLocation(): string {
    const path = window.location.pathname
    return path.replace(new RegExp(`^${this.base}`), '') || '/'
  }
}
```

#### Hash 模式

```typescript
class HashHistory implements RouterHistory {
  private listeners: Array<() => void> = []

  constructor() {
    this.setupListeners()
  }

  private setupListeners(): void {
    window.addEventListener('hashchange', this.handleHashChange)
  }

  private handleHashChange = (): void => {
    const location = this.getCurrentLocation()
    this.listeners.forEach(listener => listener(location))
  }

  push(to: string): void {
    window.location.hash = to
  }

  replace(to: string): void {
    const href = window.location.href.replace(/#.*$/, '')
    window.location.replace(href + '#' + to)
  }

  getCurrentLocation(): string {
    const hash = window.location.hash
    return hash.slice(1) || '/'
  }
}
```

## 性能优化实现

### 1. 预加载机制

#### 智能预加载策略

**位置**: `src/plugins/performance-plugin.ts`

```typescript
class RoutePreloader {
  private preloadCache = new Set<string>()

  // 悬停预加载
  setupHoverPreload(): void {
    document.addEventListener('mouseover', event => {
      const target = event.target as HTMLElement
      const link = target.closest('a[href]') as HTMLAnchorElement

      if (link && this.isInternalLink(link)) {
        this.preloadRoute(link.getAttribute('href')!)
      }
    })
  }

  // 可见性预加载
  setupVisiblePreload(): void {
    const observer = new IntersectionObserver(
      entries => {
        entries.forEach(entry => {
          if (entry.isIntersecting) {
            const link = entry.target as HTMLAnchorElement
            this.preloadRoute(link.getAttribute('href')!)
          }
        })
      },
      {
        rootMargin: '50px', // 提前50px开始预加载
      }
    )

    // 观察所有路由链接
    document.querySelectorAll('a[href]').forEach(link => {
      if (this.isInternalLink(link as HTMLAnchorElement)) {
        observer.observe(link)
      }
    })
  }

  // 空闲时预加载
  setupIdlePreload(): void {
    if ('requestIdleCallback' in window) {
      window.requestIdleCallback(() => {
        this.preloadAllRoutes()
      })
    }
  }

  private async preloadRoute(href: string): Promise<void> {
    if (this.preloadCache.has(href)) return

    this.preloadCache.add(href)

    try {
      const route = this.router.resolve(href)

      // 预加载组件
      if (route.matched.length > 0) {
        const components = route.matched[0].components
        if (components?.default && typeof components.default === 'function') {
          await components.default()
        }
      }
    } catch (error) {
      console.warn(`预加载路由失败: ${href}`, error)
    }
  }
}
```

### 2. 缓存系统实现

#### 多级缓存策略

**位置**: `src/plugins/cache-plugin.ts`

```typescript
class MultiLevelCache {
  private memoryCache = new Map<string, CacheEntry>()
  private persistentCache: Storage

  constructor(strategy: CacheStrategy) {
    this.persistentCache = strategy === 'localStorage' ? localStorage : sessionStorage
  }

  get(key: string): CacheEntry | null {
    // 1. 检查内存缓存
    let entry = this.memoryCache.get(key)
    if (entry && !this.isExpired(entry)) {
      return entry
    }

    // 2. 检查持久化缓存
    try {
      const stored = this.persistentCache.getItem(key)
      if (stored) {
        entry = JSON.parse(stored)
        if (!this.isExpired(entry)) {
          // 回写到内存缓存
          this.memoryCache.set(key, entry)
          return entry
        }
      }
    } catch (error) {
      console.warn('缓存读取失败:', error)
    }

    return null
  }

  set(key: string, entry: CacheEntry): void {
    // 写入内存缓存
    this.memoryCache.set(key, entry)

    // 写入持久化缓存
    try {
      this.persistentCache.setItem(key, JSON.stringify(entry))
    } catch (error) {
      console.warn('缓存写入失败:', error)
    }
  }

  private isExpired(entry: CacheEntry): boolean {
    return Date.now() - entry.timestamp > entry.ttl
  }
}
```

### 3. 组件优化

#### RouterView 优化

**位置**: `src/components/RouterView.ts`

```typescript
export default defineComponent({
  name: 'RouterView',

  setup(props, { slots }) {
    const route = useRoute()
    const depth = inject(routerViewDepthKey, 0)

    // 组件缓存
    const componentCache = new Map<string, Component>()

    const matchedRoute = computed(() => {
      const matched = route.matched[depth]
      if (!matched) return null

      // 缓存组件
      const cacheKey = matched.path + matched.name
      let component = componentCache.get(cacheKey)

      if (!component) {
        component = resolveComponent(matched)
        componentCache.set(cacheKey, component)
      }

      return { ...matched, component }
    })

    // 提供深度给子 RouterView
    provide(routerViewDepthKey, depth + 1)

    return () => {
      const matched = matchedRoute.value
      if (!matched) return null

      const component = matched.component
      if (!component) return null

      // 渲染组件
      return h(component, {
        key: matched.path,
        route: route.value,
      })
    }
  },
})
```

## 错误处理机制

### 1. 导航错误处理

```typescript
class NavigationErrorHandler {
  handleNavigationError(error: NavigationFailure): void {
    switch (error.type) {
      case NavigationFailureType.cancelled:
        console.warn('导航被取消:', error)
        break

      case NavigationFailureType.duplicated:
        console.warn('重复导航:', error)
        break

      case NavigationFailureType.redirected:
        console.info('导航重定向:', error)
        break

      default:
        console.error('导航错误:', error)
    }
  }
}
```

### 2. 组件加载错误处理

```typescript
function resolveComponent(matched: RouteRecordNormalized): Component | null {
  try {
    const component = matched.components?.default

    if (typeof component === 'function') {
      // 异步组件错误处理
      return defineAsyncComponent({
        loader: component as () => Promise<Component>,
        errorComponent: ErrorComponent,
        loadingComponent: LoadingComponent,
        timeout: 5000,
      })
    }

    return component as Component
  } catch (error) {
    console.error('组件解析失败:', error)
    return ErrorComponent
  }
}
```

## 内存管理

### 1. 弱引用使用

```typescript
class WeakRefManager {
  private refs = new Set<WeakRef<any>>()

  addRef<T extends object>(obj: T): WeakRef<T> {
    const ref = new WeakRef(obj)
    this.refs.add(ref)
    return ref
  }

  cleanup(): void {
    for (const ref of this.refs) {
      if (ref.deref() === undefined) {
        this.refs.delete(ref)
      }
    }
  }
}
```

### 2. 定时清理机制

```typescript
class MemoryManager {
  private cleanupTimer: number | null = null

  startCleanup(): void {
    this.cleanupTimer = window.setInterval(() => {
      this.performCleanup()
    }, 60000) // 每分钟清理一次
  }

  stopCleanup(): void {
    if (this.cleanupTimer) {
      clearInterval(this.cleanupTimer)
      this.cleanupTimer = null
    }
  }

  private performCleanup(): void {
    // 清理过期缓存
    this.cleanupExpiredCache()

    // 清理弱引用
    this.cleanupWeakRefs()

    // 清理事件监听器
    this.cleanupEventListeners()
  }
}
```

## 总结

@ldesign/router 的实现细节体现了以下特点：

1. **算法优化**: 高效的路由匹配和缓存算法
2. **内存管理**: 完善的内存管理和清理机制
3. **错误处理**: 全面的错误处理和恢复机制
4. **性能优化**: 多层级的性能优化策略
5. **扩展性**: 良好的扩展接口和插件系统

这些实现细节确保了路由系统的高性能、稳定性和可维护性。
