# @ldesign/http 实现细节

## 核心功能实现

### 1. HTTP 客户端实现

#### 客户端初始化
```typescript
export function createHttpClient(config: HttpConfig = {}): HttpClient {
  // 合并默认配置
  const mergedConfig = mergeConfig(defaultConfig, config)
  
  // 创建适配器
  const adapter = createAdapter(mergedConfig.adapter)
  
  // 创建管理器实例
  const interceptorManager = new InterceptorManager()
  const cacheManager = createCacheManager(mergedConfig.cache)
  const retryManager = createRetryManager(mergedConfig.retry)
  const concurrencyManager = createConcurrencyManager(mergedConfig.concurrency)
  
  return new HttpClient({
    config: mergedConfig,
    adapter,
    interceptorManager,
    cacheManager,
    retryManager,
    concurrencyManager
  })
}
```

#### 请求执行流程
```typescript
class HttpClient {
  async request<T>(config: RequestConfig): Promise<ResponseData<T>> {
    // 1. 配置预处理
    const processedConfig = this.preprocessConfig(config)
    
    // 2. 请求拦截器
    const interceptedConfig = await this.interceptorManager.processRequest(processedConfig)
    
    // 3. 缓存检查
    if (this.shouldUseCache(interceptedConfig)) {
      const cached = await this.cacheManager.get<T>(interceptedConfig)
      if (cached) {
        return cached
      }
    }
    
    // 4. 并发控制和去重
    const response = await this.concurrencyManager.execute(
      () => this.executeWithRetry<T>(interceptedConfig),
      interceptedConfig
    )
    
    // 5. 缓存存储
    if (this.shouldCache(interceptedConfig, response)) {
      await this.cacheManager.set(interceptedConfig, response)
    }
    
    // 6. 响应拦截器
    return this.interceptorManager.processResponse(response)
  }
  
  private async executeWithRetry<T>(config: RequestConfig): Promise<ResponseData<T>> {
    return this.retryManager.execute(
      () => this.adapter.request<T>(config),
      config
    )
  }
}
```

### 2. 适配器实现细节

#### Fetch 适配器
```typescript
class FetchAdapter implements HttpAdapter {
  async request<T>(config: RequestConfig): Promise<ResponseData<T>> {
    // 构建请求选项
    const fetchOptions: RequestInit = {
      method: config.method,
      headers: this.buildHeaders(config.headers),
      body: this.buildBody(config.data),
      signal: config.signal
    }
    
    // 处理超时
    const controller = new AbortController()
    const timeoutId = config.timeout 
      ? setTimeout(() => controller.abort(), config.timeout)
      : null
    
    try {
      // 发起请求
      const response = await fetch(this.buildURL(config), {
        ...fetchOptions,
        signal: config.signal || controller.signal
      })
      
      // 解析响应
      const data = await this.parseResponse<T>(response, config.responseType)
      
      return {
        data,
        status: response.status,
        statusText: response.statusText,
        headers: this.parseHeaders(response.headers),
        config
      }
    } catch (error) {
      throw this.transformError(error, config)
    } finally {
      if (timeoutId) {
        clearTimeout(timeoutId)
      }
    }
  }
  
  private async parseResponse<T>(response: Response, responseType?: string): Promise<T> {
    switch (responseType) {
      case 'json':
        return response.json()
      case 'text':
        return response.text() as T
      case 'blob':
        return response.blob() as T
      case 'arrayBuffer':
        return response.arrayBuffer() as T
      default:
        // 根据 Content-Type 自动判断
        const contentType = response.headers.get('content-type') || ''
        if (contentType.includes('application/json')) {
          return response.json()
        } else if (contentType.includes('text/')) {
          return response.text() as T
        } else {
          return response.blob() as T
        }
    }
  }
}
```

#### Axios 适配器
```typescript
class AxiosAdapter implements HttpAdapter {
  private axios: AxiosInstance
  
  constructor() {
    this.axios = axios.create()
  }
  
  async request<T>(config: RequestConfig): Promise<ResponseData<T>> {
    try {
      // 转换配置格式
      const axiosConfig = this.transformConfig(config)
      
      // 发起请求
      const response = await this.axios.request<T>(axiosConfig)
      
      // 转换响应格式
      return this.transformResponse(response, config)
    } catch (error) {
      throw this.transformError(error, config)
    }
  }
  
  private transformConfig(config: RequestConfig): AxiosRequestConfig {
    return {
      url: config.url,
      method: config.method,
      headers: config.headers,
      params: config.params,
      data: config.data,
      timeout: config.timeout,
      responseType: config.responseType,
      signal: config.signal
    }
  }
}
```

### 3. 缓存系统实现

#### 高级缓存管理器
```typescript
class AdvancedCacheManager extends CacheManager {
  private stats: CacheStats
  private tagIndex = new Map<string, Set<string>>()
  private dependencyGraph = new Map<string, Set<string>>()
  
  async get<T>(config: RequestConfig): Promise<ResponseData<T> | null> {
    const key = this.getCachedKey(config)
    
    try {
      const cached = await this.storage.get(key)
      if (cached && !this.isExpired(cached)) {
        this.updateStats('hit')
        this.updateAccessLog(key)
        return cached.data
      }
    } catch (error) {
      console.warn('Cache get error:', error)
    }
    
    this.updateStats('miss')
    return null
  }
  
  async set<T>(
    config: RequestConfig,
    response: ResponseData<T>,
    options?: CacheSetOptions
  ): Promise<void> {
    const key = this.getCachedKey(config)
    const ttl = options?.ttl ?? this.config.ttl
    
    const cacheItem: CacheItem = {
      data: response,
      timestamp: Date.now(),
      ttl,
      metadata: {
        tags: options?.tags,
        dependencies: options?.dependencies,
        size: this.calculateSize(response)
      }
    }
    
    // 存储缓存项
    await this.storage.set(key, cacheItem)
    
    // 更新索引
    this.updateTagIndex(key, options?.tags)
    this.updateDependencyGraph(key, options?.dependencies)
    
    // 更新统计
    this.updateStats('set')
  }
  
  async invalidateByTag(tag: string): Promise<number> {
    const keys = this.tagIndex.get(tag)
    if (!keys) return 0
    
    let invalidatedCount = 0
    for (const key of keys) {
      await this.storage.delete(key)
      invalidatedCount++
    }
    
    this.tagIndex.delete(tag)
    return invalidatedCount
  }
}
```

#### LRU 缓存策略
```typescript
class LRUCacheStorage implements CacheStorage {
  private cache = new Map<string, CacheItem>()
  private maxSize: number
  
  constructor(maxSize: number = 100) {
    this.maxSize = maxSize
  }
  
  async get(key: string): Promise<CacheItem | null> {
    const item = this.cache.get(key)
    if (item) {
      // 移动到最前面（最近使用）
      this.cache.delete(key)
      this.cache.set(key, item)
      return item
    }
    return null
  }
  
  async set(key: string, value: CacheItem): Promise<void> {
    // 如果已存在，先删除
    if (this.cache.has(key)) {
      this.cache.delete(key)
    }
    // 如果超过最大大小，删除最久未使用的
    else if (this.cache.size >= this.maxSize) {
      const firstKey = this.cache.keys().next().value
      this.cache.delete(firstKey)
    }
    
    // 添加到最前面
    this.cache.set(key, value)
  }
  
  async delete(key: string): Promise<void> {
    this.cache.delete(key)
  }
  
  async clear(): Promise<void> {
    this.cache.clear()
  }
}
```

### 4. 重试机制实现

#### 重试管理器
```typescript
class RetryManager {
  async execute<T>(
    requestFn: () => Promise<ResponseData<T>>,
    config: RequestConfig
  ): Promise<ResponseData<T>> {
    const retryConfig = this.getRetryConfig(config)
    
    if (!retryConfig.enabled) {
      return requestFn()
    }
    
    let lastError: Error
    let attempt = 0
    
    while (attempt < retryConfig.maxAttempts) {
      try {
        const result = await requestFn()
        
        // 记录成功统计
        if (attempt > 0) {
          this.recordRetrySuccess(attempt)
        }
        
        return result
      } catch (error) {
        lastError = error
        attempt++
        
        // 检查是否应该重试
        if (!this.shouldRetry(error as HttpError, attempt, retryConfig)) {
          break
        }
        
        // 计算延迟时间
        const delay = this.calculateDelay(attempt, retryConfig)
        
        // 记录重试统计
        this.recordRetryAttempt(error as HttpError, attempt, delay)
        
        // 等待延迟
        await this.sleep(delay)
      }
    }
    
    // 记录重试失败统计
    this.recordRetryFailure(lastError as HttpError, attempt)
    
    throw lastError
  }
  
  private shouldRetry(error: HttpError, attempt: number, config: RetryConfig): boolean {
    // 检查最大重试次数
    if (attempt >= config.maxAttempts) {
      return false
    }
    
    // 自定义重试条件
    if (config.condition) {
      return config.condition(error)
    }
    
    // 默认重试条件
    return this.isRetryableError(error)
  }
  
  private isRetryableError(error: HttpError): boolean {
    // 网络错误
    if (error.isNetworkError) {
      return true
    }
    
    // 超时错误
    if (error.isTimeoutError) {
      return true
    }
    
    // 5xx 服务器错误
    if (error.response?.status >= 500) {
      return true
    }
    
    // 429 限流错误
    if (error.response?.status === 429) {
      return true
    }
    
    return false
  }
  
  private calculateDelay(attempt: number, config: RetryConfig): number {
    if (config.delayFn) {
      return config.delayFn(attempt)
    }
    
    const baseDelay = config.delay || 1000
    
    switch (config.backoff) {
      case 'exponential':
        return Math.min(baseDelay * Math.pow(2, attempt - 1), 30000)
      case 'linear':
        return baseDelay * attempt
      default:
        return baseDelay
    }
  }
}
```

### 5. 请求去重实现

#### 去重管理器
```typescript
class DeduplicationManager {
  private runningTasks = new Map<string, Promise<any>>()
  private stats: DeduplicationStats = {
    executions: 0,
    duplications: 0,
    savedRequests: 0,
    deduplicationRate: 0
  }
  
  async execute<T>(
    key: string,
    requestFn: () => Promise<T>
  ): Promise<T> {
    // 检查是否已有相同请求在执行
    const existingTask = this.runningTasks.get(key)
    if (existingTask) {
      this.stats.duplications++
      this.stats.savedRequests++
      this.updateDeduplicationRate()
      return existingTask
    }
    
    // 创建新任务
    const task = this.createTask(key, requestFn)
    this.runningTasks.set(key, task)
    this.stats.executions++
    
    try {
      const result = await task
      return result
    } finally {
      // 清理完成的任务
      this.runningTasks.delete(key)
      this.updateDeduplicationRate()
    }
  }
  
  private async createTask<T>(
    key: string,
    requestFn: () => Promise<T>
  ): Promise<T> {
    try {
      return await requestFn()
    } catch (error) {
      // 确保错误情况下也清理任务
      this.runningTasks.delete(key)
      throw error
    }
  }
  
  private updateDeduplicationRate(): void {
    const total = this.stats.executions + this.stats.duplications
    this.stats.deduplicationRate = total > 0 ? this.stats.duplications / total : 0
  }
}
```

#### 去重键生成器
```typescript
class DeduplicationKeyGenerator {
  private config: DeduplicationKeyConfig
  
  constructor(config: DeduplicationKeyConfig = {}) {
    this.config = {
      includeMethod: true,
      includeUrl: true,
      includeParams: true,
      includeData: false,
      ...config
    }
  }
  
  generate(requestConfig: RequestConfig): string {
    const parts: string[] = []
    
    if (this.config.includeMethod && requestConfig.method) {
      parts.push(`method:${requestConfig.method}`)
    }
    
    if (this.config.includeUrl && requestConfig.url) {
      parts.push(`url:${requestConfig.url}`)
    }
    
    if (this.config.includeParams && requestConfig.params) {
      const sortedParams = this.sortObject(requestConfig.params)
      parts.push(`params:${JSON.stringify(sortedParams)}`)
    }
    
    if (this.config.includeData && requestConfig.data) {
      const dataString = this.serializeData(requestConfig.data)
      parts.push(`data:${dataString}`)
    }
    
    if (this.config.customGenerator) {
      return this.config.customGenerator(requestConfig)
    }
    
    return parts.join('|')
  }
  
  private serializeData(data: any): string {
    if (data instanceof FormData) {
      return this.serializeFormData(data)
    }
    
    if (typeof data === 'object' && data !== null) {
      return JSON.stringify(this.sortObject(data))
    }
    
    return String(data)
  }
  
  private serializeFormData(formData: FormData): string {
    const entries: string[] = []
    
    for (const [key, value] of formData.entries()) {
      if (value instanceof File) {
        entries.push(`${key}:[File:${value.name}:${value.size}]`)
      } else {
        entries.push(`${key}:${value}`)
      }
    }
    
    return entries.sort().join(',')
  }
  
  private sortObject(obj: Record<string, any>): Record<string, any> {
    const sorted: Record<string, any> = {}
    const keys = Object.keys(obj).sort()
    
    for (const key of keys) {
      sorted[key] = obj[key]
    }
    
    return sorted
  }
}
```

### 6. 错误处理实现

#### 错误恢复策略
```typescript
const networkReconnectStrategy: ErrorRecoveryStrategy = {
  name: 'network-reconnect',
  priority: 10,
  canHandle: (error: HttpError) => error.isNetworkError,
  recover: async (error: HttpError): Promise<boolean> => {
    try {
      // 尝试简单的网络连通性检查
      const response = await fetch('/ping', { 
        method: 'HEAD',
        cache: 'no-cache',
        signal: AbortSignal.timeout(5000)
      })
      return response.ok
    } catch {
      return false
    }
  }
}

const authRefreshStrategy: ErrorRecoveryStrategy = {
  name: 'auth-refresh',
  priority: 20,
  canHandle: (error: HttpError) => error.response?.status === 401,
  recover: async (error: HttpError): Promise<boolean> => {
    try {
      const refreshToken = localStorage.getItem('refreshToken')
      if (!refreshToken) return false

      const response = await fetch('/auth/refresh', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ refreshToken })
      })

      if (response.ok) {
        const data = await response.json()
        localStorage.setItem('accessToken', data.accessToken)
        localStorage.setItem('refreshToken', data.refreshToken)
        return true
      }
    } catch {
      localStorage.removeItem('accessToken')
      localStorage.removeItem('refreshToken')
    }
    
    return false
  }
}
```

这些实现细节展示了 @ldesign/http 如何通过精心设计的算法和数据结构来实现高性能、可靠的 HTTP 客户端功能。每个组件都经过优化，确保在各种场景下都能提供最佳的性能和用户体验。
