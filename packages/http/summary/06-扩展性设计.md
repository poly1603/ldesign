# @ldesign/http 扩展性设计

## 扩展性原则

### 1. 开放封闭原则 (Open-Closed Principle)
- 对扩展开放：支持新功能的添加
- 对修改封闭：不破坏现有功能

### 2. 插件化架构
- 核心功能最小化
- 高级功能通过插件提供
- 插件间相互独立

### 3. 接口驱动设计
- 定义清晰的接口契约
- 支持多种实现方式
- 便于测试和替换

## 扩展点设计

### 1. 适配器扩展

#### 适配器接口
```typescript
interface HttpAdapter {
  /** 适配器名称 */
  name: string
  
  /** 检查是否支持当前环境 */
  isSupported(): boolean
  
  /** 执行 HTTP 请求 */
  request<T = any>(config: RequestConfig): Promise<ResponseData<T>>
}
```

#### 自定义适配器实现
```typescript
class GraphQLAdapter implements HttpAdapter {
  name = 'graphql'
  
  isSupported(): boolean {
    return typeof fetch !== 'undefined'
  }
  
  async request<T>(config: RequestConfig): Promise<ResponseData<T>> {
    // GraphQL 特定的请求处理逻辑
    const query = config.data?.query
    const variables = config.data?.variables
    
    const response = await fetch(config.url, {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
        ...config.headers
      },
      body: JSON.stringify({ query, variables })
    })
    
    const result = await response.json()
    
    return {
      data: result.data,
      status: response.status,
      statusText: response.statusText,
      headers: Object.fromEntries(response.headers.entries()),
      config
    }
  }
}

// 使用自定义适配器
const client = createHttpClient({
  adapter: new GraphQLAdapter()
})
```

#### WebSocket 适配器示例
```typescript
class WebSocketAdapter implements HttpAdapter {
  name = 'websocket'
  private connections = new Map<string, WebSocket>()
  
  isSupported(): boolean {
    return typeof WebSocket !== 'undefined'
  }
  
  async request<T>(config: RequestConfig): Promise<ResponseData<T>> {
    const ws = this.getConnection(config.url)
    
    return new Promise((resolve, reject) => {
      const messageId = this.generateMessageId()
      
      const message = {
        id: messageId,
        type: config.method,
        data: config.data
      }
      
      const timeout = setTimeout(() => {
        reject(new Error('WebSocket request timeout'))
      }, config.timeout || 30000)
      
      const handleMessage = (event: MessageEvent) => {
        const response = JSON.parse(event.data)
        if (response.id === messageId) {
          clearTimeout(timeout)
          ws.removeEventListener('message', handleMessage)
          
          resolve({
            data: response.data,
            status: response.status || 200,
            statusText: response.statusText || 'OK',
            headers: response.headers || {},
            config
          })
        }
      }
      
      ws.addEventListener('message', handleMessage)
      ws.send(JSON.stringify(message))
    })
  }
}
```

### 2. 缓存策略扩展

#### 缓存策略接口
```typescript
interface CacheStrategy {
  name: string
  get(key: string): Promise<CacheItem | null>
  set(key: string, value: CacheItem): Promise<void>
  delete(key: string): Promise<void>
  clear(): Promise<void>
  size(): Promise<number>
}
```

#### Redis 缓存策略
```typescript
class RedisCacheStrategy implements CacheStrategy {
  name = 'redis'
  private client: RedisClient
  
  constructor(redisClient: RedisClient) {
    this.client = redisClient
  }
  
  async get(key: string): Promise<CacheItem | null> {
    const value = await this.client.get(key)
    return value ? JSON.parse(value) : null
  }
  
  async set(key: string, value: CacheItem): Promise<void> {
    const ttl = value.ttl || 0
    const serialized = JSON.stringify(value)
    
    if (ttl > 0) {
      await this.client.setex(key, Math.floor(ttl / 1000), serialized)
    } else {
      await this.client.set(key, serialized)
    }
  }
  
  async delete(key: string): Promise<void> {
    await this.client.del(key)
  }
  
  async clear(): Promise<void> {
    await this.client.flushdb()
  }
  
  async size(): Promise<number> {
    return this.client.dbsize()
  }
}
```

#### IndexedDB 缓存策略
```typescript
class IndexedDBCacheStrategy implements CacheStrategy {
  name = 'indexeddb'
  private dbName = 'http-cache'
  private storeName = 'cache-items'
  
  async get(key: string): Promise<CacheItem | null> {
    const db = await this.openDB()
    const transaction = db.transaction([this.storeName], 'readonly')
    const store = transaction.objectStore(this.storeName)
    
    return new Promise((resolve, reject) => {
      const request = store.get(key)
      request.onsuccess = () => resolve(request.result || null)
      request.onerror = () => reject(request.error)
    })
  }
  
  async set(key: string, value: CacheItem): Promise<void> {
    const db = await this.openDB()
    const transaction = db.transaction([this.storeName], 'readwrite')
    const store = transaction.objectStore(this.storeName)
    
    return new Promise((resolve, reject) => {
      const request = store.put(value, key)
      request.onsuccess = () => resolve()
      request.onerror = () => reject(request.error)
    })
  }
  
  private async openDB(): Promise<IDBDatabase> {
    return new Promise((resolve, reject) => {
      const request = indexedDB.open(this.dbName, 1)
      
      request.onsuccess = () => resolve(request.result)
      request.onerror = () => reject(request.error)
      
      request.onupgradeneeded = () => {
        const db = request.result
        if (!db.objectStoreNames.contains(this.storeName)) {
          db.createObjectStore(this.storeName)
        }
      }
    })
  }
}
```

### 3. 拦截器扩展

#### 拦截器接口
```typescript
interface Interceptor {
  name?: string
  priority?: number
  request?: (config: RequestConfig) => RequestConfig | Promise<RequestConfig>
  response?: (response: ResponseData) => ResponseData | Promise<ResponseData>
  responseError?: (error: HttpError) => any
}
```

#### 性能监控拦截器
```typescript
class PerformanceInterceptor implements Interceptor {
  name = 'performance'
  priority = 1
  
  private startTimes = new Map<string, number>()
  
  request(config: RequestConfig): RequestConfig {
    const requestId = this.generateRequestId()
    config.metadata = { ...config.metadata, requestId }
    this.startTimes.set(requestId, performance.now())
    
    return config
  }
  
  response(response: ResponseData): ResponseData {
    const requestId = response.config.metadata?.requestId
    if (requestId) {
      const startTime = this.startTimes.get(requestId)
      if (startTime) {
        const duration = performance.now() - startTime
        this.recordMetrics(response.config, duration, true)
        this.startTimes.delete(requestId)
      }
    }
    
    return response
  }
  
  responseError(error: HttpError): Promise<never> {
    const requestId = error.config?.metadata?.requestId
    if (requestId) {
      const startTime = this.startTimes.get(requestId)
      if (startTime) {
        const duration = performance.now() - startTime
        this.recordMetrics(error.config, duration, false)
        this.startTimes.delete(requestId)
      }
    }
    
    return Promise.reject(error)
  }
  
  private recordMetrics(config: RequestConfig, duration: number, success: boolean): void {
    // 发送性能指标到监控系统
    const metrics = {
      url: config.url,
      method: config.method,
      duration,
      success,
      timestamp: Date.now()
    }
    
    // 可以发送到 APM 系统、日志服务等
    this.sendToMonitoring(metrics)
  }
}
```

#### 请求签名拦截器
```typescript
class SignatureInterceptor implements Interceptor {
  name = 'signature'
  priority = 10
  
  constructor(private secretKey: string) {}
  
  request(config: RequestConfig): RequestConfig {
    const timestamp = Date.now().toString()
    const nonce = this.generateNonce()
    
    // 构建签名字符串
    const signString = this.buildSignString(config, timestamp, nonce)
    
    // 生成签名
    const signature = this.generateSignature(signString, this.secretKey)
    
    // 添加签名头
    config.headers = {
      ...config.headers,
      'X-Timestamp': timestamp,
      'X-Nonce': nonce,
      'X-Signature': signature
    }
    
    return config
  }
  
  private buildSignString(config: RequestConfig, timestamp: string, nonce: string): string {
    const parts = [
      config.method?.toUpperCase(),
      config.url,
      timestamp,
      nonce
    ]
    
    if (config.data && typeof config.data === 'object') {
      parts.push(JSON.stringify(config.data))
    }
    
    return parts.join('|')
  }
  
  private generateSignature(data: string, secret: string): string {
    // 使用 HMAC-SHA256 生成签名
    return crypto.subtle.digest('SHA-256', 
      new TextEncoder().encode(data + secret)
    ).then(buffer => 
      Array.from(new Uint8Array(buffer))
        .map(b => b.toString(16).padStart(2, '0'))
        .join('')
    )
  }
}
```

### 4. 中间件扩展

#### 中间件接口
```typescript
type Middleware = (
  config: RequestConfig,
  next: (config: RequestConfig) => Promise<ResponseData>
) => Promise<ResponseData>
```

#### 断路器中间件
```typescript
class CircuitBreakerMiddleware {
  private failures = new Map<string, number>()
  private lastFailureTime = new Map<string, number>()
  private state = new Map<string, 'CLOSED' | 'OPEN' | 'HALF_OPEN'>()
  
  constructor(
    private failureThreshold = 5,
    private recoveryTimeout = 60000
  ) {}
  
  middleware: Middleware = async (config, next) => {
    const key = this.getCircuitKey(config)
    const currentState = this.getState(key)
    
    switch (currentState) {
      case 'OPEN':
        if (this.shouldAttemptRecovery(key)) {
          this.setState(key, 'HALF_OPEN')
          return this.executeRequest(config, next, key)
        } else {
          throw new Error('Circuit breaker is OPEN')
        }
      
      case 'HALF_OPEN':
      case 'CLOSED':
        return this.executeRequest(config, next, key)
    }
  }
  
  private async executeRequest(
    config: RequestConfig,
    next: (config: RequestConfig) => Promise<ResponseData>,
    key: string
  ): Promise<ResponseData> {
    try {
      const response = await next(config)
      this.onSuccess(key)
      return response
    } catch (error) {
      this.onFailure(key)
      throw error
    }
  }
  
  private onSuccess(key: string): void {
    this.failures.set(key, 0)
    this.setState(key, 'CLOSED')
  }
  
  private onFailure(key: string): void {
    const currentFailures = this.failures.get(key) || 0
    const newFailures = currentFailures + 1
    
    this.failures.set(key, newFailures)
    this.lastFailureTime.set(key, Date.now())
    
    if (newFailures >= this.failureThreshold) {
      this.setState(key, 'OPEN')
    }
  }
}
```

### 5. 错误恢复策略扩展

#### 错误恢复策略接口
```typescript
interface ErrorRecoveryStrategy {
  name: string
  priority?: number
  canHandle: (error: HttpError) => boolean
  recover: (error: HttpError) => Promise<boolean>
}
```

#### 服务降级策略
```typescript
class ServiceDegradationStrategy implements ErrorRecoveryStrategy {
  name = 'service-degradation'
  priority = 5
  
  constructor(private fallbackServices: Map<string, string>) {}
  
  canHandle(error: HttpError): boolean {
    const status = error.response?.status
    return status === 503 || status === 502 || status === 504
  }
  
  async recover(error: HttpError): Promise<boolean> {
    const originalUrl = error.config?.url
    if (!originalUrl) return false
    
    // 查找降级服务
    const fallbackUrl = this.findFallbackService(originalUrl)
    if (!fallbackUrl) return false
    
    try {
      // 测试降级服务是否可用
      const response = await fetch(fallbackUrl, {
        method: 'HEAD',
        signal: AbortSignal.timeout(3000)
      })
      
      return response.ok
    } catch {
      return false
    }
  }
  
  private findFallbackService(url: string): string | null {
    for (const [pattern, fallback] of this.fallbackServices) {
      if (url.includes(pattern)) {
        return url.replace(pattern, fallback)
      }
    }
    return null
  }
}
```

### 6. 插件系统

#### 插件接口
```typescript
interface HttpPlugin {
  name: string
  version?: string
  install: (client: HttpClient, options?: any) => void
  uninstall?: (client: HttpClient) => void
}
```

#### 插件管理器
```typescript
class PluginManager {
  private plugins = new Map<string, HttpPlugin>()
  private installedPlugins = new Set<string>()
  
  register(plugin: HttpPlugin): void {
    this.plugins.set(plugin.name, plugin)
  }
  
  install(client: HttpClient, pluginName: string, options?: any): void {
    const plugin = this.plugins.get(pluginName)
    if (!plugin) {
      throw new Error(`Plugin "${pluginName}" not found`)
    }
    
    if (this.installedPlugins.has(pluginName)) {
      throw new Error(`Plugin "${pluginName}" already installed`)
    }
    
    plugin.install(client, options)
    this.installedPlugins.add(pluginName)
  }
  
  uninstall(client: HttpClient, pluginName: string): void {
    const plugin = this.plugins.get(pluginName)
    if (!plugin || !this.installedPlugins.has(pluginName)) {
      return
    }
    
    if (plugin.uninstall) {
      plugin.uninstall(client)
    }
    
    this.installedPlugins.delete(pluginName)
  }
}
```

#### 示例插件：请求重复检测
```typescript
class RequestDeduplicationPlugin implements HttpPlugin {
  name = 'request-deduplication'
  version = '1.0.0'
  
  private pendingRequests = new Map<string, Promise<ResponseData>>()
  
  install(client: HttpClient, options: { keyGenerator?: (config: RequestConfig) => string } = {}): void {
    const keyGenerator = options.keyGenerator || this.defaultKeyGenerator
    
    client.addRequestInterceptor(async (config) => {
      const key = keyGenerator(config)
      
      // 检查是否有相同的请求正在进行
      const existingRequest = this.pendingRequests.get(key)
      if (existingRequest) {
        // 等待现有请求完成
        return existingRequest
      }
      
      return config
    })
    
    client.addResponseInterceptor(
      (response) => {
        // 清理完成的请求
        const key = keyGenerator(response.config)
        this.pendingRequests.delete(key)
        return response
      },
      (error) => {
        // 清理失败的请求
        const key = keyGenerator(error.config)
        this.pendingRequests.delete(key)
        return Promise.reject(error)
      }
    )
  }
  
  private defaultKeyGenerator(config: RequestConfig): string {
    return `${config.method}:${config.url}:${JSON.stringify(config.params || {})}`
  }
}
```

## 扩展最佳实践

### 1. 接口设计原则
- 保持接口简单明确
- 提供合理的默认实现
- 支持配置和定制

### 2. 向后兼容性
- 使用语义化版本控制
- 提供迁移指南
- 保持 API 稳定性

### 3. 文档和示例
- 提供详细的扩展文档
- 包含完整的示例代码
- 说明最佳实践

### 4. 测试覆盖
- 为扩展点编写测试
- 提供测试工具和模拟
- 确保扩展的质量

这种扩展性设计使得 @ldesign/http 能够适应各种不同的使用场景和技术栈，同时保持核心功能的稳定性和简洁性。
