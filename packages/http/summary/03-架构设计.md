# @ldesign/http 架构设计

## 整体架构

### 分层架构图

```
┌─────────────────────────────────────────────────────────────┐
│                    应用层 (Application Layer)                │
│  ┌─────────────────┐  ┌─────────────────┐  ┌─────────────────┐ │
│  │   Vue Plugin    │  │  React Hooks    │  │  Vanilla JS     │ │
│  └─────────────────┘  └─────────────────┘  └─────────────────┘ │
└─────────────────────────────────────────────────────────────┘
┌─────────────────────────────────────────────────────────────┐
│                    API 层 (API Layer)                       │
│  ┌─────────────────┐  ┌─────────────────┐  ┌─────────────────┐ │
│  │   HTTP Client   │  │   Upload/Download│  │   Type Utils    │ │
│  └─────────────────┘  └─────────────────┘  └─────────────────┘ │
└─────────────────────────────────────────────────────────────┘
┌─────────────────────────────────────────────────────────────┐
│                   功能层 (Feature Layer)                     │
│  ┌─────────────────┐  ┌─────────────────┐  ┌─────────────────┐ │
│  │     Cache       │  │     Retry       │  │  Deduplication  │ │
│  └─────────────────┘  └─────────────────┘  └─────────────────┘ │
│  ┌─────────────────┐  ┌─────────────────┐  ┌─────────────────┐ │
│  │  Interceptors   │  │ Error Recovery  │  │   Concurrency   │ │
│  └─────────────────┘  └─────────────────┘  └─────────────────┘ │
└─────────────────────────────────────────────────────────────┘
┌─────────────────────────────────────────────────────────────┐
│                   适配器层 (Adapter Layer)                   │
│  ┌─────────────────┐  ┌─────────────────┐  ┌─────────────────┐ │
│  │  Fetch Adapter  │  │  Axios Adapter  │  │  Alova Adapter  │ │
│  └─────────────────┘  └─────────────────┘  └─────────────────┘ │
└─────────────────────────────────────────────────────────────┘
┌─────────────────────────────────────────────────────────────┐
│                   基础层 (Foundation Layer)                  │
│  ┌─────────────────┐  ┌─────────────────┐  ┌─────────────────┐ │
│  │   Type System   │  │   Utilities     │  │   Constants     │ │
│  └─────────────────┘  └─────────────────┘  └─────────────────┘ │
└─────────────────────────────────────────────────────────────┘
```

## 核心组件设计

### 1. HttpClient 核心类

```typescript
class HttpClient {
  private adapter: HttpAdapter
  private interceptorManager: InterceptorManager
  private cacheManager: CacheManager
  private retryManager: RetryManager
  private concurrencyManager: ConcurrencyManager
  private config: HttpConfig

  constructor(config: HttpConfig) {
    this.config = this.mergeConfig(config)
    this.adapter = this.createAdapter()
    this.interceptorManager = new InterceptorManager()
    this.cacheManager = this.createCacheManager()
    this.retryManager = this.createRetryManager()
    this.concurrencyManager = this.createConcurrencyManager()
  }

  async request<T>(config: RequestConfig): Promise<ResponseData<T>> {
    // 1. 预处理配置
    const processedConfig = await this.preprocessConfig(config)
    
    // 2. 执行请求拦截器
    const interceptedConfig = await this.interceptorManager.processRequest(processedConfig)
    
    // 3. 执行请求（带缓存、重试、并发控制）
    const response = await this.executeRequest(interceptedConfig)
    
    // 4. 执行响应拦截器
    const interceptedResponse = await this.interceptorManager.processResponse(response)
    
    return interceptedResponse
  }
}
```

### 2. 适配器系统

#### 适配器接口
```typescript
interface HttpAdapter {
  name: string
  isSupported(): boolean
  request(config: RequestConfig): Promise<ResponseData>
}
```

#### 适配器实现
```typescript
class FetchAdapter implements HttpAdapter {
  name = 'fetch'
  
  isSupported(): boolean {
    return typeof fetch !== 'undefined'
  }
  
  async request(config: RequestConfig): Promise<ResponseData> {
    const response = await fetch(config.url, {
      method: config.method,
      headers: config.headers,
      body: config.data,
      signal: config.signal
    })
    
    return {
      data: await this.parseResponse(response, config.responseType),
      status: response.status,
      statusText: response.statusText,
      headers: this.parseHeaders(response.headers),
      config
    }
  }
}
```

### 3. 拦截器管理器

```typescript
class InterceptorManager {
  private requestInterceptors: RequestInterceptor[] = []
  private responseInterceptors: ResponseInterceptor[] = []
  private errorInterceptors: ErrorInterceptor[] = []

  addRequestInterceptor(interceptor: RequestInterceptor): number {
    return this.requestInterceptors.push(interceptor) - 1
  }

  async processRequest(config: RequestConfig): Promise<RequestConfig> {
    let processedConfig = config
    
    for (const interceptor of this.requestInterceptors) {
      processedConfig = await interceptor(processedConfig)
    }
    
    return processedConfig
  }

  async processResponse(response: ResponseData): Promise<ResponseData> {
    let processedResponse = response
    
    for (const interceptor of this.responseInterceptors) {
      processedResponse = await interceptor(processedResponse)
    }
    
    return processedResponse
  }
}
```

### 4. 缓存管理器

```typescript
class AdvancedCacheManager {
  private storage: CacheStorage
  private strategy: CacheStrategy
  private stats: CacheStats
  private tagIndex: Map<string, Set<string>>
  private dependencyGraph: Map<string, Set<string>>

  async get<T>(config: RequestConfig): Promise<ResponseData<T> | null> {
    const key = this.generateKey(config)
    
    try {
      const cached = await this.storage.get(key)
      if (cached && !this.isExpired(cached)) {
        this.updateStats('hit')
        return cached.data
      }
    } catch (error) {
      console.warn('Cache get error:', error)
    }
    
    this.updateStats('miss')
    return null
  }

  async set<T>(
    config: RequestConfig, 
    response: ResponseData<T>,
    options?: CacheOptions
  ): Promise<void> {
    const key = this.generateKey(config)
    const ttl = options?.ttl ?? this.config.ttl
    
    const cacheItem: CacheItem = {
      data: response,
      timestamp: Date.now(),
      ttl,
      metadata: {
        tags: options?.tags,
        dependencies: options?.dependencies
      }
    }
    
    await this.storage.set(key, cacheItem)
    this.updateIndexes(key, options)
  }
}
```

### 5. 重试管理器

```typescript
class RetryManager {
  private config: RetryConfig

  async execute<T>(
    requestFn: () => Promise<ResponseData<T>>,
    config: RequestConfig
  ): Promise<ResponseData<T>> {
    let lastError: Error
    let attempt = 0
    
    while (attempt < this.config.maxAttempts) {
      try {
        return await requestFn()
      } catch (error) {
        lastError = error
        attempt++
        
        if (!this.shouldRetry(error, attempt)) {
          break
        }
        
        const delay = this.calculateDelay(attempt)
        await this.sleep(delay)
      }
    }
    
    throw lastError
  }

  private shouldRetry(error: Error, attempt: number): boolean {
    if (attempt >= this.config.maxAttempts) {
      return false
    }
    
    if (this.config.condition) {
      return this.config.condition(error as HttpError)
    }
    
    // 默认重试条件
    return this.isRetryableError(error)
  }

  private calculateDelay(attempt: number): number {
    if (this.config.delayFn) {
      return this.config.delayFn(attempt)
    }
    
    switch (this.config.backoff) {
      case 'exponential':
        return this.config.delay * Math.pow(2, attempt - 1)
      case 'linear':
        return this.config.delay * attempt
      default:
        return this.config.delay
    }
  }
}
```

### 6. 并发控制管理器

```typescript
class ConcurrencyManager {
  private activeRequests = new Set<string>()
  private requestQueue: RequestTask[] = []
  private deduplicationManager: DeduplicationManager

  async execute<T>(
    requestFn: () => Promise<ResponseData<T>>,
    config: RequestConfig
  ): Promise<ResponseData<T>> {
    // 去重检查
    if (this.config.deduplication) {
      const key = this.generateDeduplicationKey(config)
      return this.deduplicationManager.execute(key, () => 
        this.executeWithConcurrencyControl(requestFn, config)
      )
    }
    
    return this.executeWithConcurrencyControl(requestFn, config)
  }

  private async executeWithConcurrencyControl<T>(
    requestFn: () => Promise<ResponseData<T>>,
    config: RequestConfig
  ): Promise<ResponseData<T>> {
    return new Promise((resolve, reject) => {
      const task: RequestTask<T> = {
        id: this.generateTaskId(),
        execute: requestFn,
        resolve,
        reject,
        config
      }
      
      if (this.activeRequests.size < this.config.maxConcurrent) {
        this.executeTask(task)
      } else {
        this.enqueueTask(task)
      }
    })
  }
}
```

## 数据流设计

### 请求处理流程

```
用户请求
    ↓
配置预处理
    ↓
请求拦截器链
    ↓
缓存检查 ──→ 缓存命中 ──→ 响应拦截器链 ──→ 返回结果
    ↓ 缓存未命中
并发控制检查
    ↓
去重检查 ──→ 去重命中 ──→ 等待结果 ──→ 返回结果
    ↓ 去重未命中
重试管理器
    ↓
适配器执行
    ↓
错误处理 ──→ 重试 ──→ 适配器执行
    ↓ 成功
缓存存储
    ↓
响应拦截器链
    ↓
返回结果
```

### 错误处理流程

```
请求错误
    ↓
错误分类
    ↓
错误恢复策略
    ↓
恢复成功? ──→ 是 ──→ 继续请求
    ↓ 否
重试检查
    ↓
可重试? ──→ 是 ──→ 重试延迟 ──→ 重新请求
    ↓ 否
错误拦截器
    ↓
错误统计
    ↓
抛出错误
```

## 模块依赖关系

### 核心依赖图

```
HttpClient
├── HttpAdapter (接口)
│   ├── FetchAdapter
│   ├── AxiosAdapter
│   └── AlovaAdapter
├── InterceptorManager
├── CacheManager
│   ├── CacheStorage (接口)
│   │   ├── MemoryCacheStorage
│   │   └── LocalStorageCacheStorage
│   └── CacheStrategy (接口)
│       ├── LRUStrategy
│       ├── LFUStrategy
│       └── TTLStrategy
├── RetryManager
├── ConcurrencyManager
│   └── DeduplicationManager
└── ErrorHandler
    ├── ErrorRecoveryStrategy (接口)
    └── ErrorAnalyzer
```

### 类型系统依赖

```
types/index.ts (核心类型)
├── RequestConfig
├── ResponseData
├── HttpError
├── CacheConfig
├── RetryConfig
└── ConcurrencyConfig

types/utils.ts (工具类型)
├── TypeGuards
├── UtilityTypes
├── ConditionalTypes
└── HelperFunctions
```

## 扩展点设计

### 1. 适配器扩展

```typescript
// 自定义适配器
class CustomAdapter extends BaseAdapter {
  name = 'custom'
  
  async request(config: RequestConfig): Promise<ResponseData> {
    // 自定义实现
  }
}

// 注册适配器
const client = createHttpClient({
  adapter: new CustomAdapter()
})
```

### 2. 中间件扩展

```typescript
// 自定义中间件
const customMiddleware = async (config: RequestConfig, next: NextFunction) => {
  // 前置处理
  console.log('Request start:', config.url)
  
  const response = await next(config)
  
  // 后置处理
  console.log('Request end:', response.status)
  
  return response
}

client.use(customMiddleware)
```

### 3. 拦截器扩展

```typescript
// 自定义拦截器
const customInterceptor = {
  request: (config: RequestConfig) => {
    // 请求预处理
    return config
  },
  response: (response: ResponseData) => {
    // 响应后处理
    return response
  },
  responseError: (error: HttpError) => {
    // 错误处理
    return Promise.reject(error)
  }
}

client.addRequestInterceptor(customInterceptor.request)
client.addResponseInterceptor(customInterceptor.response, customInterceptor.responseError)
```

### 4. 缓存策略扩展

```typescript
// 自定义缓存策略
class CustomCacheStrategy implements CacheStrategy {
  async get(key: string): Promise<any> {
    // 自定义获取逻辑
  }
  
  async set(key: string, value: any): Promise<void> {
    // 自定义存储逻辑
  }
  
  async delete(key: string): Promise<void> {
    // 自定义删除逻辑
  }
}

const cacheManager = createAdvancedCacheManager({
  strategy: new CustomCacheStrategy()
})
```

这种架构设计确保了系统的可扩展性、可维护性和高性能，同时保持了良好的代码组织和清晰的职责分离。
